<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ElasticSearch服务部署</title>
    <link href="/ElasticSearch/ElasticSearch%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"/>
    <url>/ElasticSearch/ElasticSearch%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch服务部署"><a href="#ElasticSearch服务部署" class="headerlink" title="ElasticSearch服务部署"></a>ElasticSearch服务部署</h1><p>ElasticSearch：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.8/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.8/index.html</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>​        Elasticsearch是一个开源的分布式、RESTful 风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene。</p><p>​        Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库——无论是开源还是私有，但它也仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。 更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理，因为Lucene 非常复杂。<br>   为了解决Lucene使用时的繁复性，于是Elasticsearch便应运而生。它使用 Java 编写，内部采用 Lucene 做索引与搜索，但是它的目标是使全文检索变得更简单，简单来说，就是对Lucene 做了一层封装，它提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索。</p><p>​        当然，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确地形容：</p><ul><li>一个分布式的实时文档存储，每个字段可以被索引与搜索；</li><li>一个分布式实时分析搜索引擎；</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li></ul><p>​        由于Elasticsearch的功能强大和使用简单，维基百科、卫报、Stack Overflow、GitHub等都纷纷采用它来做搜索。现在，Elasticsearch已成为全文搜索领域的主流软件之一。</p><h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ul><li><p>CentOS 7</p><p>具体ES支持的操作系统版本可以在该网址下对照：<a href="https://www.elastic.co/cn/support/matrix" target="_blank" rel="noopener">https://www.elastic.co/cn/support/matrix</a></p></li></ul><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li><p>JDK1.8 </p><p>ES运行需要JAVA环境，我使用的是CentOS 7自带的JDK1.8版本，安装ES前先检查JAVA版本，若未安装JDK请先下载 <a href="http://openjdk.java.net/" target="_blank" rel="noopener">OpenJDK</a> </p></li><li><p>Elasticsearch 7.8.0：数据存储，查询，分析</p><p><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></p></li><li><p>Kinbana 7.8.0：数据可视化web客户端</p><p><a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/kibana</a></p></li></ul><p><strong>如果要使用Kibana一定要确保和ES的版本一致</strong></p><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><h3 id="Elasticsearch部署"><a href="#Elasticsearch部署" class="headerlink" title="Elasticsearch部署"></a>Elasticsearch部署</h3><ul><li>解压软件</li></ul><pre><code class="sh">$ tar -xzf elasticsearch-7.8.0-linux-x86_64.tar.gz$ cd elasticsearch-7.8.0/</code></pre><ul><li><p>修改配置文件</p><p>vi /config/elasticsearch.yml</p></li></ul><pre><code>cluster.name: switch-es        //ES集群名字，如果是多节点部署会通过集群名字来组合成为一个集群node.name: node-1            //该节点的名字path.data: /usr/local/src/elasticsearch-7.8.0/data    //数据存储位置path.logs: /usr/local/src/elasticsearch-7.8.0/logs    //日志存储位置network.host: 0.0.0.0    //设置0.0.0.0即配置外网ip#http.port: 9200        //端口号cluster.initial_master_nodes: [&quot;node-1&quot;]    初始化节点，单机部署需要与节点的名字一致</code></pre><ul><li><p>启动es服务</p><p>ES服务不能在root权限下启动，所以需要先新建一个普通账户来启动</p><pre><code>$ useradd es                        //新建账户es$ chown -R es elasticsearch-7.8.0     //修改es目录的所属者$ su es                                //切换到es账户下$ ./bin/elasticsearch                //启动es服务 ./bin/elasticsearch -d 后台运行</code></pre></li><li><p>可能遇到的问题</p><p>① <strong>无法通过ip地址访问</strong></p><p>确认配置无误后，关闭防火墙</p><p>② <strong>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</strong></p><p>每个进程最大同时打开文件数太小</p><p>修改 /etc/security/limits.conf 文件，增加如下配置，用户退出后重新登录生效</p><pre><code class="bash">* soft nofile 65536* hard nofile 65536</code></pre><p>③ <strong>max number of threads [3818] for user [es] is too low, increase to at least [4096]</strong></p><p>最大线程个数太低</p><p>同上修改 /etc/security/limits.conf 文件，增加如下配置，用户退出后重新登录生效</p><pre><code class="bash">* soft nproc 4096* hard nproc 4096</code></pre><p>④ <strong>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</strong></p><p>一个进程能拥有的最多的内存区域</p><p>修改 /etc/sysctl.conf 文件，增加如下配置，执行命令「 sysctl -p 」生效</p><pre><code class="bash">vm.max_map_count=262144</code></pre></li><li><p>验证成功</p></li></ul><p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596352542238.png" srcset="/img/loading.gif" alt="1596352542238"></p><h3 id="Kibana部署"><a href="#Kibana部署" class="headerlink" title="Kibana部署"></a>Kibana部署</h3><ul><li>解压软件包</li></ul><pre><code class="sh">$ tar -xzf kibana-7.8.0-linux-x86_64.tar.gz$ cd kibana-7.8.0-linux-x86_64/ </code></pre><ul><li><p>修改配置文件</p><p>vi /config/kibana.yml</p></li></ul><pre><code>server.port: 5601            //kibana服务端口server.host: &quot;0.0.0.0&quot;        //配置外网ipelasticsearch.hosts: [&quot;http://localhost:9200&quot;]        //链接es服务器地址</code></pre><ul><li><p>启动Kibana</p><pre><code>./bin/kibana --allow-root</code></pre></li><li><p>验证成功</p><p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596352655275.png" srcset="/img/loading.gif" alt="1596352655275"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Storage BigData</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IRP Description</title>
    <link href="/Security/IRP-Description/"/>
    <url>/Security/IRP-Description/</url>
    
    <content type="html"><![CDATA[<h1 id="Widnows-Kernel-I-O-request-packets"><a href="#Widnows-Kernel-I-O-request-packets" class="headerlink" title="Widnows Kernel I/O request packets"></a>Widnows Kernel I/O request packets</h1><h2 id="0x01-I-O管理器"><a href="#0x01-I-O管理器" class="headerlink" title="0x01 I/O管理器"></a>0x01 I/O管理器</h2><p>Windows I/O管理器为系统内核模式下提供一致的数据流接口，从上层发送下来的请求数据包会按照统一的格式封装成为一个IRP数据包，经过各类过滤层，文件系统，中间层最终流到最底层。理解I/O管理器中IRP的工作原理对于理解Windows内核有很重要的意义。因为所有的请求调用无非都是数据包的传递。</p>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InfinityHook</title>
    <link href="/Security/InfinityHook/"/>
    <url>/Security/InfinityHook/</url>
    
    <content type="html"><![CDATA[<h1 id="InfinityHook原理与实现"><a href="#InfinityHook原理与实现" class="headerlink" title="InfinityHook原理与实现"></a>InfinityHook原理与实现</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文所述的Hook技术非本人原创，偶然在git上看到某开源项目InfinityHook，拜读其源码后略微解读了InfinityHook的原理。</p><p>参考资料：    <a href="https://github.com/everdox/InfinityHook" target="_blank" rel="noopener">https://github.com/everdox/InfinityHook</a></p><p>​                       <a href="https://bbs.pediy.com/thread-253450.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-253450.htm</a></p><h2 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h2><p>熟悉Hook技术的都应该知道，Hook技术一般是通过挂钩系统调用，上下文切换，页面错误，DPC等，对系统内核调用进行过滤/拦截/修改等操作。一般使用较多的Hook技术主要有SSDT Hook/InLine Hook/IDT Hook等。</p><p>Hook技术的确是一种很强大技术，在windows闭源的背景下可以让内核开发工程师进行更接近windows底层进行安全功能的开发。同样，有安全就有攻击，不少恶意代码也通过同样的技术来进行恶意攻击。为此自windows vista后微软为限制人为非法修改windows系统内核，引入了PG（PatchGuard）机制。当PG检测到系统内核被篡改后会直接触发0x00000109蓝屏，因此Hook技术在商业软件中已不再适用。</p><p>但是接下来讲的InfinityHook具有极高的便携性与稳定性，它利用了windows的Event Tracing机制，到目前为止微软尚未修复该漏洞，因此InfinityHook可以与PatchGuard兼容运行。</p><h2 id="0x02-ETW-Event-Tracing-for-Windows"><a href="#0x02-ETW-Event-Tracing-for-Windows" class="headerlink" title="0x02 ETW  (Event Tracing for Windows)"></a>0x02 ETW  (Event Tracing for Windows)</h2><p>如前文所述，InfinityHook是利用了ETW的漏洞所产生的一种Hook技术，因此在进行hook之前我们需要对windows ETW机制有所理解。</p><p>Windows事件跟踪（ETW）是一种有效的内核级跟踪工具，可用于将内核或应用程序定义的事件记录到日志文件中。 您可以实时使用事件或从日志文件使用事件，然后使用它们调试应用程序或确定应用程序中发生性能问题的位置。</p><p>ETW使您可以动态地启用或禁用事件跟踪，从而使您可以在生产环境中执行详细的跟踪而无需重新启动计算机或应用程序。</p><p>事件跟踪API分为三个不同的组件：</p><ul><li>控制器，用于启动和停止事件跟踪会话并启用提供程序</li><li>提供者，提供事件</li><li>提供者，消费事件</li></ul><p>下图显示了事件跟踪模型：</p><p><img src="E:%5CGitBlog%5Csource%5Cimg_post%5Cetdiag2.png" srcset="/img/loading.gif" alt></p><p>控制器通常创建并定义跟踪会话。跟踪会话包括名称，标识符GUID，有关内核应如何为使用者进行序列化和准备数据的标志以及有关为该会话启用了哪些提供程序的信息。控制器还可以管理和修改现有的内置跟踪会话。控制器完成上述所有工作的主要接口是通过NtTraceControl API。</p><p>提供者将事件数据提供给记录器会话。通常是通过NtTraceEvent API或等效的内核EtwWrite。根据控制器如何建立会话，先前知道事件数据的使用者可以实时使用数据，文件或偶尔从循环缓冲区中使用数据。</p><p>要了解有关ETW内部的更多信息，请阅读：</p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/etw/about-event-tracing" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/etw/about-event-tracing</a></p><h2 id="0x03-InfinityHook的原理"><a href="#0x03-InfinityHook的原理" class="headerlink" title="0x03 InfinityHook的原理"></a>0x03 InfinityHook的原理</h2><p>通过上述介绍，我们大概可以知道InfinityHook实际上是通过ETW机制，在windows内核配置和启动内核会话记录器。</p><p>但如何在R0开启NT Kernel Logger Session呢？</p><p>我们可以参考微软官方文档中R3 Configuring and Starting the NT Kernel Logger Session先理解应用层的配置方式，内核层的配置方式也与其相似。</p><p>参考：<a href="https://docs.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-the-nt-kernel-logger-session" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-the-nt-kernel-logger-session</a></p><p>NT Kernel Logger会话是一个事件跟踪会话，它记录一组预定义的内核事件。您不调用EnableTrace函数来启用内核提供程序。而是使用EVENT_TRACE_PROPERTIES结构的EnableFlags成员指定要接收的内核事件。 StartTrace函数使用您指定的启用标志来启用内核提供程序。</p><p>只有一个NT Kernel Logger会话。如果会话已在使用中，则StartTrace函数将返回ERROR_ALREADY_EXISTS。</p><p>截取部分代码：</p><pre><code class="c++">TRACEHANDLE SessionHandle = 0;EVENT_TRACE_PROPERTIES* pSessionProperties = NULL;ULONG BufferSize = 0;// Allocate memory for the session properties. The memory must// be large enough to include the log file name and session name,// which get appended to the end of the session properties structure.BufferSize = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(LOGFILE_PATH) + sizeof(KERNEL_LOGGER_NAME);pSessionProperties = (EVENT_TRACE_PROPERTIES*)malloc(BufferSize);if (NULL == pSessionProperties){    wprintf(L&quot;Unable to allocate %d bytes for properties structure.\n&quot;, BufferSize);    goto cleanup;}// Set the session properties. You only append the log file name// to the properties structure; the StartTrace function appends// the session name for you.ZeroMemory(pSessionProperties, BufferSize);pSessionProperties-&gt;Wnode.BufferSize = BufferSize;pSessionProperties-&gt;Wnode.Flags = WNODE_FLAG_TRACED_GUID;pSessionProperties-&gt;Wnode.ClientContext = 1; //QPC clock resolutionpSessionProperties-&gt;Wnode.Guid = SystemTraceControlGuid;pSessionProperties-&gt;EnableFlags = EVENT_TRACE_FLAG_NETWORK_TCPIP;pSessionProperties-&gt;LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;pSessionProperties-&gt;MaximumFileSize = 5;  // 5 MBpSessionProperties-&gt;LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);pSessionProperties-&gt;LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(KERNEL_LOGGER_NAME);StringCbCopy((LPWSTR)((char*)pSessionProperties + pSessionProperties-&gt;LogFileNameOffset), sizeof(LOGFILE_PATH), LOGFILE_PATH);// Create the trace session.status = StartTrace((PTRACEHANDLE)&amp;SessionHandle, KERNEL_LOGGER_NAME, pSessionProperties);</code></pre><p>可以看到配置的方式也是比较简明</p><p>首先定义一个EVENT_TRACE_PROPERTIES结构的对象，然后填充结构体，最后调用StartTrace函数创建会话。</p><p>在这里比较关键的就是EVENT_TRACE_PROPERTIES结构，结构定义如下：</p><pre><code class="c++">typedef struct _EVENT_TRACE_PROPERTIES {  WNODE_HEADER Wnode;  ULONG        BufferSize;  ULONG        MinimumBuffers;  ULONG        MaximumBuffers;  ULONG        MaximumFileSize;  ULONG        LogFileMode;  ULONG        FlushTimer;  ULONG        EnableFlags;  LONG         AgeLimit;  ULONG        NumberOfBuffers;  ULONG        FreeBuffers;  ULONG        EventsLost;  ULONG        BuffersWritten;  ULONG        LogBuffersLost;  ULONG        RealTimeBuffersLost;  HANDLE       LoggerThreadId;  ULONG        LogFileNameOffset;  ULONG        LoggerNameOffset;} EVENT_TRACE_PROPERTIES, *PEVENT_TRACE_PROPERTIES;</code></pre><p>StartTrace定义如下：</p><pre><code class="c++">ULONG StartTrace(  _Out_   PTRACEHANDLE            SessionHandle,  _In_    LPCTSTR                 SessionName,  _Inout_ PEVENT_TRACE_PROPERTIES Properties);</code></pre><p>在上面的代码中我们可以看到一个比较特殊的地方：</p><pre><code class="c++">BufferSize = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(LOGFILE_PATH) + sizeof(KERNEL_LOGGER_NAME);</code></pre><p>我们StartTrace开启会话时传入的pSessionProperties对象Buffer不止EVENT_TRACE_PROPERTIES结构体大小，还包含了LOGFILE_PATH与KERNEL_LOGGER_NAME长度。</p><h2 id="0x04-InfinityHook的实现"><a href="#0x04-InfinityHook的实现" class="headerlink" title="0x04 InfinityHook的实现"></a>0x04 InfinityHook的实现</h2><p>首先，因为ETW中许多函数与结构为导出，所以需要自行定义。</p><p>参考git上源码，我们需要定义一个CKCL_TRACE_PROPERTIES结构，继承于EVENT_TRACE_PROPERTIES</p><pre><code class="c++">//// To enable/disable tracing on the circular kernel context logger.//typedef struct _CKCL_TRACE_PROPERIES: EVENT_TRACE_PROPERTIES{    ULONG64                    Unknown[3];    UNICODE_STRING            ProviderName;} CKCL_TRACE_PROPERTIES, *PCKCL_TRACE_PROPERTIES;</code></pre><p>定义一个CKCL_TRACE_PROPERTIES对象，为其申请PAGE_SIZE大小的内存并清零。</p><pre><code class="c++">    PCKCL_TRACE_PROPERTIES Property = (PCKCL_TRACE_PROPERTIES)ExAllocatePool(NonPagedPool, PAGE_SIZE);    if (!Property)    {        return STATUS_MEMORY_NOT_ALLOCATED;    }    memset(Property, 0, PAGE_SIZE);</code></pre><p>填充结构内容：</p><pre><code class="c++">    Property-&gt;Wnode.BufferSize = PAGE_SIZE;    Property-&gt;Wnode.Flags = WNODE_FLAG_TRACED_GUID;    Property-&gt;ProviderName = RTL_CONSTANT_STRING(L&quot;Circular Kernel Context Logger&quot;);    Property-&gt;Wnode.Guid = CkclSessionGuid;    Property-&gt;Wnode.ClientContext = 1;    Property-&gt;BufferSize = sizeof(ULONG);    Property-&gt;MinimumBuffers = Property-&gt;MaximumBuffers = 2;    Property-&gt;LogFileMode = EVENT_TRACE_BUFFERING_MODE;</code></pre><p>最后通过ZwTraceControl启动/停止/更新来控制 CKCL 事件跟踪会话</p><pre><code class="c++">//// Might be wise to actually hook ZwTraceControl so folks don&#39;t // disable your infinity hook ;).//switch (Operation){    case CKCL_TRACE_START:    {        Status = ZwTraceControl(EtwpStartTrace, Property, PAGE_SIZE, Property, PAGE_SIZE, &amp;ReturnLength);        break;    }    case CKCL_TRACE_END:    {        Status = ZwTraceControl(EtwpStopTrace, Property, PAGE_SIZE, Property, PAGE_SIZE, &amp;ReturnLength);        break;    }    case CKCL_TRACE_SYSCALL:    {        //        // Add more flags here to trap on more events!        //        Property-&gt;EnableFlags = EVENT_TRACE_FLAG_SYSTEMCALL;        Status = ZwTraceControl(EtwpUpdateTrace, Property, PAGE_SIZE, Property, PAGE_SIZE, &amp;ReturnLength);        break;    }}</code></pre><p>这里要注意的是我们需要设置Property-&gt;EnableFlags = EVENT_TRACE_FLAG_SYSTEMCALL这样的话每次触发syscall都会被记录器捕捉。</p><p>接着我们需要解析EtwpDebuggerData获得当前ETW会话中上下文WMI_LOGGER_CONTEXTS，找到CKCL并使用GetCpuClock指针覆盖原地址。</p><p>这样一来，当每次触发CKCL事件跟踪器，GetCpuClock就会被调用，从而跳转到我们已经替换的IfhpInternalGetCpuClock执行。通过一系列判断得到syscall地址后，与我们需要hook的内核API地址比较，若相等则跳转到我们自己的Fake函数中执行。</p><pre><code class="c++">static ULONG64 IfhpInternalGetCpuClock(){    if (ExGetPreviousMode() == KernelMode)    {        return __rdtsc();    }    //    // Extract the system call index (if you so desire).    //    PKTHREAD CurrentThread = (PKTHREAD)__readgsqword(OFFSET_KPCR_CURRENT_THREAD);    unsigned int SystemCallIndex = *(unsigned int*)((uintptr_t)CurrentThread + OFFSET_KTHREAD_SYSTEM_CALL_NUMBER);    PVOID* StackMax = (PVOID*)__readgsqword(OFFSET_KPCR_RSP_BASE);    PVOID* StackFrame = (PVOID*)_AddressOfReturnAddress();    //    // First walk backwards on the stack to find the 2 magic values.    //    for (PVOID* StackCurrent = StackMax;         StackCurrent &gt; StackFrame;        --StackCurrent)    {        //         // This is intentionally being read as 4-byte magic on an 8        // byte aligned boundary.        //        PULONG AsUlong = (PULONG)StackCurrent;        if (*AsUlong != INFINITYHOOK_MAGIC_1)        {            continue;        }        //         // If the first magic is set, check for the second magic.        //        --StackCurrent;        PUSHORT AsShort = (PUSHORT)StackCurrent;        if (*AsShort != INFINITYHOOK_MAGIC_2)        {            continue;        }        //        // Now we reverse the direction of the stack walk.        //        for (;            StackCurrent &lt; StackMax;            ++StackCurrent)        {            PULONGLONG AsUlonglong = (PULONGLONG)StackCurrent;            if (!(PAGE_ALIGN(*AsUlonglong) &gt;= SystemCallEntryPage &amp;&amp;                 PAGE_ALIGN(*AsUlonglong) &lt; (PVOID)((uintptr_t)SystemCallEntryPage + (PAGE_SIZE * 2))))            {                continue;            }            //            // If you want to &quot;hook&quot; this function, replace this stack memory             // with a pointer to your own function.            //            void** SystemCallFunction = &amp;StackCurrent[9];            if (IfhpCallback)            {                IfhpCallback(SystemCallIndex, SystemCallFunction);            }            break;        }        break;    }    return __rdtsc();}</code></pre><p>最后是卸载hook，因为我们仅需要重启CKCL事件跟踪会话即可。</p><h2 id="0x05-结论"><a href="#0x05-结论" class="headerlink" title="0x05 结论"></a>0x05 结论</h2><p>因为时间原因，不对其中具体的分析进行描述，可以参考前言中git源码与看雪的原文进行验证。</p>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Driver Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT 开发基础</title>
    <link href="/MQTT/MQTT-%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/MQTT/MQTT-%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="了解MQTT协议"><a href="#了解MQTT协议" class="headerlink" title="了解MQTT协议"></a>了解MQTT协议</h1><p><strong>MQTT 是一种连接协议，它指定了如何组织数据字节并通过 TCP/IP 网络传输它们。但实际上，开发人员并不需要了解这个连接协议。我们只需要知道，每条消息有一个命令和数据有效负载。该命令定义消息类型（例如 CONNECT 消息或 SUBSCRIBE 消息）。所有 MQTT 库和工具都提供了直接处理这些消息的简单方法，并能自动填充一些必需的字段，比如消息和客户端 ID。</strong></p><hr><p>首先，客户端发送一条 CONNECT 消息来连接代理。CONNECT 消息要求建立从客户端到代理的连接。CONNECT 消息包含以下内容参数。</p><table><thead><tr><th align="left">参数</th><th>说明</th></tr></thead><tbody><tr><td align="left">cleanSession</td><td>此标志指定连接是否是持久性的。持久会话会将所有订阅和可能丢失的消息（具体取决于 QoS） 都存储在代理中。</td></tr><tr><td align="left">username</td><td>代理的身份验证和授权凭证。</td></tr><tr><td align="left">password</td><td>代理的身份验证和授权凭证。</td></tr><tr><td align="left">lastWillTopic</td><td>连接意外中断时，代理会自动向某个主题发送一条 “last will” 消息。</td></tr><tr><td align="left">lastWillQos</td><td>“last will” 消息的 QoS。</td></tr><tr><td align="left">lastWillMessage</td><td>“last will” 消息本身。</td></tr><tr><td align="left">keepAlive</td><td>这是客户端通过 ping 代理来保持连接有效所需的时间间隔。</td></tr></tbody></table><hr><p>客户端收到来自代理的一条 CONNACK 消息。CONNACK 消息包含以下内容参数。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>sessionPresent</td><td>此参数表明连接是否已有一个持久会话。也就是说，连接已订阅了主题，而且会接收丢失的消息。</td></tr><tr><td>returnCode</td><td>0 表示成功。其他值指出了失败的原因。</td></tr></tbody></table><hr><p>建立连接后，客户端然后会向代理发送一条或多条 SUBSCRIBE 消息，表明它会从代理接收针对某些主题的消息。消息可以包含一个或多个重复的参数</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>qos</td><td>qos（服务质量或 QoS）标志表明此主题范围内的消息传送到客户端所需的一致程度。<br>值 0：不可靠，消息基本上仅传送一次，如果当时客户端不可用，则会丢失该消息。<br>值 1：消息应传送至少 1 次。<br>值 2：消息仅传送一次。</td></tr><tr><td>topic</td><td>要订阅的主题。一个主题可以有多个级别，级别之间用斜杠字符分隔。例如，“sys/hps100/request” 和 “sys/hps100/push” 是有效的主题。</td></tr></tbody></table><hr><p>客户端成功订阅某个主题后，代理会返回一条 SUBACK 消息，其中包含一个或多个 returnCode 参数。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>returnCode</td><td>SUBCRIBE 命令中的每个主题都有一个返回代码。返回值如下所示。<br>值 0 - 2：成功达到相应的 QoS 级别。<br>值 128：失败。</td></tr></tbody></table><hr><p>与 SUBSCRIBE 消息对应，客户端也可以通过 UNSUBSCRIBE 消息取消订阅一个或多个主题。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>topic</td><td>此参数可重复用于多个主题。</td></tr></tbody></table><hr><p>客户端可向代理发送 PUBLISH 消息。该消息包含一个主题和数据有效负载。代理然后将消息转发给所有订阅该主题的客户端</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>topicName</td><td>发布的消息的相关主题。</td></tr><tr><td>qos</td><td>消息传递的服务质量水平。</td></tr><tr><td>retainFlag</td><td>此标志表明代理是否保留该消息作为针对此主题的最后一条已知消息。</td></tr><tr><td>payload</td><td>消息中的实际数据。它可以是文本字符串或二进制大对象数据。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT 协议 3.1.1</title>
    <link href="/Network/MQTT-%E5%8D%8F%E8%AE%AE-3-1-1/"/>
    <url>/Network/MQTT-%E5%8D%8F%E8%AE%AE-3-1-1/</url>
    
    <content type="html"><![CDATA[<h1 id="MQTT协议3-1-1中文版"><a href="#MQTT协议3-1-1中文版" class="headerlink" title="MQTT协议3.1.1中文版"></a>MQTT协议3.1.1中文版</h1><hr><ul><li><a href="https://www.oasis-open.org/committees/mqtt/" target="_blank" rel="noopener">OASIS标准</a> 2014年10月29日</li></ul><h2 id="规范链接-Specification-URIs"><a href="#规范链接-Specification-URIs" class="headerlink" title="规范链接 (Specification URIs)"></a>规范链接 (Specification URIs)</h2><h3 id="当前版本-This-version-："><a href="#当前版本-This-version-：" class="headerlink" title="当前版本(This version)："></a>当前版本(This version)：</h3><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.doc" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.doc</a> (Authoritative)</p><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></p><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.pdf" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.pdf</a></p><h3 id="以前的版本-Previous-version-："><a href="#以前的版本-Previous-version-：" class="headerlink" title="以前的版本(Previous version)："></a>以前的版本(Previous version)：</h3><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/cos01/mqtt-v3.1.1-cos01.doc" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/cos01/mqtt-v3.1.1-cos01.doc</a> (Authoritative)</p><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/cos01/mqtt-v3.1.1-cos01.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/cos01/mqtt-v3.1.1-cos01.html</a></p><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/cos01/mqtt-v3.1.1-cos01.pdf" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/cos01/mqtt-v3.1.1-cos01.pdf</a></p><h3 id="最新版本-Latest-version-："><a href="#最新版本-Latest-version-：" class="headerlink" title="最新版本(Latest version)："></a>最新版本(Latest version)：</h3><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.doc" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.doc</a> (Authoritative)</p><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html</a></p><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.pdf" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.pdf</a></p><h3 id="技术委员会-Technical-Committee-："><a href="#技术委员会-Technical-Committee-：" class="headerlink" title="技术委员会(Technical Committee)："></a>技术委员会(Technical Committee)：</h3><p><a href="https://www.oasis-open.org/committees/mqtt/" target="_blank" rel="noopener">结构化信息标准促进组织MQTT技术委员会</a></p><h4 id="主席-Chairs-："><a href="#主席-Chairs-：" class="headerlink" title="主席(Chairs)："></a>主席(Chairs)：</h4><p>拉斐尔·J·科恩 (), 个人</p><p>理查德·J·科彭 (), <a href="http://www.ibm.com/" target="_blank" rel="noopener">IBM</a></p><h4 id="编辑-Editors-："><a href="#编辑-Editors-：" class="headerlink" title="编辑(Editors)："></a>编辑(Editors)：</h4><p>安德鲁·班克斯 (), <a href="http://www.ibm.com/" target="_blank" rel="noopener">IBM</a></p><p>拉胡尔·吉普塔 (), <a href="http://www.ibm.com/" target="_blank" rel="noopener">IBM</a></p><h3 id="相关文档-Related-work-："><a href="#相关文档-Related-work-：" class="headerlink" title="相关文档(Related work)："></a>相关文档(Related work)：</h3><h4 id="本规范与此有关："><a href="#本规范与此有关：" class="headerlink" title="本规范与此有关："></a>本规范与此有关：</h4><ul><li>MQTT和NIST网络安全框架1.0版. 编辑是杰夫·布朗和路易·菲利普·拉穆勒. 最新版本： <a href="http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html</a>.</li></ul><h3 id="摘要-Abstract"><a href="#摘要-Abstract" class="headerlink" title="摘要 (Abstract)"></a>摘要 (Abstract)</h3><p>MQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议. 它的设计思想是轻巧、开放、简单、规范, 因此易于实现. 这些特点使得它对很多场景来说都是很好的选择, 包括受限的环境如机器与机器的通信(M2M)以及物联网环境(IoT), 这些场景要求很小的代码封装或者网络带宽非常昂贵.</p><p>本协议运行在TCP/IP, 或其它提供了有序、可靠、双向连接的网络连接上. 它有以下特点：</p><ul><li>使用发布/订阅消息模式, 提供了一对多的消息分发和应用之间的解耦.</li><li>消息传输不需要知道负载内容.</li><li>提供三种等级的服务质量：.<ul><li>“<code>最多一次</code>”, 尽操作环境所能提供的最大努力分发消息. 消息可能会丢失. 例如, 这个等级可用于环境传感器数据, 单次的数据丢失没关系, 因为不久之后会再次发送.</li><li>“<code>至少一次</code>”, 保证消息可以到达, 但是可能会重复.</li><li>“<code>仅一次</code>”, 保证消息只到达一次. 例如, 这个等级可用在一个计费系统中, 这里如果消息重复或丢失会导致不正确的收费.</li></ul></li><li>很小的传输消耗和协议数据交换, 最大限度减少网络流量</li><li>异常连接断开发生时, 能通知到相关各方.</li></ul><h3 id="状态-Status"><a href="#状态-Status" class="headerlink" title="状态 (Status)"></a>状态 (Status)</h3><p>本文档最后由OASIS成员在上面标示的日期最终修订或批准. 批准的级别也在上面列出了. 如果要查看本文档最新的修订版请检查上面的 <em>最新版本</em> 位置. 技术委员会产生的其它修订版和其它技术文档都列在这里：<a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt#technical" target="_blank" rel="noopener">https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt#technical</a> .</p><p>技术委员会成员对本规范的评论应该发送到技术委员会的邮件列表. 其他人应该发送评论到技术委员会的公共评论列表, 方法是点击技术委员会网站的 <a href="https://www.oasis-open.org/committees/comments/index.php?wg_abbrev=mqtt" target="_blank" rel="noopener">发送评论</a> 按钮, 网页地址是 <a href="https://www.oasis-open.org/committees/mqtt/" target="_blank" rel="noopener">https://www.oasis-open.org/committees/mqtt/</a> .</p><p>关于实现本规范必不可少的任何专利是否已公开, 以及其它的专利许可条款相关的信息, 请参考技术委员会网站的知识产权部分((<a href="https://www.oasis-open.org/committees/mqtt/ipr.php" target="_blank" rel="noopener">https://www.oasis-open.org/committees/mqtt/ipr.php</a>).</p><h3 id="引用格式-Citation-format-："><a href="#引用格式-Citation-format-：" class="headerlink" title="引用格式(Citation format)："></a>引用格式(Citation format)：</h3><p>引用此规范时应该使用下面的引文格式：</p><p><strong>[mqtt-v3.1.1]</strong></p><p><em>MQTT Version 3.1.1</em>. Edited by Andrew Banks and Rahul Gupta<em>.</em> 29 October 2014. OASIS Standard. <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a>. Latest version: <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html</a>.</p><h3 id="文档链接"><a href="#文档链接" class="headerlink" title="文档链接"></a>文档链接</h3><ul><li><a href="https://github.com/mcxiaoke/mqtt" target="_blank" rel="noopener">MQTT协议3.1.1中文翻译项目</a></li><li><a href="https://github.com/mcxiaoke/mqtt/blob/master/protocol/MQTT-3.1.1-CN.pdf" target="_blank" rel="noopener">MQTT协议3.1.1中文版PDF</a></li></ul><h2 id="修订记录"><a href="#修订记录" class="headerlink" title="修订记录"></a>修订记录</h2><table><thead><tr><th align="left"><strong>版 本</strong></th><th align="left"><strong>日 期</strong></th><th align="left"><strong>发布说明</strong></th></tr></thead><tbody><tr><td align="left">1.0.0</td><td align="left">2015-07-30</td><td align="left">翻译全部文本, 完成初步审校, 公开发布第一版</td></tr><tr><td align="left">1.0.1</td><td align="left">2015-10-22</td><td align="left">修订几处笔误, 增补几处未翻译的文本</td></tr><tr><td align="left">1.0.2</td><td align="left">2016-02-04</td><td align="left">转换为Markdown格式, 发布更有好的在线阅读版本</td></tr><tr><td align="left">1.0.3</td><td align="left">2016-02-06</td><td align="left">补充中英文对照, 修正部分链接和格式</td></tr></tbody></table><h2 id="译者"><a href="#译者" class="headerlink" title="译者"></a>译者</h2><ul><li><a href="https://github.com/mcxiaoke" target="_blank" rel="noopener">GitHub</a></li><li><a href="http://blog.mcxiaoke.com/" target="_blank" rel="noopener">Blog</a></li><li>Email</li></ul><h2 id="第一章-概述-Introduction"><a href="#第一章-概述-Introduction" class="headerlink" title="第一章 概述 Introduction"></a>第一章 概述 Introduction</h2><h3 id="1-1-MQTT协议的组织结构-Organization-of-MQTT"><a href="#1-1-MQTT协议的组织结构-Organization-of-MQTT" class="headerlink" title="1.1 MQTT协议的组织结构 Organization of MQTT"></a>1.1 MQTT协议的组织结构 Organization of MQTT</h3><p>本规范分为七个章节：</p><ul><li><a href="https://www.zybuluo.com/khan-lau/note/1326839#第一章-概述-introduction" target="_blank" rel="noopener">第一章 – 介绍</a></li><li>第二章 – MQTT控制报文格式</li><li>第三章 – MQTT控制报文</li><li>第四章 – 操作行为</li><li>第五章 – 安全</li><li>第六章 – 使用WebSocket</li><li>第七章 – 一致性目标</li><li>附录B – 强制性规范声明</li></ul><h3 id="1-2-术语-Terminology"><a href="#1-2-术语-Terminology" class="headerlink" title="1.2 术语 Terminology"></a>1.2 术语 Terminology</h3><p>本规范中用到的关键字 <strong>必须</strong> MUST, <strong>不能</strong> MUST NOT, <strong>要求</strong> REQUIRED, <strong>将会</strong> SHALL, <strong>不会</strong> SHALL NOT, <strong>应该</strong> SHOULD, <strong>不应该</strong> SHOULD NOT, <strong>推荐</strong> RECOMMENDED, <strong>可以</strong> MAY, <strong>可选</strong> OPTIONAL 都是按照 IETF RFC 2119 <a href="https://www.zybuluo.com/khan-lau/note/1326839#anchor-RFC2119" target="_blank" rel="noopener">RFC2119</a> 中的描述解释.</p><p><strong>网络连接 Network Connection</strong></p><p>MQTT使用的底层传输协议基础设施.</p><ul><li>客户端使用它连接服务端.</li><li>它提供有序的、可靠的、双向字节流传输.</li></ul><p>例子见<a href="https://www.zybuluo.com/khan-lau/note/1326839#42-网络连接-network-connections" target="_blank" rel="noopener">4.2节</a>.</p><p><strong>应用消息 Application Message</strong><br>MQTT协议通过网络传输应用数据. 应用消息通过MQTT传输时, 它们有关联的服务质量(QoS)和主题(Topic).</p><p><strong>客户端 Client</strong><br>使用MQTT的程序或设备. 客户端总是通过网络连接到服务端. 它可以</p><ul><li>发布应用消息给其它相关的客户端.</li><li>订阅以请求接受相关的应用消息.</li><li>取消订阅以移除接受应用消息的请求.</li><li>从服务端断开连接.</li></ul><p><strong>服务端 Server</strong><br>一个程序或设备, 作为发送消息的客户端和请求订阅的客户端之间的中介. 服务端</p><ul><li>接受来自客户端的网络连接.</li><li>接受客户端发布的应用消息.</li><li>处理客户端的订阅和取消订阅请求.</li><li>转发应用消息给符合条件的已订阅客户端.</li></ul><p><strong>订阅 Subscription</strong><br>订阅包含一个<code>主题过滤器(Topic Filter)</code>和一个<code>最大的服务质量(QoS)等级</code>. 订阅与单个会话(Session)关联. 会话可以包含多于一个的订阅. 会话的每个订阅都有一个不同的主题过滤器.</p><p><strong>主题名 Topic Name</strong><br>附加在应用消息上的一个标签, 服务端已知且与订阅匹配. 服务端发送应用消息的一个副本给每一个匹配的客户端订阅.</p><p><strong>主题过滤器 Topic Filter</strong><br>订阅中包含的一个表达式, 用于表示相关的一个或多个主题. 主题过滤器可以使用通配符.</p><p><strong>会话 Session</strong><br>客户端和服务端之间的状态交互. 一些会话持续时长与网络连接一样, 另一些可以在客户端和服务端的多个连续网络连接间扩展.</p><p><strong>控制报文 MQTT Control Packet</strong><br>通过网络连接发送的信息数据包. MQTT规范定义了十四种不同类型的控制报文, 其中一个(PUBLISH报文)用于传输应用消息.</p><h3 id="1-3-规范引用-Normative-references"><a href="#1-3-规范引用-Normative-references" class="headerlink" title="1.3 规范引用 Normative references"></a>1.3 规范引用 Normative references</h3><p>[RFC2119]<br>Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997,<br><a href="http://www.rfc-editor.org/info/rfc2119" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc2119</a></p><p>[RFC3629]<br>Yergeau, F., “UTF-8, a transformation format of ISO 10646”, STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003,<br><a href="http://www.rfc-editor.org/info/rfc3629" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc3629</a></p><p>[RFC6455]<br>Fette, I. and A. Melnikov, “The WebSocket Protocol”, RFC 6455, DOI 10.17487/RFC6455, December 2011,<br><a href="http://www.rfc-editor.org/info/rfc6455" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6455</a></p><p>[Unicode]<br>The Unicode Consortium. The Unicode Standard,<br><a href="http://www.rfc-editor.org/info/rfc2119" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc2119</a></p><h3 id="1-4-非规范引用-Non-normative-references"><a href="#1-4-非规范引用-Non-normative-references" class="headerlink" title="1.4 非规范引用 Non-normative references"></a>1.4 非规范引用 Non-normative references</h3><p>[RFC0793]<br>Postel, J., “Transmission Control Protocol”, STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981,<br><a href="http://www.rfc-editor.org/info/rfc793" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc793</a></p><p>[RFC5246]<br>Dierks, T. and E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.2”, RFC 5246, DOI 10.17487/RFC5246, August 2008,<br><a href="http://www.rfc-editor.org/info/rfc2119" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc2119</a></p><p>[AES]<br>Advanced Encryption Standard (AES) (FIPS PUB 197).<br><a href="https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf" target="_blank" rel="noopener">https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf</a></p><p>[CHACHA20]<br>ChaCha20 and Poly1305 for IETF Protocols<br><a href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7539</a></p><p>[FIPS1402]<br>Security Requirements for Cryptographic Modules (FIPS PUB 140-2)<br><a href="https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf" target="_blank" rel="noopener">https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf</a></p><p>[IEEE 802.1AR]<br>IEEE Standard for Local and metropolitan area networks - Secure Device Identity<br><a href="http://standards.ieee.org/findstds/standard/802.1AR-2009.html" target="_blank" rel="noopener">http://standards.ieee.org/findstds/standard/802.1AR-2009.html</a></p><p>[ISO29192]<br>ISO/IEC 29192-1:2012 Information technology – Security techniques – Lightweight cryptography – Part 1: General<br><a href="https://www.iso.org/standard/56425.html" target="_blank" rel="noopener">https://www.iso.org/standard/56425.html</a></p><p>[MQTT NIST]<br>MQTT supplemental publication, MQTT and the NIST Framework for Improving Critical Infrastructure Cybersecurity<br><a href="http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html</a></p><p>[MQTTV311]<br>MQTT V3.1.1 Protocol Specification<br><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></p><p>[ISO20922]<br>MQTT V3.1.1 ISO Standard (ISO/IEC 20922:2016)<br><a href="https://www.iso.org/standard/69466.html" target="_blank" rel="noopener">https://www.iso.org/standard/69466.html</a></p><p>[NISTCSF]<br>Improving Critical Infrastructure Cybersecurity Executive Order 13636<br><a href="https://www.nist.gov/sites/default/files/documents/itl/preliminary-cybersecurity-framework.pdf" target="_blank" rel="noopener">https://www.nist.gov/sites/default/files/documents/itl/preliminary-cybersecurity-framework.pdf</a></p><p>[NIST7628]<br>NISTIR 7628 Guidelines for Smart Grid Cyber Security Catalogue<br><a href="https://www.nist.gov/sites/default/files/documents/smartgrid/nistir-7628_total.pdf" target="_blank" rel="noopener">https://www.nist.gov/sites/default/files/documents/smartgrid/nistir-7628_total.pdf</a></p><p>[NSAB]<br>NSA Suite B Cryptography<br><a href="http://www.nsa.gov/ia/programs/suiteb_cryptography/" target="_blank" rel="noopener">http://www.nsa.gov/ia/programs/suiteb_cryptography/</a></p><p>[PCIDSS]<br>PCI-DSS Payment Card Industry Data Security Standard<br><a href="https://www.pcisecuritystandards.org/pci_security/" target="_blank" rel="noopener">https://www.pcisecuritystandards.org/pci_security/</a></p><p>[RFC1928]<br>Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, “SOCKS Protocol Version 5”, RFC 1928, DOI 10.17487/RFC1928, March 1996,<br><a href="http://www.rfc-editor.org/info/rfc1928" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc1928</a></p><p>[RFC4511]<br>Sermersheim, J., Ed., “Lightweight Directory Access Protocol (LDAP): The Protocol”, RFC 4511, DOI 10.17487/RFC4511, June 2006,<br><a href="http://www.rfc-editor.org/info/rfc4511" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc4511</a></p><p>[RFC5280]<br>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, “Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile”, RFC 5280, DOI 10.17487/RFC5280, May 2008,<br><a href="http://www.rfc-editor.org/info/rfc5280" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc5280</a></p><p>[RFC6066]<br>Eastlake 3rd, D., “Transport Layer Security (TLS) Extensions: Extension Definitions”, RFC 6066, DOI 10.17487/RFC6066, January 2011,<br><a href="http://www.rfc-editor.org/info/rfc6066" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6066</a></p><p>[RFC6749]<br>Hardt, D., Ed., “The OAuth 2.0 Authorization Framework”, RFC 6749, DOI 10.17487/RFC6749, October 2012,<br><a href="http://www.rfc-editor.org/info/rfc6749" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6749</a></p><p>[RFC6960]<br>Santesson, S., Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, “X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP”, RFC 6960, DOI 10.17487/RFC6960, June 2013,<br><a href="http://www.rfc-editor.org/info/rfc6960" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6960</a></p><p>[SARBANES]<br>Sarbanes-Oxley Act of 2002.<br><a href="http://www.gpo.gov/fdsys/pkg/PLAW-107publ204/html/PLAW-107publ204.htm" target="_blank" rel="noopener">http://www.gpo.gov/fdsys/pkg/PLAW-107publ204/html/PLAW-107publ204.htm</a></p><p>[USEUPRIVSH]<br>U.S.-EU Privacy Shield Framework<br><a href="https://www.privacyshield.gov/" target="_blank" rel="noopener">https://www.privacyshield.gov</a></p><p>[RFC3986]<br>Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax”, STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005,<br><a href="http://www.rfc-editor.org/info/rfc3986" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc3986</a></p><p>[RFC1035]<br>Mockapetris, P., “Domain names - implementation and specification”, STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987,<br><a href="http://www.rfc-editor.org/info/rfc1035" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc1035</a></p><p>[RFC2782]<br>Gulbrandsen, A., Vixie, P., and L. Esibov, “A DNS RR for specifying the location of services (DNS SRV)”, RFC 2782, DOI 10.17487/RFC2782, February 2000,<br><a href="http://www.rfc-editor.org/info/rfc2782" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc2782</a></p><h3 id="1-5-数据表示-Data-representations"><a href="#1-5-数据表示-Data-representations" class="headerlink" title="1.5 数据表示 Data representations"></a>1.5 数据表示 Data representations</h3><h4 id="1-5-1-二进制位-Bits"><a href="#1-5-1-二进制位-Bits" class="headerlink" title="1.5.1 二进制位 Bits"></a>1.5.1 二进制位 Bits</h4><p>字节中的位从0到7. 第7位是最高有效位, 第0位是最低有效位.</p><h4 id="1-5-2-整数数值-Integer-data-values"><a href="#1-5-2-整数数值-Integer-data-values" class="headerlink" title="1.5.2 整数数值 Integer data values"></a>1.5.2 整数数值 Integer data values</h4><p>整数数值是16位, 使用大端序(big-endian, 高位字节在低位字节前面). 这意味着一个16位的字在网络上表示为最高有效字节(MSB), 后面跟着最低有效字节(LSB).</p><h4 id="1-5-3-UTF-8编码字符串-UTF-8-encoded-strings"><a href="#1-5-3-UTF-8编码字符串-UTF-8-encoded-strings" class="headerlink" title="1.5.3 UTF-8编码字符串 UTF-8 encoded strings"></a>1.5.3 UTF-8编码字符串 UTF-8 encoded strings</h4><p>后面会描述的控制报文中的文本字段编码为UTF-8格式的字符串. UTF-8 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC3629" target="_blank" rel="noopener">RFC3629</a> 是一个高效的Unicode字符编码格式, 为了支持基于文本的通信, 它对ASCII字符的编码做了优化.</p><p>每一个字符串都有一个两字节的长度字段作为前缀, 它给出这个字符串UTF-8编码的字节数, 它们在<a href="https://www.zybuluo.com/khan-lau/note/1326839#图例-11-utf-8编码字符串的结构-structure-of-utf-8-encoded-strings" target="_blank" rel="noopener">图例 1.1 UTF-8编码字符串的结构</a> 中描述. 因此可以传送的UTF-8编码的字符串大小有一个限制, 不能超过 65535字节.</p><p>除非另有说明, 所有的UTF-8编码字符串的长度都<strong>必须</strong>在0到65535字节这个范围内.</p><h5 id="图例-1-1-UTF-8编码字符串的结构-Structure-of-UTF-8-encoded-strings"><a href="#图例-1-1-UTF-8编码字符串的结构-Structure-of-UTF-8-encoded-strings" class="headerlink" title="图例 1.1 UTF-8编码字符串的结构 Structure of UTF-8 encoded strings"></a>图例 1.1 UTF-8编码字符串的结构 Structure of UTF-8 encoded strings</h5><table><thead><tr><th align="left"><strong>二进制位</strong></th><th align="left">7-0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">字符串长度的最高有效字节(MSB)</td></tr><tr><td align="left">byte 2</td><td align="left">字符串长度的最低有效字节(LSB)</td></tr><tr><td align="left">byte 3 ….</td><td align="left">如果长度大于0, 这里是UTF-8编码的字符数据.</td></tr></tbody></table><p>UTF-8编码字符串中的字符数据<strong>必须</strong>是按照Unicode规范 <a href="https://www.zybuluo.com/khan-lau/note/1326839#Unicode" target="_blank" rel="noopener">Unicode</a>] 定义的和在RFC3629 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC3629" target="_blank" rel="noopener">RFC3629</a>] 中重申的有效的UTF-8格式. 特别需要指出的是, 这些数据<strong>不能</strong>包含字符码在U+D800和U+DFFF之间的数据. 如果服务端或客户端收到了一个包含无效UTF-8字符的控制报文, 它<strong>必须</strong>关闭网络连接 [MQTT-1.5.3-1].</p><p>UTF-8编码的字符串<strong>不能</strong>包含空字符U+0000. 如果客户端或服务端收到了一个包含U+0000的控制报文, 它<strong>必须</strong>关闭网络连接 [MQTT-1.5.3-2].</p><p>数据中<strong>不应该</strong>包含下面这些Unicode代码点的编码. 如果一个接收者(服务端或客户端)收到了包含下列任意字符的控制报文, 它<strong>可以</strong>关闭网络连接：</p><ul><li>U+0001和U+001F之间的控制字符</li><li>U+007F和U+009F之间的控制字符</li><li>Unicode规范定义的非字符代码点(例如U+0FFFF)</li><li>Unicode规范定义的保留字符(例如U+0FFFF)</li></ul><p>UTF-8编码序列0XEF 0xBB 0xBF总是被解释为U+FEFF(零宽度非换行空白字符), 无论它出现在字符串的什么位置, 报文接收者都不能跳过或者剥离它 [MQTT-1.5.3-3].</p><h4 id="非规范示例-Non-normative-example"><a href="#非规范示例-Non-normative-example" class="headerlink" title="非规范示例 Non normative example"></a>非规范示例 Non normative example</h4><blockquote><p>例如, 字符串 A𪛔 是一个拉丁字母A后面跟着一个代码点U+2A6D4(它表示一个中日韩统一表意文字扩展B中的字符), 这个字符串编码如下：</p></blockquote><h5 id="图例-1-2-UTF-8编码字符串非规范示例-UTF-8-encoded-string-non-normative-example"><a href="#图例-1-2-UTF-8编码字符串非规范示例-UTF-8-encoded-string-non-normative-example" class="headerlink" title="图例 1.2 UTF-8编码字符串非规范示例 UTF-8 encoded string non normative example"></a>图例 1.2 UTF-8编码字符串非规范示例 UTF-8 encoded string non normative example</h5><table><thead><tr><th align="left"><strong>Bit</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">字符串长度 MSB (0x00)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">字符串长度 LSB (0x05)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left">‘A’ (0x41)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 4</td><td align="left">(0xF0)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 5</td><td align="left">(0xAA)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 6</td><td align="left">(0x9B)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 7</td><td align="left">(0x94)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h3 id="1-6-编辑约定-Editing-conventions"><a href="#1-6-编辑约定-Editing-conventions" class="headerlink" title="1.6 编辑约定 Editing conventions"></a>1.6 编辑约定 Editing conventions</h3><p>本规范用黄色高亮的文本标识一致性声明, 每个一致性声明都分配了一个这种格式的引用：[MQTT-x.x.x-y].</p><h2 id="第二章-MQTT控制报文格式-MQTT-Control-Packet-format"><a href="#第二章-MQTT控制报文格式-MQTT-Control-Packet-format" class="headerlink" title="第二章 MQTT控制报文格式 MQTT Control Packet format"></a>第二章 MQTT控制报文格式 MQTT Control Packet format</h2><h3 id="2-1-MQTT控制报文的结构-Structure-of-an-MQTT-Control-Packet"><a href="#2-1-MQTT控制报文的结构-Structure-of-an-MQTT-Control-Packet" class="headerlink" title="2.1 MQTT控制报文的结构 Structure of an MQTT Control Packet"></a>2.1 MQTT控制报文的结构 Structure of an MQTT Control Packet</h3><p>MQTT协议通过交换预定义的MQTT控制报文来通信. 这一节描述这些报文的格式.</p><p>MQTT控制报文由三部分组成, 按照 <a href="https://www.zybuluo.com/khan-lau/note/1326839#图例-21-mqtt控制报文的结构" target="_blank" rel="noopener">图例 2.1 –MQTT控制报文的结构</a> 描述的顺序：</p><h5 id="图例-2-1-–MQTT控制报文的结构"><a href="#图例-2-1-–MQTT控制报文的结构" class="headerlink" title="图例 2.1 –MQTT控制报文的结构"></a>图例 2.1 –MQTT控制报文的结构</h5><table><thead><tr><th align="left">Fixed header</th><th align="left">固定报头, 所有控制报文都包含</th></tr></thead><tbody><tr><td align="left">Variable header</td><td align="left">可变报头, 部分控制报文包含</td></tr><tr><td align="left">Payload</td><td align="left">有效载荷, 部分控制报文包含</td></tr></tbody></table><h3 id="2-2-固定报头-Fixed-header"><a href="#2-2-固定报头-Fixed-header" class="headerlink" title="2.2 固定报头 Fixed header"></a>2.2 固定报头 Fixed header</h3><p>每个MQTT控制报文都包含一个固定报头. <a href="https://www.zybuluo.com/khan-lau/note/1326839#图例-22--固定报头的格式" target="_blank" rel="noopener">图例 2.2 -固定报头的格式</a> 描述了固定报头的格式.</p><h5 id="图例-2-2-固定报头的格式"><a href="#图例-2-2-固定报头的格式" class="headerlink" title="图例 2.2 -固定报头的格式"></a>图例 2.2 -固定报头的格式</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文的类型</td><td>用于指定控制报文类型的标志位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2…</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="2-2-1-MQTT控制报文的类型-MQTT-Control-Packet-type"><a href="#2-2-1-MQTT控制报文的类型-MQTT-Control-Packet-type" class="headerlink" title="2.2.1 MQTT控制报文的类型 MQTT Control Packet type"></a>2.2.1 MQTT控制报文的类型 MQTT Control Packet type</h4><p><strong>位置：</strong>第1个字节, 二进制位7-4.</p><p>表示为4位无符号值, 这些值的定义见 <a href="https://www.zybuluo.com/khan-lau/note/1326839#表格-21--控制报文的类型" target="_blank" rel="noopener">表格 2.1 -控制报文的类型</a></p><h5 id="表格-2-1-控制报文的类型"><a href="#表格-2-1-控制报文的类型" class="headerlink" title="表格 2.1 -控制报文的类型"></a>表格 2.1 -控制报文的类型</h5><table><thead><tr><th align="left"><strong>名字</strong></th><th align="left"><strong>值</strong></th><th align="left"><strong>报文流动方向</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">Reserved</td><td align="left">0</td><td align="left">禁止</td><td align="left">保留</td></tr><tr><td align="left">CONNECT</td><td align="left">1</td><td align="left">客户端到服务端</td><td align="left">客户端请求连接服务端</td></tr><tr><td align="left">CONNACK</td><td align="left">2</td><td align="left">服务端到客户端</td><td align="left">连接报文确认</td></tr><tr><td align="left">PUBLISH</td><td align="left">3</td><td align="left">两个方向都允许</td><td align="left">发布消息</td></tr><tr><td align="left">PUBACK</td><td align="left">4</td><td align="left">两个方向都允许</td><td align="left">QoS 1消息发布收到确认</td></tr><tr><td align="left">PUBREC</td><td align="left">5</td><td align="left">两个方向都允许</td><td align="left">发布收到(保证交付第一步)</td></tr><tr><td align="left">PUBREL</td><td align="left">6</td><td align="left">两个方向都允许</td><td align="left">发布释放(保证交付第二步)</td></tr><tr><td align="left">PUBCOMP</td><td align="left">7</td><td align="left">两个方向都允许</td><td align="left">QoS 2消息发布完成(保证交互第三步)</td></tr><tr><td align="left">SUBSCRIBE</td><td align="left">8</td><td align="left">客户端到服务端</td><td align="left">客户端订阅请求</td></tr><tr><td align="left">SUBACK</td><td align="left">9</td><td align="left">服务端到客户端</td><td align="left">订阅请求报文确认</td></tr><tr><td align="left">UNSUBSCRIBE</td><td align="left">10</td><td align="left">客户端到服务端</td><td align="left">客户端取消订阅请求</td></tr><tr><td align="left">UNSUBACK</td><td align="left">11</td><td align="left">服务端到客户端</td><td align="left">取消订阅报文确认</td></tr><tr><td align="left">PINGREQ</td><td align="left">12</td><td align="left">客户端到服务端</td><td align="left">心跳请求</td></tr><tr><td align="left">PINGRESP</td><td align="left">13</td><td align="left">服务端到客户端</td><td align="left">心跳响应</td></tr><tr><td align="left">DISCONNECT</td><td align="left">14</td><td align="left">客户端到服务端</td><td align="left">客户端断开连接</td></tr><tr><td align="left">Reserved</td><td align="left">15</td><td align="left">禁止</td><td align="left">保留</td></tr></tbody></table><h4 id="2-2-2-标志-Flags"><a href="#2-2-2-标志-Flags" class="headerlink" title="2.2.2 标志 Flags"></a>2.2.2 标志 Flags</h4><p>固定报头第1个字节的剩余的4位 [3-0]包含每个MQTT控制报文类型特定的标志, 见 <a href="https://www.zybuluo.com/khan-lau/note/1326839#表格-22---标志位-flag-bits" target="_blank" rel="noopener">表格 2.2 -标志位</a>. 表格 2.2中任何标记为“保留”的标志位, 都是保留给以后使用的, <strong>必须</strong>设置为表格中列出的值 [MQTT-2.2.2-1]. 如果收到非法的标志, 接收者<strong>必须</strong>关闭网络连接. 有关错误处理的详细信息见 <a href="https://www.zybuluo.com/khan-lau/note/1326839#48-错误处理-handling-errors" target="_blank" rel="noopener">4.8节</a> [MQTT-2.2.2-2].</p><h5 id="表格-2-2-标志位-Flag-Bits"><a href="#表格-2-2-标志位-Flag-Bits" class="headerlink" title="表格 2.2 - 标志位 Flag Bits"></a>表格 2.2 - 标志位 Flag Bits</h5><table><thead><tr><th align="left"><strong>控制报文</strong></th><th align="left"><strong>固定报头标志</strong></th><th align="left"><strong>Bit 3</strong></th><th align="left"><strong>Bit 2</strong></th><th align="left"><strong>Bit 1</strong></th><th align="left"><strong>Bit 0</strong></th></tr></thead><tbody><tr><td align="left">CONNECT</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">CONNACK</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PUBLISH</td><td align="left">Used in MQTT 3.1.1</td><td align="left">DUP1</td><td align="left">QoS2</td><td align="left">QoS2</td><td align="left">RETAIN3</td></tr><tr><td align="left">PUBACK</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PUBREC</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PUBREL</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">PUBCOMP</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">SUBSCRIBE</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">SUBACK</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">UNSUBSCRIBE</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">UNSUBACK</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PINGREQ</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PINGRESP</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">DISCONNECT</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><p>- DUP1 =控制报文的重复分发标志<br>- QoS2 = PUBLISH报文的服务质量等级<br>- RETAIN3 = PUBLISH报文的保留标志</p><p>PUBLISH控制报文中的DUP, QoS和RETAIN标志的描述见 <a href="https://www.zybuluo.com/khan-lau/note/1326839#331-固定报头" target="_blank" rel="noopener">3.3.1节</a>.</p><h4 id="2-2-3-剩余长度-Remaining-Length"><a href="#2-2-3-剩余长度-Remaining-Length" class="headerlink" title="2.2.3 剩余长度 Remaining Length"></a>2.2.3 剩余长度 Remaining Length</h4><p><strong>位置：</strong>从第2个字节开始.</p><p>剩余长度(Remaining Length)表示当前报文剩余部分的字节数, 包括可变报头和负载的数据. 剩余长度不包括用于编码剩余长度字段本身的字节数.</p><p>剩余长度字段使用一个变长度编码方案, 对小于128的值它使用单字节编码. 更大的值按下面的方式处理. 低7位有效位用于编码数据, 最高有效位用于指示是否有更多的字节. 因此每个字节可以编码128个数值和一个<em>延续位(continuation bit)</em>. 剩余长度字段最大4个字节.</p><blockquote><p><strong>非规范评注</strong></p><p>例如, 十进制数64会被编码为一个字节, 数值是64, 十六进制表示为0x40,. 十进制数字321(=65+2*128)被编码为两个字节, 最低有效位在前. 第一个字节是 65+128=193. 注意最高位为1表示后面至少还有一个字节. 第二个字节是2.</p><p><strong>非规范评注</strong></p><p>这允许应用发送最大256MB(268,435,455)大小的控制报文. 这个数值在报文中的表示是：0xFF,0xFF,0xFF,0x7F.</p><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#表格-24剩余长度字段的大小-size-of-remaining-length-field" target="_blank" rel="noopener">表格 2.4剩余长度字段的大小</a>展示了<code>剩余长度</code>字段所表示的值随字节增长.</p></blockquote><h5 id="表格-2-4剩余长度字段的大小-Size-of-Remaining-Length-field"><a href="#表格-2-4剩余长度字段的大小-Size-of-Remaining-Length-field" class="headerlink" title="表格 2.4剩余长度字段的大小 Size of Remaining Length field"></a>表格 2.4剩余长度字段的大小 Size of Remaining Length field</h5><table><thead><tr><th align="left"><strong>字节数</strong></th><th align="left"><strong>最小值</strong></th><th align="left"><strong>最大值</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0 (0x00)</td><td align="left">127 (0x7F)</td></tr><tr><td align="left">2</td><td align="left">128 (0x80, 0x01)</td><td align="left">16 383 (0xFF, 0x7F)</td></tr><tr><td align="left">3</td><td align="left">16 384 (0x80, 0x80, 0x01)</td><td align="left">2 097 151 (0xFF, 0xFF, 0x7F)</td></tr><tr><td align="left">4</td><td align="left">2 097 152 (0x80, 0x80, 0x80, 0x01)</td><td align="left">268 435 455 (0xFF, 0xFF, 0xFF, 0x7F)</td></tr></tbody></table><p>分别表示(每个字节的低7位用于编码数据, 最高位是标志位)：</p><ul><li>1个字节时, 从0(0x00)到127(0x7f)</li><li>2个字节时, 从128(0x80,0x01)到16383(0Xff,0x7f)</li><li>3个字节时, 从16384(0x80,0x80,0x01)到2097151(0xFF,0xFF,0x7F)</li><li>4个字节时, 从2097152(0x80,0x80,0x80,0x01)到268435455(0xFF,0xFF,0xFF,0x7F)</li></ul><blockquote><p><strong>非规范评注</strong></p><p>非负整数X使用变长编码方案的算法如下：</p></blockquote><pre><code>   do  encodedByte = X MOD 128  X = X DIV 128 // if there are more data to encode, set the top bit of this byte if ( X &gt; 0 )     encodedByte = encodedByte OR 128 endif     &#39;output&#39; encodedBytewhile ( X &gt; 0 )</code></pre><blockquote><p>MOD是模运算, DIV是整数除法, OR是位操作或(C语言中分别是%, /, |)</p><p><strong>非规范评注</strong></p><p>剩余长度字段的解码算法如下：</p></blockquote><pre><code>multiplier = 1value = 0do    encodedByte = &#39;next byte from stream&#39;    value += (encodedByte AND 127) * multiplier    multiplier *= 128    if (multiplier &gt; 128*128*128)       throw Error(Malformed Remaining Length)while ((encodedByte AND 128) != 0)</code></pre><blockquote><p>AND是位操作与(C语言中的&amp;)</p><p>这个算法终止时, value包含的就是剩余长度的值.</p></blockquote><h3 id="2-3-可变报头-Variable-header"><a href="#2-3-可变报头-Variable-header" class="headerlink" title="2.3 可变报头 Variable header"></a>2.3 可变报头 Variable header</h3><p>某些MQTT控制报文包含一个可变报头部分. 它在固定报头和负载之间. 可变报头的内容根据报文类型的不同而不同. 可变报头的报文标识符(Packet Identifier)字段存在于在多个类型的报文里.</p><h4 id="2-3-1-报文标识符-Packet-Identifier"><a href="#2-3-1-报文标识符-Packet-Identifier" class="headerlink" title="2.3.1 报文标识符 Packet Identifier"></a>2.3.1 报文标识符 Packet Identifier</h4><h5 id="图例-2-3-报文标识符字节-Packet-Identifier-bytes"><a href="#图例-2-3-报文标识符字节-Packet-Identifier-bytes" class="headerlink" title="图例 2.3 -报文标识符字节 Packet Identifier bytes"></a>图例 2.3 -报文标识符字节 Packet Identifier bytes</h5><table><thead><tr><th align="left"><strong>Bit</strong></th><th align="left"><strong>7</strong> - <strong>0</strong></th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">报文标识符 MSB</td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符 LSB</td></tr></tbody></table><p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段. 这些报文是<code>PUBLISH</code>(QoS &gt; 0时), <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBSCRIBE</code>, <code>SUBACK</code>, <code>UNSUBSCIBE</code>, <code>UNSUBACK</code>.</p><p>SUBSCRIBE, UNSUBSCRIBE和PUBLISH(QoS大于0)控制报文<strong>必须</strong>包含一个非零的16位报文标识符(Packet Identifier)[MQTT-2.3.1-1]. 客户端每次发送一个新的这些类型的报文时都<strong>必须</strong>分配一个当前未使用的报文标识符 [MQTT-2.3.1-2]. 如果一个客户端要重发这个特殊的控制报文, 在随后重发那个报文时, 它<strong>必须</strong>使用相同的标识符. 当客户端处理完这个报文对应的确认后, 这个报文标识符就释放可重用. QoS 1的PUBLISH对应的是PUBACK, QoS 2的PUBLISH对应的是PUBCOMP, 与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK [MQTT-2.3.1-3]. 发送一个QoS 0的PUBLISH报文时, 相同的条件也适用于服务端 [MQTT-2.3.1-4].</p><p>QoS等于0的PUBLISH报文<strong>不能</strong>包含报文标识符 [MQTT-2.3.1-5].</p><p>PUBACK, PUBREC, PUBREL报文<strong>必须</strong>包含与最初发送的PUBLISH报文相同的报文标识符 [MQTT-2.3.1-6]. 类似地, SUBACK和UNSUBACK<strong>必须</strong>包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符 [MQTT-2.3.1-7].</p><p>需要报文标识符的控制报文在 <a href="https://www.zybuluo.com/khan-lau/note/1326839#_Table_2.5_-" target="_blank" rel="noopener">表格 2.5 -包含报文标识符的控制报文</a> 中列出.</p><h5 id="表格-2-5-包含报文标识符的控制报文-Control-Packets-that-contain-a-Packet-Identifier"><a href="#表格-2-5-包含报文标识符的控制报文-Control-Packets-that-contain-a-Packet-Identifier" class="headerlink" title="表格 2.5 -包含报文标识符的控制报文 Control Packets that contain a Packet Identifier"></a>表格 2.5 -包含报文标识符的控制报文 Control Packets that contain a Packet Identifier</h5><table><thead><tr><th align="left"><strong>控制报文</strong></th><th align="left"><strong>报文标识符字段</strong></th></tr></thead><tbody><tr><td align="left">CONNECT</td><td align="left">不需要</td></tr><tr><td align="left">CONNACK</td><td align="left">不需要</td></tr><tr><td align="left">PUBLISH</td><td align="left">需要(如果QoS &gt; 0)</td></tr><tr><td align="left">PUBACK</td><td align="left">需要</td></tr><tr><td align="left">PUBREC</td><td align="left">需要</td></tr><tr><td align="left">PUBREL</td><td align="left">需要</td></tr><tr><td align="left">PUBCOMP</td><td align="left">需要</td></tr><tr><td align="left">SUBSCRIBE</td><td align="left">需要</td></tr><tr><td align="left">SUBACK</td><td align="left">需要</td></tr><tr><td align="left">UNSUBSCRIBE</td><td align="left">需要</td></tr><tr><td align="left">UNSUBACK</td><td align="left">需要</td></tr><tr><td align="left">PINGREQ</td><td align="left">不需要</td></tr><tr><td align="left">PINGRESP</td><td align="left">不需要</td></tr><tr><td align="left">DISCONNECT</td><td align="left">不需要</td></tr></tbody></table><p>客户端和服务端彼此独立地分配报文标识符. 因此, 客户端服务端组合使用相同的报文标识符可以实现并发的消息交换.</p><p><strong>非规范评注</strong></p><p>客户端发送标识符为0x1234的PUBLISH报文, 它有可能会在收到那个报文的PUBACK之前, 先收到服务端发送的另一个不同的但是报文标识符也为0x1234的PUBLISH报文.</p><table><thead><tr><th align="left">Client</th><th align="left">Server</th></tr></thead><tbody><tr><td align="left">PUBLISH</td><td align="left">Packet Identifier=0x1234—</td></tr><tr><td align="left">–PUBLISH</td><td align="left">Packet Identifier=0x1234</td></tr><tr><td align="left">PUBACK</td><td align="left">Packet Identifier=0x1234—</td></tr><tr><td align="left">–PUBACK</td><td align="left">Packet Identifier=0x1234</td></tr></tbody></table><h3 id="2-4-有效载荷-Payload"><a href="#2-4-有效载荷-Payload" class="headerlink" title="2.4 有效载荷 Payload"></a>2.4 有效载荷 Payload</h3><p>某些MQTT控制报文在报文的最后部分包含一个有效载荷, 这将在第三章论述. 对于PUBLISH来说有效载荷就是应用消息. <a href="https://www.zybuluo.com/khan-lau/note/1326839#_Table_2.6_-" target="_blank" rel="noopener">表格 2.6 – 包含有效载荷的控制报文</a> 列出了需要有效载荷的控制报文.</p><h5 id="表格-2-6-–-包含有效载荷的控制报文-Control-Packets-that-contain-a-Payload"><a href="#表格-2-6-–-包含有效载荷的控制报文-Control-Packets-that-contain-a-Payload" class="headerlink" title="表格 2.6 – 包含有效载荷的控制报文 Control Packets that contain a Payload"></a>表格 2.6 – 包含有效载荷的控制报文 Control Packets that contain a Payload</h5><table><thead><tr><th align="left"><strong>控制报文</strong></th><th align="left"><strong>有效载荷</strong></th></tr></thead><tbody><tr><td align="left">CONNECT</td><td align="left">需要</td></tr><tr><td align="left">CONNACK</td><td align="left">不需要</td></tr><tr><td align="left">PUBLISH</td><td align="left">可选</td></tr><tr><td align="left">PUBACK</td><td align="left">不需要</td></tr><tr><td align="left">PUBREC</td><td align="left">不需要</td></tr><tr><td align="left">PUBREL</td><td align="left">不需要</td></tr><tr><td align="left">PUBCOMP</td><td align="left">不需要</td></tr><tr><td align="left">SUBSCRIBE</td><td align="left">需要</td></tr><tr><td align="left">SUBACK</td><td align="left">需要</td></tr><tr><td align="left">UNSUBSCRIBE</td><td align="left">需要</td></tr><tr><td align="left">UNSUBACK</td><td align="left">不需要</td></tr><tr><td align="left">PINGREQ</td><td align="left">不需要</td></tr><tr><td align="left">PINGRESP</td><td align="left">不需要</td></tr><tr><td align="left">DISCONNECT</td><td align="left">不需要</td></tr></tbody></table><h2 id="第三章-MQTT控制报文-MQTT-Control-Packets"><a href="#第三章-MQTT控制报文-MQTT-Control-Packets" class="headerlink" title="第三章 MQTT控制报文 MQTT Control Packets"></a>第三章 MQTT控制报文 MQTT Control Packets</h2><h3 id="3-1-CONNECT-–-连接服务端"><a href="#3-1-CONNECT-–-连接服务端" class="headerlink" title="3.1 CONNECT – 连接服务端"></a>3.1 CONNECT – 连接服务端</h3><p>客户端到服务端的网络连接建立后, 客户端发送给服务端的第一个报文<strong>必须</strong>是CONNECT报文 [MQTT-3.1.0-1].</p><p>在一个网络连接上, 客户端只能发送一次CONNECT报文. 服务端<strong>必须</strong>将客户端发送的第二个CONNECT报文当作协议违规处理并断开客户端的连接 [MQTT-3.1.0-2]. 有关错误处理的信息请查看<a href="https://www.zybuluo.com/khan-lau/note/1326839#48-错误处理-handling-errors" target="_blank" rel="noopener">4.8节</a>.</p><p>有效载荷包含一个或多个编码的字段. 包括客户端的唯一标识符, Will主题, Will消息, 用户名和密码. 除了客户端标识之外, 其它的字段都是可选的, 基于标志位来决定可变报头中是否需要包含这些字段.</p><h4 id="3-1-1-固定报头-Fixed-header"><a href="#3-1-1-固定报头-Fixed-header" class="headerlink" title="3.1.1 固定报头 Fixed header"></a>3.1.1 固定报头 Fixed header</h4><h5 id="图例-3-1-–CONNECT报文的固定报头"><a href="#图例-3-1-–CONNECT报文的固定报头" class="headerlink" title="图例 3.1 –CONNECT报文的固定报头"></a>图例 3.1 –CONNECT报文的固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT报文类型 (1)</td><td>Reserved 保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2…</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>剩余长度等于可变报头的长度(10字节)加上有效载荷的长度. 编码方式见 <a href="https://www.zybuluo.com/khan-lau/note/1326839#223-剩余长度-remaining-length" target="_blank" rel="noopener">2.2.3节</a>的说明.</p><h4 id="3-1-2-可变报头-Variable-header"><a href="#3-1-2-可变报头-Variable-header" class="headerlink" title="3.1.2 可变报头 Variable header"></a>3.1.2 可变报头 Variable header</h4><p>CONNECT报文的可变报头按下列次序包含四个字段：协议名(Protocol Name), 协议级别(Protocol Level), 连接标志(Connect Flags)和保持连接(Keep Alive).</p><h5 id="协议名-Protocol-Name"><a href="#协议名-Protocol-Name" class="headerlink" title="协议名 Protocol Name"></a>协议名 Protocol Name</h5><h6 id="图例-3-2-协议名字节构成"><a href="#图例-3-2-协议名字节构成" class="headerlink" title="图例 3.2 -协议名字节构成"></a>图例 3.2 -协议名字节构成</h6><table><thead><tr><th align="left"><strong>说明</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">协议名</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">长度 MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">长度 LSB (4)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 3</td><td align="left">‘M’</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 4</td><td align="left">‘Q’</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 5</td><td align="left">‘T’</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 6</td><td align="left">‘T’</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr></tbody></table><p>协议名是表示协议名 <em>MQTT</em> 的UTF-8编码的字符串. MQTT规范的后续版本不会改变这个字符串的偏移和长度.</p><p>如果协议名不正确服务端<strong>可以</strong>断开客户端的连接, 也<strong>可以</strong>按照某些其它规范继续处理CONNECT报文. 对于后一种情况, 按照本规范, 服务端<strong>不能</strong>继续处理CONNECT报文 [MQTT-3.1.2-1].</p><blockquote><p><strong>非规范评注</strong></p><p>数据包检测工具, 例如防火墙, 可以使用协议名来识别MQTT流量.</p></blockquote><h5 id="协议级别-Protocol-Level"><a href="#协议级别-Protocol-Level" class="headerlink" title="协议级别 Protocol Level"></a>协议级别 Protocol Level</h5><h6 id="图例-3-3-Protocol-Level-byte协议级别字节构成"><a href="#图例-3-3-Protocol-Level-byte协议级别字节构成" class="headerlink" title="图例 3.3 - Protocol Level byte协议级别字节构成"></a>图例 3.3 - Protocol Level byte协议级别字节构成</h6><table><thead><tr><th align="left"><strong>说明</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">协议级别</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 7</td><td align="left">Level(4)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr></tbody></table><p>客户端用8位的无符号值表示协议的修订版本. 对于3.1.1版协议, 协议级别字段的值是4(0x04). 如果发现不支持的协议级别, 服务端<strong>必须</strong>给发送一个返回码为0x01(不支持的协议级别)的CONNACK报文响应CONNECT报文, 然后断开客户端的连接 [MQTT-3.1.2-2].</p><h5 id="连接标志-Connect-Flags"><a href="#连接标志-Connect-Flags" class="headerlink" title="连接标志 Connect Flags"></a>连接标志 Connect Flags</h5><p>连接标志字节包含一些用于指定MQTT连接行为的参数. 它还指出有效载荷中的字段是否存在.</p><h6 id="图例-3-4-连接标志位"><a href="#图例-3-4-连接标志位" class="headerlink" title="图例 3.4 -连接标志位"></a>图例 3.4 -连接标志位</h6><p>服务端<strong>必须</strong>验证CONNECT控制报文的保留标志位(第0位)是否为0, 如果不为0必须断开客户端连接 [MQTT-3.1.2-3].</p><h5 id="清理会话-Clean-Session"><a href="#清理会话-Clean-Session" class="headerlink" title="清理会话 Clean Session"></a>清理会话 Clean Session</h5><p><strong>位置：</strong>连接标志字节的第1位</p><p>这个二进制位指定了会话状态的处理方式.</p><p>客户端和服务端可以保存会话状态, 以支持跨网络连接的可靠消息传输. 这个标志位用于控制会话状态的生存时间.</p><p>如果清理会话(CleanSession)标志被设置为0, 服务端<strong>必须</strong>基于当前会话(使用客户端标识符识别)的状态恢复与客户端的通信. 如果没有与这个客户端标识符关联的会话, 服务端<strong>必须</strong>创建一个新的会话. 在连接断开之后, 当连接断开后, 客户端和服务端<strong>必须</strong>保存会话信息 [MQTT-3.1.2-4]. 当清理会话标志为0的会话连接断开之后, 服务端<strong>必须</strong>将之后的QoS 1和QoS 2级别的消息保存为会话状态的一部分, 如果这些消息匹配断开连接时客户端的任何订阅 <a href="https://tools.oasis-open.org/issues/browse/MQTT-3" target="_blank" rel="noopener">MQTT-3</a>.1.2-5]. 服务端也<strong>可以</strong>保存满足相同条件的QoS 0级别的消息.</p><p>如果清理会话(CleanSession)标志被设置为1, 客户端和服务端<strong>必须</strong>丢弃之前的任何会话并开始一个新的会话. 会话仅持续和网络连接同样长的时间. 与这个会话关联的状态数据<strong>不能</strong>被任何之后的会话重用 [MQTT-3.1.2-6].</p><p>客户端的会话状态包括：</p><ul><li>已经发送给服务端, 但是还没有完成确认的QoS 1和QoS 2级别的消息</li><li>已从服务端接收, 但是还没有完成确认的QoS 2级别的消息.</li></ul><p>服务端的会话状态包括：</p><ul><li>会话是否存在, 即使会话状态的其它部分都是空.</li><li>客户端的订阅信息.</li><li>已经发送给客户端, 但是还没有完成确认的QoS 1和QoS 2级别的消息.</li><li>即将传输给客户端的QoS 1和QoS 2级别的消息.</li><li>已从客户端接收, 但是还没有完成确认的QoS 2级别的消息.</li><li>可选, 准备发送给客户端的QoS 0级别的消息.</li></ul><p>保留消息不是服务端会话状态的一部分, 会话终止时<strong>不能</strong>删除保留消息 [MQTT-3.1.2.7].</p><p>有关状态存储的限制和细节见第 <a href="https://www.zybuluo.com/khan-lau/note/1326839#41-状态存储-storing-state" target="_blank" rel="noopener">4.1节</a>.</p><p>当清理会话标志被设置为1时, 客户端和服务端的状态删除不需要是原子操作.</p><blockquote><p><strong>非规范评注</strong></p><p>为了确保在发生故障时状态的一致性, 客户端应该使用会话状态标志1重复请求连接, 直到连接成功.</p><p><strong>非规范评注</strong></p><p>一般来说, 客户端连接时总是将清理会话标志设置为0或1, 并且不交替使用两种值. 这个选择取决于具体的应用. 清理会话标志设置为1的客户端不会收到旧的应用消息, 而且在每次连接成功后都需要重新订阅任何相关的主题. 清理会话标志设置为0的客户端会收到所有在它连接断开期间发布的QoS 1和QoS 2级别的消息. 因此, 要确保不丢失连接断开期间的消息, 需要使用QoS 1或 QoS 2级别, 同时将清理会话标志设置为0.</p><p><strong>非规范评注</strong></p><p>清理会话标志0的客户端连接时, 它请求服务端在连接断开后保留它的MQTT会话状态. 如果打算在之后的某个时间点重连到这个服务端, 客户端连接应该只使用清理会话标志0. 当客户端决定之后不再使用这个会话时, 应该将清理会话标志设置为1最后再连接一次, 然后断开连接.</p></blockquote><h5 id="遗嘱标志-Will-Flag"><a href="#遗嘱标志-Will-Flag" class="headerlink" title="遗嘱标志 Will Flag"></a>遗嘱标志 Will Flag</h5><p><strong>位置：</strong>连接标志的第2位.</p><p>遗嘱标志(Will Flag)被设置为1, 表示如果连接请求被接受了, 遗嘱(Will Message)消息<strong>必须</strong>被存储在服务端并且与这个网络连接关联. 之后网络连接关闭时, 服务端<strong>必须</strong>发布这个遗嘱消息, 除非服务端收到DISCONNECT报文时删除了这个遗嘱消息 [MQTT-3.1.2-8] .</p><p>遗嘱消息发布的条件, 包括但不限于：</p><ul><li>服务端检测到了一个I/O错误或者网络故障.</li><li>客户端在保持连接(Keep Alive)的时间内未能通讯.</li><li>客户端没有先发送DISCONNECT报文直接关闭了网络连接.</li><li>由于协议错误服务端关闭了网络连接.</li></ul><p>如果遗嘱标志被设置为1, 连接标志中的Will QoS和Will Retain字段会被服务端用到, 同时有效载荷中<strong>必须</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-9].</p><p>一旦被发布或者服务端收到了客户端发送的DISCONNECT报文, 遗嘱消息就<strong>必须</strong>从存储的会话状态中移除 [MQTT-3.1.2-10].</p><p>如果遗嘱标志被设置为0, 连接标志中的Will QoS和Will Retain字段<strong>必须</strong>设置为0, 并且有效载荷中<strong>不能</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-11].</p><p>如果遗嘱标志被设置为0, 网络连接断开时, <strong>不能</strong>发送遗嘱消息 [MQTT-3.1.2-12].</p><p>服务端应该迅速发布遗嘱消息. 在关机或故障的情况下, 服务端可以推迟遗嘱消息的发布直到之后的重启. 如果发生了这种情况, 在服务器故障和遗嘱消息被发布之间可能会有一个延迟.</p><h5 id="遗嘱QoS-Will-QoS"><a href="#遗嘱QoS-Will-QoS" class="headerlink" title="遗嘱QoS Will QoS"></a>遗嘱QoS Will QoS</h5><p><strong>位置：</strong>连接标志的第4和第3位.</p><p>这两位用于指定发布遗嘱消息时使用的服务质量等级.</p><p>如果遗嘱标志被设置为0, 遗嘱QoS也<strong>必须</strong>设置为0(0x00) [MQTT-3.1.2-13].</p><p>如果遗嘱标志被设置为1, 遗嘱QoS的值可以等于0(0x00), 1(0x01), 2(0x02). 它的值<strong>不能</strong>等于3 [MQTT-3.1.2-14].</p><h5 id="遗嘱保留-Will-Retain"><a href="#遗嘱保留-Will-Retain" class="headerlink" title="遗嘱保留 Will Retain"></a>遗嘱保留 Will Retain</h5><p><strong>位置：</strong>连接标志的第5位.</p><p>如果遗嘱消息被发布时需要保留, 需要指定这一位的值.</p><p>如果遗嘱标志被设置为0, 遗嘱保留(Will Retain)标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-15].</p><p>如果遗嘱标志被设置为1：</p><ul><li>如果遗嘱保留被设置为0, 服务端<strong>必须</strong>将遗嘱消息当作非保留消息发布 [MQTT-3.1.2-16].</li><li>如果遗嘱保留被设置为1, 服务端<strong>必须</strong>将遗嘱消息当作保留消息发布 [MQTT-3.1.2-17].</li></ul><h5 id="用户名标志-User-Name-Flag"><a href="#用户名标志-User-Name-Flag" class="headerlink" title="用户名标志 User Name Flag"></a>用户名标志 User Name Flag</h5><p><strong>位置：</strong>连接标志的第7位.</p><p>如果用户名(User Name)标志被设置为0, 有效载荷中<strong>不能</strong>包含用户名字段 [MQTT-3.1.2-18].</p><p>如果用户名(User Name)标志被设置为1, 有效载荷中<strong>必须</strong>包含用户名字段 [MQTT-3.1.2-19].</p><h5 id="密码标志-Password-Flag"><a href="#密码标志-Password-Flag" class="headerlink" title="密码标志 Password Flag"></a>密码标志 Password Flag</h5><p><strong>位置：</strong>连接标志的第6位.</p><p>如果密码(Password)标志被设置为0, 有效载荷中<strong>不能</strong>包含密码字段 [MQTT-3.1.2-20].</p><p>如果密码(Password)标志被设置为1, 有效载荷中<strong>必须</strong>包含密码字段 [MQTT-3.1.2-21].</p><p>如果用户名标志被设置为0, 密码标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-22].</p><h5 id="保持连接-Keep-Alive"><a href="#保持连接-Keep-Alive" class="headerlink" title="保持连接 Keep Alive"></a>保持连接 Keep Alive</h5><h5 id="图例-3-5保持连接字节"><a href="#图例-3-5保持连接字节" class="headerlink" title="图例 3.5保持连接字节"></a>图例 3.5保持连接字节</h5><table><thead><tr><th align="left"><strong>Bit</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">byte 9</td><td align="left">保持连接 Keep Alive MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 10</td><td align="left">保持连接 Keep Alive LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>保持连接(Keep Alive)是一个以秒为单位的时间间隔, 表示为一个16位的字, 它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻, 两者之间允许空闲的最大时间间隔. 客户端负责保证控制报文发送的时间间隔不超过保持连接的值. 如果没有任何其它的控制报文可以发送, 客户端<strong>必须</strong>发送一个PINGREQ报文 [MQTT-3.1.2-23].</p><p>不管保持连接的值是多少, 客户端任何时候都可以发送PINGREQ报文, 并且使用PINGRESP报文判断网络和服务端的活动状态.</p><p>如果保持连接的值非零, 并且服务端在一点五倍的保持连接时间内没有收到客户端的控制报文, 它<strong>必须</strong>断开客户端的网络连接, 认为网络连接已断开 [MQTT-3.1.2-24].</p><p>客户端发送了PINGREQ报文之后, 如果在合理的时间内仍没有收到PINGRESP报文, 它<strong>应该</strong>关闭到服务端的网络连接.</p><p>保持连接的值为零表示关闭保持连接功能. 这意味着, 服务端不需要因为客户端不活跃而断开连接. 注意：不管保持连接的值是多少, 任何时候, 只要服务端认为客户端是不活跃或无响应的, 可以断开客户端的连接.</p><blockquote><p><strong>非规范评注</strong></p><p>保持连接的实际值是由应用指定的, 一般是几分钟. 允许的最大值是18小时12分15秒.</p></blockquote><h5 id="可变报头非规范示例"><a href="#可变报头非规范示例" class="headerlink" title="可变报头非规范示例"></a>可变报头非规范示例</h5><h6 id="图例-3-6-可变报头非规范示例"><a href="#图例-3-6-可变报头非规范示例" class="headerlink" title="图例 3.6 -可变报头非规范示例"></a>图例 3.6 -可变报头非规范示例</h6><h4 id="3-1-3-有效载荷-Payload"><a href="#3-1-3-有效载荷-Payload" class="headerlink" title="3.1.3 有效载荷 Payload"></a>3.1.3 有效载荷 Payload</h4><p>CONNECT报文的有效载荷(payload)包含一个或多个以长度为前缀的字段, 可变报头中的标志决定是否包含这些字段. 如果包含的话, <strong>必须</strong>按这个顺序出现：客户端标识符, 遗嘱主题, 遗嘱消息, 用户名, 密码 [MQTT-3.1.3-1].</p><h5 id="客户端标识符-Client-Identifier"><a href="#客户端标识符-Client-Identifier" class="headerlink" title="客户端标识符 Client Identifier"></a>客户端标识符 Client Identifier</h5><p>服务端使用客户端标识符 (ClientId) 识别客户端. 连接服务端的每个客户端都有唯一的客户端标识符(ClientId). 客户端和服务端都必须使用ClientId识别两者之间的MQTT会话相关的状态 [MQTT-3.1.3-2].</p><p>客户端标识符 (ClientId) <strong>必须</strong>存在而且<strong>必须</strong>是CONNECT报文有效载荷的第一个字段 [MQTT-3.1.3-3].</p><p>客户端标识符<strong>必须</strong>是<a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码字符串 [MQTT-3.1.3-4].</p><p>服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的客户端标识符, 客户端标识符只能包含这些字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”(大写字母, 小写字母和数字)[MQTT-3.1.3-5].</p><p>服务端<strong>可以</strong>允许编码后超过23个字节的客户端标识符 (ClientId). 服务端<strong>可以</strong>允许包含不是上面列表字符的客户端标识符 (ClientId).</p><p>服务端<strong>可以</strong>允许客户端提供一个零字节的客户端标识符 (ClientId) , 如果这样做了, 服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户端标识符给那个客户端. 然后它<strong>必须</strong>假设客户端提供了那个唯一的客户端标识符, 正常处理这个CONNECT报文 [MQTT-3.1.3-6].</p><p>如果客户端提供了一个零字节的客户端标识符, 它<strong>必须</strong>同时将清理会话标志设置为1 [MQTT-3.1.3-7].</p><p>如果客户端提供的ClientId为零字节且清理会话标志为0, 服务端<strong>必须</strong>发送返回码为0x02(表示标识符不合格)的CONNACK报文响应客户端的CONNECT报文, 然后关闭网络连接 [MQTT-3.1.3-8].</p><p>如果服务端拒绝了这个ClientId, 它<strong>必须</strong>发送返回码为0x02(表示标识符不合格)的CONNACK报文响应客户端的CONNECT报文, 然后关闭网络连接 [MQTT-3.1.3-9].</p><blockquote><p><strong>非规范评注</strong></p><p>客户端实现可以提供一个方便的方法用于生成随机的ClientId. 当清理会话标志被设置为0时应该主动放弃使用这种方法.</p></blockquote><h5 id="遗嘱主题-Will-Topic"><a href="#遗嘱主题-Will-Topic" class="headerlink" title="遗嘱主题 Will Topic"></a>遗嘱主题 Will Topic</h5><p>如果遗嘱标志被设置为1, 有效载荷的下一个字段是遗嘱主题(Will Topic). 遗嘱主题<strong>必须</strong>是 <a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码字符串 [MQTT-3.1.3-10].</p><h5 id="遗嘱消息-Will-Message"><a href="#遗嘱消息-Will-Message" class="headerlink" title="遗嘱消息 Will Message"></a>遗嘱消息 Will Message</h5><p>如果遗嘱标志被设置为1, 有效载荷的下一个字段是遗嘱消息. 遗嘱消息定义了将被发布到遗嘱主题的应用消息, 见3.1.2.5节的描述. 这个字段由一个两字节的长度和遗嘱消息的有效载荷组成, 表示为零字节或多个字节序列. 长度给出了跟在后面的数据的字节数, 不包含长度字段本身占用的两个字节.</p><p>遗嘱消息被发布到遗嘱主题时, 它的有效载荷只包含这个字段的数据部分, 不包含开头的两个长度字节.</p><h5 id="用户名-User-Name"><a href="#用户名-User-Name" class="headerlink" title="用户名 User Name"></a>用户名 User Name</h5><p>如果用户名(User Name)标志被设置为1, 有效载荷的下一个字段就是它. 用户名<strong>必须</strong>是 <a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码字符串 [MQTT-3.1.3-11]. 服务端可以将它用于身份验证和授权.</p><h5 id="密码-Password"><a href="#密码-Password" class="headerlink" title="密码 Password"></a>密码 Password</h5><p>如果密码(Password)标志被设置为1, 有效载荷的下一个字段就是它. 密码字段包含一个两字节的长度字段, 长度表示二进制数据的字节数(不包含长度字段本身占用的两个字节), 后面跟着0到65535字节的二进制数据.</p><h5 id="图例-3-7-密码字节"><a href="#图例-3-7-密码字节" class="headerlink" title="图例 3.7 - 密码字节"></a>图例 3.7 - 密码字节</h5><table><thead><tr><th align="left"><strong>Bit</strong></th><th align="left"><strong>7</strong> - <strong>0</strong></th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">数据长度 MSB</td></tr><tr><td align="left">byte 2</td><td align="left">数据长度 LSB</td></tr><tr><td align="left">byte 3 ….</td><td align="left">如果长度大于0, 这里就是数据部分</td></tr></tbody></table><h4 id="3-1-4-响应-Response"><a href="#3-1-4-响应-Response" class="headerlink" title="3.1.4 响应 Response"></a>3.1.4 响应 Response</h4><p>注意：服务器可以在同一个TCP端口或其他网络端点上支持多种协议(包括本协议的早期版本). 如果服务器确定协议是MQTT 3.1.1, 那么它按照下面的方法验证连接请求.</p><ol><li>网络连接建立后, 如果服务端在合理的时间内没有收到CONNECT报文, 服务端<strong>应该</strong>关闭这个连接.</li><li>服务端<strong>必须</strong>按照3.1节的要求验证CONNECT报文, 如果报文不符合规范, 服务端不发送CONNACK报文直接关闭网络连接 [MQTT-3.1.4-1].</li><li>服务端<strong>可以</strong>检查CONNECT报文的内容是不是满足任何进一步的限制, <strong>可以</strong>执行身份验证和授权检查. 如果任何一项检查没通过, 按照3.2节的描述, 它<strong>应该</strong>发送一个适当的、返回码非零的CONNACK响应, 并且<strong>必须</strong>关闭这个网络连接.</li></ol><p>如果验证成功, 服务端会执行下列步骤.</p><ol><li>如果ClientId表明客户端已经连接到这个服务端, 那么服务端<strong>必须</strong>断开原有的客户端连接 [MQTT-3.1.4-2].</li><li>服务端<strong>必须</strong>按照 3.1.2.4节的描述执行清理会话的过程 [MQTT-3.1.4-3].</li><li>服务端<strong>必须</strong>发送返回码为零的CONNACK报文作为CONNECT报文的确认响应 [MQTT-3.1.4-4].</li><li>开始消息分发和保持连接状态监视.</li></ol><p>允许客户端在发送CONNECT报文之后立即发送其它的控制报文；客户端不需要等待服务端的CONNACK报文. 如果服务端拒绝了CONNECT, 它<strong>不能</strong>处理客户端在CONNECT报文之后发送的任何数据 [MQTT-3.1.4-5].</p><blockquote><p><strong>非规范评注</strong></p><p>客户端通常会等待一个CONNACK报文. 然而客户端有权在收到CONNACK之前发送控制报文, 由于不需要维持连接状态, 这可以简化客户端的实现.</p></blockquote><h3 id="3-2-CONNACK-–-确认连接请求"><a href="#3-2-CONNACK-–-确认连接请求" class="headerlink" title="3.2 CONNACK – 确认连接请求"></a>3.2 CONNACK – 确认连接请求</h3><p>服务端发送CONNACK报文响应从客户端收到的CONNECT报文. 服务端发送给客户端的第一个报文<strong>必须</strong>是CONNACK [MQTT-3.2.0-1].</p><p>如果客户端在合理的时间内没有收到服务端的CONNACK报文, 客户端<strong>应该</strong>关闭网络连接. <em>合理</em> 的时间取决于应用的类型和通信基础设施.</p><h4 id="3-2-1-固定报头"><a href="#3-2-1-固定报头" class="headerlink" title="3.2.1 固定报头"></a>3.2.1 固定报头</h4><p>固定报头的格式见 <a href="https://www.zybuluo.com/khan-lau/note/1326839#_Figure_3.8_–" target="_blank" rel="noopener">图例 3.8 – CONNACK 报文固定报头</a> 的描述.</p><h5 id="图例-3-8-–-CONNACK-报文固定报头"><a href="#图例-3-8-–-CONNACK-报文固定报头" class="headerlink" title="图例 3.8 – CONNACK 报文固定报头"></a>图例 3.8 – CONNACK 报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT报文类型 (2)</td><td>Reserved 保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2…</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度. 对于CONNACK报文这个值等于2.</p><h4 id="3-2-2-可变报头"><a href="#3-2-2-可变报头" class="headerlink" title="3.2.2 可变报头"></a>3.2.2 可变报头</h4><p>可变报头的格式见 <a href="https://www.zybuluo.com/khan-lau/note/1326839#_图例_3.9_–CONNACK报文可变报头" target="_blank" rel="noopener">图例 3.9 –CONNACK报文可变报头</a> 的描述.</p><h5 id="图例-3-9-–CONNACK报文可变报头"><a href="#图例-3-9-–CONNACK报文可变报头" class="headerlink" title="图例 3.9 –CONNACK报文可变报头"></a>图例 3.9 –CONNACK报文可变报头</h5><table><thead><tr><th align="left"><strong>描述</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">连接确认标志</td><td align="left">Reserved 保留位</td><td align="left">SP1</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">连接返回码</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left"></td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td></tr></tbody></table><table><thead><tr><th></th><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>连接确认标志</td><td>Reserved 保留位</td><td>SP1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X</td></tr><tr><td>连接返回码</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table><h5 id="连接确认标志-Connect-Acknowledge-Flags"><a href="#连接确认标志-Connect-Acknowledge-Flags" class="headerlink" title="连接确认标志 Connect Acknowledge Flags"></a>连接确认标志 Connect Acknowledge Flags</h5><p>第1个字节是 <em>连接确认标志</em>, 位7-1是保留位且<strong>必须</strong>设置为0.<br>第0 (SP)位 是当前会话(Session Present)标志.</p><h5 id="当前会话-Session-Present"><a href="#当前会话-Session-Present" class="headerlink" title="当前会话 Session Present"></a>当前会话 Session Present</h5><p><strong>位置：</strong>连接确认标志的第0位.</p><p>如果服务端收到清理会话(CleanSession)标志为1的连接, 除了将CONNACK报文中的返回码设置为0之外, 还<strong>必须</strong>将CONNACK报文中的当前会话设置(Session Present)标志为0 [MQTT-3.2.2-1].</p><p>如果服务端收到一个CleanSession为0的连接, 当前会话标志的值取决于服务端是否已经保存了ClientId对应客户端的会话状态. 如果服务端已经保存了会话状态, 它<strong>必须</strong>将CONNACK报文中的当前会话标志设置为1 [MQTT-3.2.2-2]. 如果服务端没有已保存的会话状态, 它<strong>必须</strong>将CONNACK报文中的当前会话设置为0. 还需要将CONNACK报文中的返回码设置为0 [MQTT-3.2.2-3].</p><p>当前会话标志使服务端和客户端在是否有已存储的会话状态上保持一致.</p><p>一旦完成了会话的初始化设置, 已经保存会话状态的客户端将期望服务端维持它存储的会话状态. 如果客户端从服务端收到的当前的值与预期的不同, 客户端可以选择继续这个会话或者断开连接. 客户端可以丢弃客户端和服务端之间的会话状态, 方法是, 断开连接, 将清理会话标志设置为1, 再次连接, 然后再次断开连接.</p><p>如果服务端发送了一个包含非零返回码的CONNACK报文, 它<strong>必须</strong>将当前会话标志设置为0 [MQTT-3.2.2-4].</p><h5 id="连接返回码-Connect-Return-code"><a href="#连接返回码-Connect-Return-code" class="headerlink" title="连接返回码 Connect Return code"></a>连接返回码 Connect Return code</h5><p><strong>位置：</strong>可变报头的第2个字节.</p><p>连接返回码字段使用一个字节的无符号值, 在 <a href="https://www.zybuluo.com/khan-lau/note/1326839#_表格_3.1_–连接返回码的值" target="_blank" rel="noopener">表格 3.1 –连接返回码的值</a> 中列出. 如果服务端收到一个合法的CONNECT报文, 但出于某些原因无法处理它, 服务端应该尝试发送一个包含非零返回码(表格中的某一个)的CONNACK报文. 如果服务端发送了一个包含非零返回码的CONNACK报文, 那么它<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-5]..</p><h6 id="表格-3-1-–连接返回码的值"><a href="#表格-3-1-–连接返回码的值" class="headerlink" title="表格 3.1 –连接返回码的值"></a>表格 3.1 –连接返回码的值</h6><table><thead><tr><th align="left"><strong>值</strong></th><th align="left"><strong>返回码响应</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00连接已接受</td><td align="left">连接已被服务端接受</td></tr><tr><td align="left">1</td><td align="left">0x01连接已拒绝, 不支持的协议版本</td><td align="left">服务端不支持客户端请求的MQTT协议级别</td></tr><tr><td align="left">2</td><td align="left">0x02连接已拒绝, 不合格的客户端标识符</td><td align="left">客户端标识符是正确的UTF-8编码, 但服务端不允许使用</td></tr><tr><td align="left">3</td><td align="left">0x03连接已拒绝, 服务端不可用</td><td align="left">网络连接已建立, 但MQTT服务不可用</td></tr><tr><td align="left">4</td><td align="left">0x04连接已拒绝, 无效的用户名或密码</td><td align="left">用户名或密码的数据格式无效</td></tr><tr><td align="left">5</td><td align="left">0x05连接已拒绝, 未授权</td><td align="left">客户端未被授权连接到此服务器</td></tr><tr><td align="left">6-255</td><td align="left"></td><td align="left">保留</td></tr></tbody></table><p>如果认为上表中的所有连接返回码都不太合适, 那么服务端<strong>必须</strong>关闭网络连接, 不需要发送CONNACK报文 [MQTT-3.2.2-6].</p><h4 id="3-2-3-有效载荷"><a href="#3-2-3-有效载荷" class="headerlink" title="3.2.3 有效载荷"></a>3.2.3 有效载荷</h4><p>CONNACK报文没有有效载荷.</p><h3 id="3-3-PUBLISH-–-发布消息"><a href="#3-3-PUBLISH-–-发布消息" class="headerlink" title="3.3 PUBLISH – 发布消息"></a>3.3 PUBLISH – 发布消息</h3><p>PUBLISH控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息.</p><h4 id="3-3-1-固定报头"><a href="#3-3-1-固定报头" class="headerlink" title="3.3.1 固定报头"></a>3.3.1 固定报头</h4><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#_图例_3.10_–" target="_blank" rel="noopener">图例 3.10 – PUBLISH报文固定报头</a>描述了固定报头的格式</p><h6 id="图例-3-10-–-PUBLISH报文固定报头"><a href="#图例-3-10-–-PUBLISH报文固定报头" class="headerlink" title="图例 3.10 – PUBLISH报文固定报头"></a>图例 3.10 – PUBLISH报文固定报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (3)</td><td>DUP</td><td>QoS-H</td><td>QoS-</td><td>RETAIN</td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>1</td><td>1</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>byte 2…</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h5 id="重发标志-DUP"><a href="#重发标志-DUP" class="headerlink" title="重发标志 DUP"></a>重发标志 DUP</h5><p><strong>位置：</strong>第1个字节, 第3位</p><p>如果DUP标志被设置为0, 表示这是客户端或服务端第一次请求发送这个PUBLISH报文. 如果DUP标志被设置为1, 表示这可能是一个早前报文请求的重发.</p><p>客户端或服务端请求重发一个PUBLISH报文时, <strong>必须</strong>将DUP标志设置为1 [MQTT-3.3.1.-1].. 对于QoS 0的消息, DUP标志<strong>必须</strong>设置为0 [MQTT-3.3.1-2].</p><p>服务端发送PUBLISH报文给订阅者时, 收到(入站)的PUBLISH报文的DUP标志的值不会被传播. 发送(出站)的PUBLISH报文与收到(入站)的PUBLISH报文中的DUP标志是独立设置的, 它的值<strong>必须</strong>单独的根据发送(出站)的PUBLISH报文是否是一个重发来确定 [MQTT-3.3.1-3].</p><blockquote><p><strong>非规范评注</strong></p><p>接收者收到一个DUP标志为1的控制报文时, 不能假设它看到了一个这个报文之前的一个副本.</p><p><strong>非规范评注</strong></p><p>需要特别指出的是, DUP标志关注的是控制报文本身, 与它包含的应用消息无关. 当使用QoS 1时, 客户端可能会收到一个DUP标志为0的PUBLISH报文, 这个报文包含一个它之前收到过的应用消息的副本, 但是用的是不同的报文标识符. 2.3.1节提供了有关报文标识符的更多信息.</p></blockquote><h5 id="服务质量等级-QoS"><a href="#服务质量等级-QoS" class="headerlink" title="服务质量等级 QoS"></a>服务质量等级 QoS</h5><p><strong>位置：</strong>第1个字节, 第2-1位.</p><p>这个字段表示应用消息分发的服务质量等级保证. 服务质量等级在 <a href="https://www.zybuluo.com/khan-lau/note/1326839#_表格_3.2_-服务质量定义" target="_blank" rel="noopener">表格 3.2 -服务质量定义</a> 中列出.</p><h6 id="表格-3-2-服务质量定义"><a href="#表格-3-2-服务质量定义" class="headerlink" title="表格 3.2 -服务质量定义"></a>表格 3.2 -服务质量定义</h6><table><thead><tr><th align="left"><strong>QoS值</strong></th><th align="left"><strong>Bit 2</strong></th><th align="left"><strong>Bit 1</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">最多分发一次</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">至少分发一次</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">0</td><td align="left">只分发一次</td></tr><tr><td align="left">-</td><td align="left">1</td><td align="left">1</td><td align="left">保留位</td></tr></tbody></table><p>PUBLISH报文<strong>不能</strong>将QoS所有的位设置为1. 如果服务端或客户端收到QoS所有位都为1的PUBLISH报文, 它<strong>必须</strong>关闭网络连接 [MQTT-3.3.1-4].</p><h5 id="保留标志-RETAIN"><a href="#保留标志-RETAIN" class="headerlink" title="保留标志 RETAIN"></a>保留标志 RETAIN</h5><p><strong>位置：</strong>第1个字节, 第0位.</p><p>如果客户端发给服务端的PUBLISH报文的保留(RETAIN)标志被设置为1, 服务端<strong>必须</strong>存储这个应用消息和它的服务质量等级(QoS), 以便它可以被分发给未来的主题名匹配的订阅者 [MQTT-3.3.1-5]. 一个新的订阅建立时, 对每个匹配的主题名, 如果存在最近保留的消息, 它<strong>必须</strong>被发送给这个订阅者 [MQTT-3.3.1-6]. 如果服务端收到一条保留(RETAIN)标志为1的QoS 0消息, 它<strong>必须</strong>丢弃之前为那个主题保留的任何消息. 它<strong>应该</strong>将这个新的QoS 0消息当作那个主题的新保留消息, 但是任何时候都<strong>可以</strong>选择丢弃它 — 如果这种情况发生了, 那个主题将没有保留消息 [MQTT-3.3.1-7]. 有关存储状态的更多信息见 <a href="https://www.zybuluo.com/khan-lau/note/1326839#41-状态存储-storing-state" target="_blank" rel="noopener">4.1节</a>.</p><p>服务端发送PUBLISH报文给客户端时, 如果消息是作为客户端一个新订阅的结果发送, 它<strong>必须</strong>将报文的保留标志设为1 [MQTT-3.3.1-8]. 当一个PUBLISH报文发送给客户端是因为匹配一个已建立的订阅时, 服务端<strong>必须</strong>将保留标志设为0, 不管它收到的这个消息中保留标志的值是多少 [MQTT-3.3.1-9].</p><p>保留标志为1且有效载荷为零字节的PUBLISH报文会被服务端当作正常消息处理, 它会被发送给订阅主题匹配的客户端. 此外, 同一个主题下任何现存的保留消息必须被移除, 因此这个主题之后的任何订阅者都不会收到一个保留消息 [MQTT-3.3.1-10]. <em>当作正常</em> 意思是现存的客户端收到的消息中保留标志未被设置. 服务端<strong>不能</strong>存储零字节的保留消息 [MQTT-3.3.1-11].</p><p>如果客户端发给服务端的PUBLISH报文的保留标志位0, 服务端<strong>不能</strong>存储这个消息也<strong>不能</strong>移除或替换任何现存的保留消息 [MQTT-3.3.1-12].</p><blockquote><p><strong>非规范评注</strong></p><p>对于发布者不定期发送状态消息这个场景, 保留消息很有用. 新的订阅者将会收到最近的状态.</p></blockquote><p><strong>剩余长度字段</strong></p><p>等于可变报头的长度加上有效载荷的长度.</p><h4 id="3-3-2-可变报头"><a href="#3-3-2-可变报头" class="headerlink" title="3.3.2 可变报头"></a>3.3.2 可变报头</h4><p>可变报头按顺序包含主题名和报文标识符.</p><h5 id="主题名-Topic-Name"><a href="#主题名-Topic-Name" class="headerlink" title="主题名 Topic Name"></a>主题名 Topic Name</h5><p>主题名(Topic Name)用于识别有效载荷数据应该被发布到哪一个信息通道.</p><p>主题名<strong>必须</strong>是PUBLISH报文可变报头的第一个字段. 它<strong>必须</strong>是 <a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码的字符串 [MQTT-3.3.2-1].</p><p>PUBLISH报文中的主题名<strong>不能</strong>包含通配符 [MQTT-3.3.2-2].</p><p>服务端发送给订阅客户端的PUBLISH报文的主题名<strong>必须</strong>匹配该订阅的主题过滤器(根据 4.7节定义的匹配过程)[MQTT-3.3.2-3].</p><h5 id="报文标识符-Packet-Identifier"><a href="#报文标识符-Packet-Identifier" class="headerlink" title="报文标识符 Packet Identifier"></a>报文标识符 Packet Identifier</h5><p>只有当QoS等级是1或2时, 报文标识符(Packet Identifier)字段才能出现在PUBLISH报文中. 2.3.1节提供了有关报文标识符的更多信息.</p><h5 id="可变报头非规范示例-1"><a href="#可变报头非规范示例-1" class="headerlink" title="可变报头非规范示例"></a>可变报头非规范示例</h5><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#_Figure_3.11_-" target="_blank" rel="noopener">图例 3.11 – PUBLISH报文可变报头非规范示例</a> 举例说明了 <a href="https://www.zybuluo.com/khan-lau/note/1326839#_表格_3.3_-" target="_blank" rel="noopener">表格 3.3 - PUBLISH报文非规范示例</a> 中简要描述的PUBLISH报文的可变报头.</p><h6 id="表格-3-3-PUBLISH报文非规范示例"><a href="#表格-3-3-PUBLISH报文非规范示例" class="headerlink" title="表格 3.3 - PUBLISH报文非规范示例"></a>表格 3.3 - PUBLISH报文非规范示例</h6><table><thead><tr><th align="left"><strong>Field</strong></th><th align="left"><strong>Value</strong></th></tr></thead><tbody><tr><td align="left">主题名</td><td align="left">a/b</td></tr><tr><td align="left">报文标识符</td><td align="left">10</td></tr></tbody></table><h6 id="图例-3-11-–-PUBLISH报文可变报头非规范示例"><a href="#图例-3-11-–-PUBLISH报文可变报头非规范示例" class="headerlink" title="图例 3.11 – PUBLISH报文可变报头非规范示例"></a>图例 3.11 – PUBLISH报文可变报头非规范示例</h6><table><thead><tr><th align="left"><strong>描述</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">Topic Name 主题名</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left">‘a’ (0x61)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 4</td><td align="left">‘/’ (0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 5</td><td align="left">‘b’ (0x62)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">报文标识符</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 6</td><td align="left">报文标识符 MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 7</td><td align="left">报文标识符 LSB (10)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr></tbody></table><p>示例中的主题名为 “a/b”, 长度等于3, 报文标识符为 “10”</p><h4 id="3-3-3-有效载荷"><a href="#3-3-3-有效载荷" class="headerlink" title="3.3.3 有效载荷"></a>3.3.3 有效载荷</h4><p>有效载荷包含将被发布的应用消息. 数据的内容和格式是应用特定的. 有效载荷的长度这样计算：用固定报头中的剩余长度字段的值减去可变报头的长度. 包含零长度有效载荷的PUBLISH报文是合法的.</p><h4 id="3-3-4-响应"><a href="#3-3-4-响应" class="headerlink" title="3.3.4 响应"></a>3.3.4 响应</h4><p>PUBLISH报文的接收者<strong>必须</strong>按照根据PUBLISH报文中的QoS等级发送响应, 见下面表格的描述 [MQTT-3.3.4-1].</p><h6 id="表格-3-4-–-PUBLISH报文的预期响应"><a href="#表格-3-4-–-PUBLISH报文的预期响应" class="headerlink" title="表格 3.4 – PUBLISH报文的预期响应"></a>表格 3.4 – PUBLISH报文的预期响应</h6><table><thead><tr><th align="left"><strong>服务质量等级</strong></th><th align="left"><strong>预期响应</strong></th></tr></thead><tbody><tr><td align="left">QoS 0</td><td align="left">无响应</td></tr><tr><td align="left">QoS 1</td><td align="left">PUBACK报文</td></tr><tr><td align="left">QoS 2</td><td align="left">PUBREC报文</td></tr></tbody></table><h4 id="3-3-5-动作-Actions"><a href="#3-3-5-动作-Actions" class="headerlink" title="3.3.5 动作 Actions"></a>3.3.5 动作 Actions</h4><p>客户端使用PUBLISH报文发送应用消息给服务端, 目的是分发到其它订阅匹配的客户端.</p><p>服务端使用PUBLISH报文发送应用消息给每一个订阅匹配的客户端.</p><p>客户端使用带通配符的主题过滤器请求订阅时, 客户端的订阅可能会重复, 因此发布的消息可能会匹配多个过滤器. 对于这种情况, 服务端<strong>必须</strong>将消息分发给所有订阅匹配的QoS等级最高的客户端 [MQTT-3.3.5-1]. 服务端之后可以按照订阅的QoS等级, 分发消息的副本给每一个匹配的订阅者.</p><p>收到一个PUBLISH报文时, 接收者的动作取决于4.3节描述的QoS等级.</p><p>如果服务端实现不授权某个客户端发布PUBLISH报文, 它没有办法通知那个客户端. 它<strong>必须</strong>按照正常的QoS规则发送一个正面的确认, 或者关闭网络连接 [MQTT-3.3.5-2].</p><h3 id="3-4-PUBACK-–发布确认"><a href="#3-4-PUBACK-–发布确认" class="headerlink" title="3.4 PUBACK –发布确认"></a>3.4 PUBACK –发布确认</h3><p>PUBACK报文是对QoS 1等级的PUBLISH报文的响应.</p><h4 id="3-4-1-固定报头"><a href="#3-4-1-固定报头" class="headerlink" title="3.4.1 固定报头"></a>3.4.1 固定报头</h4><h6 id="图例-3-12-PUBACK报文固定报头"><a href="#图例-3-12-PUBACK报文固定报头" class="headerlink" title="图例 3.12 - PUBACK报文固定报头"></a>图例 3.12 - PUBACK报文固定报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT报文类型 (4)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2…</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度. 对PUBACK报文这个值等于2.</p><h4 id="3-4-2-可变报头"><a href="#3-4-2-可变报头" class="headerlink" title="3.4.2 可变报头"></a>3.4.2 可变报头</h4><p>包含等待确认的PUBLISH报文的报文标识符.</p><h6 id="图例-3-13-–-PUBACK报文可变报头"><a href="#图例-3-13-–-PUBACK报文可变报头" class="headerlink" title="图例 3.13 – PUBACK报文可变报头"></a>图例 3.13 – PUBACK报文可变报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-4-3-有效载荷"><a href="#3-4-3-有效载荷" class="headerlink" title="3.4.3 有效载荷"></a>3.4.3 有效载荷</h4><p>PUBACK报文没有有效载荷.</p><h4 id="3-4-4-动作"><a href="#3-4-4-动作" class="headerlink" title="3.4.4 动作"></a>3.4.4 动作</h4><p>完整的描述见 4.3.2节.</p><h3 id="3-5-PUBREC-–-发布收到-QoS-2-第一步"><a href="#3-5-PUBREC-–-发布收到-QoS-2-第一步" class="headerlink" title="3.5 PUBREC – 发布收到(QoS 2, 第一步)"></a>3.5 PUBREC – 发布收到(QoS 2, 第一步)</h3><p>PUBREC报文是对QoS等级2的PUBLISH报文的响应. 它是QoS 2等级协议交换的第二个报文.</p><h4 id="3-5-1-固定报头"><a href="#3-5-1-固定报头" class="headerlink" title="3.5.1 固定报头"></a>3.5.1 固定报头</h4><h6 id="图例-3-14-–-PUBREC报文固定报头"><a href="#图例-3-14-–-PUBREC报文固定报头" class="headerlink" title="图例 3.14 – PUBREC报文固定报头"></a>图例 3.14 – PUBREC报文固定报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (5)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度. 对PUBREC报文它的值等于2.</p><h4 id="3-5-2-可变报头"><a href="#3-5-2-可变报头" class="headerlink" title="3.5.2 可变报头"></a>3.5.2 可变报头</h4><p>可变报头包含等待确认的PUBLISH报文的报文标识符.</p><h6 id="图例-3-15-–-PUBREC报文可变报头"><a href="#图例-3-15-–-PUBREC报文可变报头" class="headerlink" title="图例 3.15 – PUBREC报文可变报头"></a>图例 3.15 – PUBREC报文可变报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-5-3-有效载荷"><a href="#3-5-3-有效载荷" class="headerlink" title="3.5.3 有效载荷"></a>3.5.3 有效载荷</h4><p>PUBREC报文没有有效载荷.</p><h4 id="3-5-4-动作"><a href="#3-5-4-动作" class="headerlink" title="3.5.4 动作"></a>3.5.4 动作</h4><p>完整的描述见 4.3.3节.</p><h3 id="3-6-PUBREL-–-发布释放-QoS-2-第二步"><a href="#3-6-PUBREL-–-发布释放-QoS-2-第二步" class="headerlink" title="3.6 PUBREL – 发布释放(QoS 2, 第二步)"></a>3.6 PUBREL – 发布释放(QoS 2, 第二步)</h3><p>PUBREL报文是对PUBREC报文的响应. 它是QoS 2等级协议交换的第三个报文.</p><h4 id="3-6-1-固定报头"><a href="#3-6-1-固定报头" class="headerlink" title="3.6.1 固定报头"></a>3.6.1 固定报头</h4><h6 id="图例-3-16-–-PUBREL报文固定报头"><a href="#图例-3-16-–-PUBREL报文固定报头" class="headerlink" title="图例 3.16 – PUBREL报文固定报头"></a>图例 3.16 – PUBREL报文固定报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (6)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>PUBREL控制报文固定报头的第3,2,1,0位是保留位, <strong>必须</strong>被设置为0,0,1,0. 服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接 [MQTT-3.6.1-1].</p><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度. 对PUBREL报文这个值等于2.</p><h4 id="3-6-2-可变报头"><a href="#3-6-2-可变报头" class="headerlink" title="3.6.2 可变报头"></a>3.6.2 可变报头</h4><p>可变报头包含与等待确认的PUBREC报文相同的报文标识符.</p><h6 id="图例-3-17-–-PUBREL报文可变报头"><a href="#图例-3-17-–-PUBREL报文可变报头" class="headerlink" title="图例 3.17 – PUBREL报文可变报头"></a>图例 3.17 – PUBREL报文可变报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-6-3-有效载荷"><a href="#3-6-3-有效载荷" class="headerlink" title="3.6.3 有效载荷"></a>3.6.3 有效载荷</h4><p>PUBREL报文没有有效载荷.</p><h4 id="3-6-4-动作"><a href="#3-6-4-动作" class="headerlink" title="3.6.4 动作"></a>3.6.4 动作</h4><p>完整的描述见 4.3.3节.</p><h3 id="3-7-PUBCOMP-–-发布完成-QoS-2-第三步"><a href="#3-7-PUBCOMP-–-发布完成-QoS-2-第三步" class="headerlink" title="3.7 PUBCOMP – 发布完成(QoS 2, 第三步)"></a>3.7 PUBCOMP – 发布完成(QoS 2, 第三步)</h3><p>PUBCOMP报文是对PUBREL报文的响应. 它是QoS 2等级协议交换的第四个也是最后一个报文.</p><h4 id="3-7-1-固定报头"><a href="#3-7-1-固定报头" class="headerlink" title="3.7.1 固定报头"></a>3.7.1 固定报头</h4><h6 id="图例-3-18-–-PUBCOMP报文固定报头"><a href="#图例-3-18-–-PUBCOMP报文固定报头" class="headerlink" title="图例 3.18 – PUBCOMP报文固定报头"></a>图例 3.18 – PUBCOMP报文固定报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (7)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度. 对PUBCOMP报文这个值等于2.</p><h4 id="3-7-2-可变报头"><a href="#3-7-2-可变报头" class="headerlink" title="3.7.2 可变报头"></a>3.7.2 可变报头</h4><p>可变报头包含与等待确认的PUBREL报文相同的报文标识符.</p><h6 id="图例-3-19-–-PUBCOMP报文可变报头"><a href="#图例-3-19-–-PUBCOMP报文可变报头" class="headerlink" title="图例 3.19 – PUBCOMP报文可变报头"></a>图例 3.19 – PUBCOMP报文可变报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-7-3-有效载荷"><a href="#3-7-3-有效载荷" class="headerlink" title="3.7.3 有效载荷"></a>3.7.3 有效载荷</h4><p>PUBCOMP报文没有有效载荷.</p><h4 id="3-7-4-动作"><a href="#3-7-4-动作" class="headerlink" title="3.7.4 动作"></a>3.7.4 动作</h4><p>完整的描述见4.3.3节.</p><h3 id="3-8-SUBSCRIBE-订阅主题"><a href="#3-8-SUBSCRIBE-订阅主题" class="headerlink" title="3.8 SUBSCRIBE - 订阅主题"></a>3.8 SUBSCRIBE - 订阅主题</h3><p>客户端向服务端发送SUBSCRIBE报文用于创建一个或多个订阅. 每个订阅注册客户端关心的一个或多个主题. 为了将应用消息转发给与那些订阅匹配的主题, 服务端发送PUBLISH报文给客户端. SUBSCRIBE报文也(为每个订阅)指定了最大的QoS等级, 服务端根据这个发送应用消息给客户端.</p><h4 id="3-8-1-固定报头"><a href="#3-8-1-固定报头" class="headerlink" title="3.8.1 固定报头"></a>3.8.1 固定报头</h4><h6 id="图例-3-20-–-SUBSCRIBE报文固定报头"><a href="#图例-3-20-–-SUBSCRIBE报文固定报头" class="headerlink" title="图例 3.20 – SUBSCRIBE报文固定报头"></a>图例 3.20 – SUBSCRIBE报文固定报头</h6><table><thead><tr><th align="left"><strong>Bit</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (8)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (8)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>SUBSCRIBE控制报固定报头的第3,2,1,0位是保留位, <strong>必须</strong>分别设置为0,0,1,0. 服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接 [MQTT-3.8.1-1].</p><p><strong>剩余长度字段</strong></p><p>等于可变报头的长度(2字节)加上有效载荷的长度.</p><h4 id="3-8-2可变报头"><a href="#3-8-2可变报头" class="headerlink" title="3.8.2可变报头"></a>3.8.2可变报头</h4><p>可变报头包含报文标识符. 2.3.1提供了有关报文标识符的更多信息.</p><h5 id="可变报头非规范示例-2"><a href="#可变报头非规范示例-2" class="headerlink" title="可变报头非规范示例"></a>可变报头非规范示例</h5><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#_图例_3.21_–" target="_blank" rel="noopener">图例 3.21 – 报文标识符等于10的可变报头, 非规范示例</a> 展示了报文标识符设置为10时的可变报头.</p><h6 id="图例-3-21-–-报文标识符等于10的可变报头-非规范示例"><a href="#图例-3-21-–-报文标识符等于10的可变报头-非规范示例" class="headerlink" title="图例 3.21 – 报文标识符等于10的可变报头, 非规范示例"></a>图例 3.21 – 报文标识符等于10的可变报头, 非规范示例</h6><table><thead><tr><th align="left"><strong>描述</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">报文标识符</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">报文标识符 MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符 LSB (10)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr></tbody></table><h4 id="3-8-3-有效载荷"><a href="#3-8-3-有效载荷" class="headerlink" title="3.8.3 有效载荷"></a>3.8.3 有效载荷</h4><p>SUBSCRIBE报文的有效载荷包含了一个主题过滤器列表, 它们表示客户端想要订阅的主题. SUBSCRIBE报文有效载荷中的主题过滤器列表<strong>必须</strong>是<a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8字符串 [MQTT-3.8.3-1]. 服务端<strong>应该</strong>支持包含通配符( 4.7.1节 定义的)的主题过滤器. 如果服务端选择不支持包含通配符的主题过滤器, <strong>必须</strong>拒绝任何包含通配符过滤器的订阅请求 [MQTT-3.8.3-2]. 每一个过滤器后面跟着一个字节, 这个字节被叫做 服务质量要求(Requested QoS). 它给出了服务端向客户端发送应用消息所允许的最大QoS等级.</p><p>SUBSCRIBE报文的有效载荷<strong>必须</strong>包含至少一对主题过滤器 和 QoS等级字段组合. 没有有效载荷的SUBSCRIBE报文是违反协议的 [MQTT-3.8.3-3]. 有关错误处理的信息请查看<a href="https://www.zybuluo.com/khan-lau/note/1326839#48-错误处理-handling-errors" target="_blank" rel="noopener">4.8节</a>.</p><p>请求的最大服务质量等级字段编码为一个字节, 它后面跟着UTF-8编码的主题名, 那些主题过滤器 /和QoS等级组合是连续地打包.</p><h6 id="图例-3-22-–-SUBSCRIBE报文有效载荷格式"><a href="#图例-3-22-–-SUBSCRIBE报文有效载荷格式" class="headerlink" title="图例 3.22 – SUBSCRIBE报文有效载荷格式"></a>图例 3.22 – SUBSCRIBE报文有效载荷格式</h6><table><thead><tr><th align="left"><strong>描述</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">主题过滤器</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">长度 MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">长度 LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">bytes 3..N</td><td align="left">主题过滤器(Topic Filter)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">服务质量要求(Requested QoS)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">保留位</td><td align="left">服务质量等级</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte N+1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">X</td><td align="left">X</td></tr></tbody></table><table><thead><tr><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>主题过滤器</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>长度 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>长度 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 3..N</td><td>主题过滤器(Topic Filter)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>服务质量要求(Requested QoS)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>保留位</td><td>服务质量等级</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte N+1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X</td><td>X</td></tr></tbody></table><p>当前版本的协议没有用到服务质量要求(Requested QoS)字节的高六位. 如果有效载荷中的任何位是非零值, 或者QoS不等于0,1或2, 服务端<strong>必须</strong>认为SUBSCRIBE报文是不合法的并关闭网络连接 [MQTT-3-8.3-4].</p><h5 id="有效载荷非规范示例"><a href="#有效载荷非规范示例" class="headerlink" title="有效载荷非规范示例"></a>有效载荷非规范示例</h5><blockquote><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#_Figure_3.23_-" target="_blank" rel="noopener">图例 3.23 – 有效载荷字节格式非规范示例</a> 展示了 <a href="https://www.zybuluo.com/khan-lau/note/1326839#_Table_3.4_-" target="_blank" rel="noopener">表格 3.5 – 有效载荷非规范示例</a> 中简略描述的SUBSCRIBE报文的有效载荷.</p></blockquote><h6 id="表格-3-5-–-有效载荷非规范示例"><a href="#表格-3-5-–-有效载荷非规范示例" class="headerlink" title="表格 3.5 – 有效载荷非规范示例"></a>表格 3.5 – 有效载荷非规范示例</h6><table><thead><tr><th align="left">主题名</th><th align="left">“a/b”</th></tr></thead><tbody><tr><td align="left">服务质量要求</td><td align="left">0x01</td></tr><tr><td align="left">主题名</td><td align="left">“c/d”</td></tr><tr><td align="left">服务质量要求</td><td align="left">0x02</td></tr></tbody></table><h6 id="图例-3-23-–-有效载荷字节格式非规范示例"><a href="#图例-3-23-–-有效载荷字节格式非规范示例" class="headerlink" title="图例 3.23 – 有效载荷字节格式非规范示例"></a>图例 3.23 – 有效载荷字节格式非规范示例</h6><table><thead><tr><th align="left"><strong>描述</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">主题过滤器(Topic Filter)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left">‘a’ (0x61)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 4</td><td align="left">‘/’ (0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 5</td><td align="left">‘b’ (0x62)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">服务质量要求(Requested QoS)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 6</td><td align="left">Requested QoS(1)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">主题过滤器(Topic Filter)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 7</td><td align="left">Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 8</td><td align="left">Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 9</td><td align="left">‘c’ (0x63)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 10</td><td align="left">‘/’ (0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 11</td><td align="left">‘d’ (0x64)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">服务质量要求(Requested QoS)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 12</td><td align="left">Requested QoS(2)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr></tbody></table><h4 id="3-8-4-响应"><a href="#3-8-4-响应" class="headerlink" title="3.8.4 响应"></a>3.8.4 响应</h4><p>服务端收到客户端发送的一个SUBSCRIBE报文时, <strong>必须</strong>使用SUBACK报文响应 [MQTT-3.8.4-1]. SUBACK报文<strong>必须</strong>和等待确认的SUBSCRIBE报文有相同的报文标识符 [MQTT-3.8.4-2].</p><p>允许服务端在发送SUBACK报文之前就开始发送与订阅匹配的PUBLISH报文.</p><p>如果服务端收到一个SUBSCRIBE报文, 报文的主题过滤器与一个现存订阅的主题过滤器相同, 那么<strong>必须</strong>使用新的订阅彻底替换现存的订阅. 新订阅的主题过滤器和之前订阅的相同, 但是它的最大QoS值可以不同. 与这个主题过滤器匹配的任何现存的保留消息<strong>必须</strong>被重发, 但是发布流程<strong>不能</strong>中断 <a href="https://tools.oasis-open.org/issues/browse/MQTT-3" target="_blank" rel="noopener">MQTT-3</a>.8.4-3].</p><p>如果主题过滤器不同于任何现存订阅的过滤器, 服务端会创建一个新的订阅并发送所有匹配的保留消息.</p><p>如果服务端收到包含多个主题过滤器的SUBSCRIBE报文, 它<strong>必须</strong>如同收到了一系列的多个SUBSCRIBE报文一样处理那个, 除了需要将它们的响应合并到一个单独的SUBACK报文发送 [MQTT-3.8.4-4].</p><p>服务端发送给客户端的SUBACK报文对每一对主题过滤器 和QoS等级都<strong>必须</strong>包含一个返回码. 这个返回码<strong>必须</strong>表示那个订阅被授予的最大QoS等级, 或者表示这个订阅失败 <a href="https://tools.oasis-open.org/issues/browse/MQTT-3" target="_blank" rel="noopener">MQTT-3</a>.8.4-5]. 服务端可以授予比订阅者要求的低一些的QoS等级. 为响应订阅而发出的消息的有效载荷的QoS<strong>必须</strong>是原始发布消息的QoS和服务端授予的QoS两者中的最小值. 如果原始消息的QoS是1而被授予的最大QoS是0, 允许服务端重复发送一个消息的副本给订阅者 <a href="https://tools.oasis-open.org/issues/browse/MQTT-3" target="_blank" rel="noopener">MQTT-3</a>.8.4-6].</p><blockquote><p><strong>非规范示例</strong><br>对某个特定的主题过滤器, 如果正在订阅的客户端被授予的最大QoS等级是1, 那么匹配这个过滤器的QoS等级0的应用消息会按QoS等级0分发给这个客户端. 这意味着客户端最多收到这个消息的一个副本. 从另一方面说, 发布给同一主题的QoS等级2的消息会被服务端降级到QoS等级1再分发给客户端, 因此客户端可能会收到重复的消息副本.</p><p>如果正在订阅的客户端被授予的最大QoS等级是0, 那么原来按QoS等级2发布给客户端的应用消息在繁忙时可能会丢失, 但是服务端不应该发送重复的消息副本. 发布给同一主题的 QoS等级1的消息在传输给客户端时可能会丢失或重复.</p><p><strong>非规范评注</strong></p><p>使用QoS等级2订阅一个主题过滤器等于是说：<em>我想要按照它们发布时的QoS等级接受匹配这个过滤器的消息</em> . 这意味着, 确定消息分发时可能的最大QoS等级是发布者的责任, 而订阅者可以要求服务端降低QoS到更适合它的等级.</p></blockquote><h3 id="3-9-SUBACK-–-订阅确认"><a href="#3-9-SUBACK-–-订阅确认" class="headerlink" title="3.9 SUBACK – 订阅确认"></a>3.9 SUBACK – 订阅确认</h3><p>服务端发送SUBACK报文给客户端, 用于确认它已收到并且正在处理SUBSCRIBE报文.</p><p>SUBACK报文包含一个返回码清单, 它们指定了SUBSCRIBE请求的每个订阅被授予的最大QoS等级.</p><h4 id="3-9-1-固定报头"><a href="#3-9-1-固定报头" class="headerlink" title="3.9.1 固定报头"></a>3.9.1 固定报头</h4><h6 id="图例-3-24-–-SUBACK报文固定报头"><a href="#图例-3-24-–-SUBACK报文固定报头" class="headerlink" title="图例 3.24 – SUBACK报文固定报头"></a>图例 3.24 – SUBACK报文固定报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (9)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>等于可变报头的长度加上有效载荷的长度.</p><h4 id="3-9-2-可变报头"><a href="#3-9-2-可变报头" class="headerlink" title="3.9.2 可变报头"></a>3.9.2 可变报头</h4><p>可变报头包含等待确认的SUBSCRIBE报文的报文标识符. <a href="https://www.zybuluo.com/khan-lau/note/1326839#_图例_3.25_–" target="_blank" rel="noopener">图例 3.25 – SUBACK报文可变报头</a> 描述了可变报头的格式.</p><h6 id="图例-3-25-–-SUBACK报文可变报头"><a href="#图例-3-25-–-SUBACK报文可变报头" class="headerlink" title="图例 3.25 – SUBACK报文可变报头"></a>图例 3.25 – SUBACK报文可变报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-9-3-有效载荷"><a href="#3-9-3-有效载荷" class="headerlink" title="3.9.3 有效载荷"></a>3.9.3 有效载荷</h4><p>有效载荷包含一个返回码清单. 每个返回码对应等待确认的SUBSCRIBE报文中的一个主题过滤器. 返回码的顺序<strong>必须</strong>和SUBSCRIBE报文中主题过滤器的顺序相同 [MQTT-3.9.3-1].</p><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#_Figure_3.26_-" target="_blank" rel="noopener">图例 3.26 – SUBACK报文有效载荷格式</a> 描述了有效载荷中单字节编码的返回码字段.</p><h6 id="图例-3-26-–-SUBACK报文有效载荷格式"><a href="#图例-3-26-–-SUBACK报文有效载荷格式" class="headerlink" title="图例 3.26 – SUBACK报文有效载荷格式"></a>图例 3.26 – SUBACK报文有效载荷格式</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td></td><td>返回码</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>X</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X</td><td>X</td></tr></tbody></table><p>允许的返回码值：</p><ul><li>0x00 - 最大QoS 0</li><li>0x01 - 成功 – 最大QoS 1</li><li>0x02 - 成功 – 最大 QoS 2</li><li>0x80 - Failure 失败</li></ul><p>0x00, 0x01, 0x02, 0x80之外的SUBACK返回码是保留的, <strong>不能</strong>使用[MQTT-3.9.3-2].</p><h5 id="有效载荷非规范示例-1"><a href="#有效载荷非规范示例-1" class="headerlink" title="有效载荷非规范示例"></a>有效载荷非规范示例</h5><blockquote><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#_Figure_3.27_-" target="_blank" rel="noopener">图例 3.27 -有效载荷字节格式非规范示例</a> 展示了在 <a href="https://www.zybuluo.com/khan-lau/note/1326839#_Table_3.5_-" target="_blank" rel="noopener">表格 3.6 -有效载荷非规范示例</a> 简要描述的SUBACK报文的有效载荷.</p></blockquote><h6 id="表格-3-6-有效载荷非规范示例"><a href="#表格-3-6-有效载荷非规范示例" class="headerlink" title="表格 3.6 -有效载荷非规范示例"></a>表格 3.6 -有效载荷非规范示例</h6><table><thead><tr><th align="left">Success - Maximum QoS 0</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">Success - Maximum QoS 2</td><td align="left">2</td></tr><tr><td align="left">Failure</td><td align="left">128</td></tr></tbody></table><h6 id="图例-3-27-有效载荷字节格式非规范示例"><a href="#图例-3-27-有效载荷字节格式非规范示例" class="headerlink" title="图例 3.27 -有效载荷字节格式非规范示例"></a>图例 3.27 -有效载荷字节格式非规范示例</h6><table><thead><tr><th align="left"><strong>描述</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">Success - Maximum QoS 0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">Success - Maximum QoS 2</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left">Failure</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h3 id="3-10-UNSUBSCRIBE-–取消订阅"><a href="#3-10-UNSUBSCRIBE-–取消订阅" class="headerlink" title="3.10 UNSUBSCRIBE –取消订阅"></a>3.10 UNSUBSCRIBE –取消订阅</h3><p>客户端发送UNSUBSCRIBE报文给服务端, 用于取消订阅主题.</p><h4 id="3-10-1-固定报头"><a href="#3-10-1-固定报头" class="headerlink" title="3.10.1 固定报头"></a>3.10.1 固定报头</h4><h6 id="图例-3-28-–-UNSUBSCRIBE报文固定报头"><a href="#图例-3-28-–-UNSUBSCRIBE报文固定报头" class="headerlink" title="图例 3.28 – UNSUBSCRIBE报文固定报头"></a>图例 3.28 – UNSUBSCRIBE报文固定报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (10)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>UNSUBSCRIBE报文固定报头的第3,2,1,0位是保留位且<strong>必须</strong>分别设置为0,0,1,0. 服务端<strong>必须</strong>认为任何其它的值都是不合法的并关闭网络连接 [MQTT-3.10.1-1].</p><p><strong>剩余长度字段</strong></p><p>等于可变报头的长度加上有效载荷的长度.</p><h4 id="3-10-2-可变报头"><a href="#3-10-2-可变报头" class="headerlink" title="3.10.2 可变报头"></a>3.10.2 可变报头</h4><p>可变报头包含一个报文标识符. 2.3.1节提供了有关报文标识符的更多信息.</p><h6 id="图例-3-29-–-UNSUBSCRIBE报文可变报头"><a href="#图例-3-29-–-UNSUBSCRIBE报文可变报头" class="headerlink" title="图例 3.29 – UNSUBSCRIBE报文可变报头"></a>图例 3.29 – UNSUBSCRIBE报文可变报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-10-3-有效载荷"><a href="#3-10-3-有效载荷" class="headerlink" title="3.10.3 有效载荷"></a>3.10.3 有效载荷</h4><p>UNSUBSCRIBE报文的有效载荷包含客户端想要取消订阅的主题过滤器列表. UNSUBSCRIBE报文中的主题过滤器<strong>必须</strong>是连续打包的、按照<a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码字符串 [MQTT-3.10.3-1].</p><p>UNSUBSCRIBE报文的有效载荷<strong>必须</strong>至少包含一个消息过滤器. 没有有效载荷的UNSUBSCRIBE报文是违反协议的 [MQTT-3.10.3-2]. 有关错误处理的更多信息请查看<a href="https://www.zybuluo.com/khan-lau/note/1326839#48-错误处理-handling-errors" target="_blank" rel="noopener">4.8节</a>.</p><h5 id="有效载荷非规范示例-2"><a href="#有效载荷非规范示例-2" class="headerlink" title="有效载荷非规范示例"></a>有效载荷非规范示例</h5><blockquote><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#_Figure_3.30_-" target="_blank" rel="noopener">图例 3.30 -有效载荷字节格式非规范示例</a> 展示了 <a href="https://www.zybuluo.com/khan-lau/note/1326839#_Table3.6_-_Payload" target="_blank" rel="noopener">表格 3.7 -有效载荷非规范示例</a> 简要描述的UNSUBSCRIBE报文的有效载荷.</p></blockquote><h6 id="表格-3-7-有效载荷非规范示例"><a href="#表格-3-7-有效载荷非规范示例" class="headerlink" title="表格 3.7 -有效载荷非规范示例"></a>表格 3.7 -有效载荷非规范示例</h6><table><thead><tr><th align="left">主题过滤器</th><th align="left">“a/b”</th></tr></thead><tbody><tr><td align="left">主题过滤器</td><td align="left">“c/d”</td></tr></tbody></table><h6 id="图例-3-30-有效载荷字节格式非规范示例"><a href="#图例-3-30-有效载荷字节格式非规范示例" class="headerlink" title="图例 3.30 -有效载荷字节格式非规范示例"></a>图例 3.30 -有效载荷字节格式非规范示例</h6><table><thead><tr><th align="left"><strong>描述</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">主题过滤器</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left">‘a’ (0x61)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 4</td><td align="left">‘/’ (0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 5</td><td align="left">‘b’ (0x62)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">主题过滤器</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 6</td><td align="left">Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 7</td><td align="left">Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 8</td><td align="left">‘c’ (0x63)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 9</td><td align="left">‘/’ (0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 10</td><td align="left">‘d’ (0x64)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr></tbody></table><h4 id="3-10-4-响应"><a href="#3-10-4-响应" class="headerlink" title="3.10.4 响应"></a>3.10.4 响应</h4><p>UNSUBSCRIBE报文提供的主题过滤器(无论是否包含通配符)<strong>必须</strong>与服务端持有的这个客户端的当前主题过滤器集合逐个字符比较. 如果有任何过滤器完全匹配, 那么它(服务端)自己的订阅将被删除, 否则不会有进一步的处理 [MQTT-3.10.4-1].</p><p>如果服务端删除了一个订阅：</p><ul><li>它<strong>必须</strong>停止分发任何新消息给这个客户端 [MQTT-3.10.4-2].</li><li>它<strong>必须</strong>完成分发任何已经开始往客户端发送的QoS 1和QoS 2的消息 [MQTT-3.10.4-3].</li><li>它<strong>可以</strong>继续发送任何现存的准备分发给客户端的缓存消息.</li></ul><p>服务端<strong>必须</strong>发送UNSUBACK报文响应客户端的UNSUBSCRIBE请求. UNSUBACK报文<strong>必须</strong>包含和UNSUBSCRIBE报文相同的报文标识符 [MQTT-3.10.4-4]. 即使没有删除任何主题订阅, 服务端也<strong>必须</strong>发送一个UNSUBACK响应 [MQTT-3.10.4-5].</p><p>如果服务端收到包含多个主题过滤器的UNSUBSCRIBE报文, 它<strong>必须</strong>如同收到了一系列的多个UNSUBSCRIBE报文一样处理那个报文, 除了将它们的响应合并到一个单独的UNSUBACK报文外. [MQTT-3.10.4-6].</p><h3 id="3-11-UNSUBACK-–-取消订阅确认"><a href="#3-11-UNSUBACK-–-取消订阅确认" class="headerlink" title="3.11 UNSUBACK – 取消订阅确认"></a>3.11 UNSUBACK – 取消订阅确认</h3><p>服务端发送UNSUBACK报文给客户端用于确认收到UNSUBSCRIBE报文.</p><h4 id="3-11-1-固定报头"><a href="#3-11-1-固定报头" class="headerlink" title="3.11.1 固定报头"></a>3.11.1 固定报头</h4><h6 id="图例-3-31-–-UNSUBACK报文固定报头"><a href="#图例-3-31-–-UNSUBACK报文固定报头" class="headerlink" title="图例 3.31 – UNSUBACK报文固定报头"></a>图例 3.31 – UNSUBACK报文固定报头</h6><table><thead><tr><th align="left"><strong>Bit</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (11)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度 (2)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr></tbody></table><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (11)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度, 对UNSUBACK报文这个值等于2.</p><h4 id="3-11-2-可变报头"><a href="#3-11-2-可变报头" class="headerlink" title="3.11.2 可变报头"></a>3.11.2 可变报头</h4><p>可变报头包含等待确认的UNSUBSCRIBE报文的报文标识符.</p><h6 id="图例-3-32-–-UNSUBACK报文可变报头"><a href="#图例-3-32-–-UNSUBACK报文可变报头" class="headerlink" title="图例 3.32 – UNSUBACK报文可变报头"></a>图例 3.32 – UNSUBACK报文可变报头</h6><table><thead><tr><th align="left"><strong>Bit</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">报文标识符 MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符 LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-11-3-有效载荷"><a href="#3-11-3-有效载荷" class="headerlink" title="3.11.3 有效载荷"></a>3.11.3 有效载荷</h4><p>UNSUBACK报文没有有效载荷.</p><h3 id="3-12-PINGREQ-–-心跳请求"><a href="#3-12-PINGREQ-–-心跳请求" class="headerlink" title="3.12 PINGREQ – 心跳请求"></a>3.12 PINGREQ – 心跳请求</h3><p>客户端发送PINGREQ报文给服务端的. 用于：</p><ol><li>在没有任何其它控制报文从客户端发给服务的时, 告知服务端客户端还活着.</li><li>请求服务端发送 响应确认它还活着.</li><li>使用网络以确认网络连接没有断开.</li></ol><p>保持连接(Keep Alive)处理中用到这个报文, 详细信息请查看 3.1.2.10节.</p><h4 id="3-12-1-固定报头"><a href="#3-12-1-固定报头" class="headerlink" title="3.12.1 固定报头"></a>3.12.1 固定报头</h4><h6 id="图例-3-33-–-PINGREQ报文固定报头"><a href="#图例-3-33-–-PINGREQ报文固定报头" class="headerlink" title="图例 3.33 – PINGREQ报文固定报头"></a>图例 3.33 – PINGREQ报文固定报头</h6><table><thead><tr><th align="left"><strong>Bit</strong></th><th align="left"><strong>7</strong></th><th align="left"><strong>6</strong></th><th align="left"><strong>5</strong></th><th align="left"><strong>4</strong></th><th align="left"><strong>3</strong></th><th align="left"><strong>2</strong></th><th align="left"><strong>1</strong></th><th align="left"><strong>0</strong></th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (12)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度 (0)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (12)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (0)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id="3-12-2-可变报头"><a href="#3-12-2-可变报头" class="headerlink" title="3.12.2 可变报头"></a>3.12.2 可变报头</h4><p>PINGREQ报文没有可变报头.</p><h4 id="3-12-3-有效载荷"><a href="#3-12-3-有效载荷" class="headerlink" title="3.12.3 有效载荷"></a>3.12.3 有效载荷</h4><p>PINGREQ报文没有有效载荷.</p><h4 id="3-12-4-响应"><a href="#3-12-4-响应" class="headerlink" title="3.12.4 响应"></a>3.12.4 响应</h4><p>服务端<strong>必须</strong>发送 PINGRESP报文响应客户端的PINGREQ报文 [MQTT-3.12.4-1].</p><h3 id="3-13-PINGRESP-–-心跳响应"><a href="#3-13-PINGRESP-–-心跳响应" class="headerlink" title="3.13 PINGRESP – 心跳响应"></a>3.13 PINGRESP – 心跳响应</h3><p>服务端发送PINGRESP报文响应客户端的PINGREQ报文. 表示服务端还活着.</p><p>保持连接(Keep Alive)处理中用到这个报文, 详情请查看 3.1.2.10节.</p><h4 id="3-13-1-固定报头"><a href="#3-13-1-固定报头" class="headerlink" title="3.13.1 固定报头"></a>3.13.1 固定报头</h4><h6 id="图例-3-34-–-PINGRESP报文固定报头"><a href="#图例-3-34-–-PINGRESP报文固定报头" class="headerlink" title="图例 3.34 – PINGRESP报文固定报头"></a>图例 3.34 – PINGRESP报文固定报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (13)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (0)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id="3-13-2-可变报头"><a href="#3-13-2-可变报头" class="headerlink" title="3.13.2 可变报头"></a>3.13.2 可变报头</h4><p>PINGRESP报文没有可变报头.</p><h4 id="3-13-3-有效载荷"><a href="#3-13-3-有效载荷" class="headerlink" title="3.13.3 有效载荷"></a>3.13.3 有效载荷</h4><p>PINGRESP报文没有有效载荷.</p><h3 id="3-14-DISCONNECT-–断开连接"><a href="#3-14-DISCONNECT-–断开连接" class="headerlink" title="3.14 DISCONNECT –断开连接"></a>3.14 DISCONNECT –断开连接</h3><p>DISCONNECT报文是客户端发给服务端的最后一个控制报文. 表示客户端正常断开连接.</p><h4 id="3-14-1-固定报头"><a href="#3-14-1-固定报头" class="headerlink" title="3.14.1 固定报头"></a>3.14.1 固定报头</h4><h6 id="图例-3-35-–-DISCONNECT报文固定报头"><a href="#图例-3-35-–-DISCONNECT报文固定报头" class="headerlink" title="图例 3.35 – DISCONNECT报文固定报头"></a>图例 3.35 – DISCONNECT报文固定报头</h6><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (14)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (0)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>服务端<strong>必须</strong>验证所有的保留位都被设置为0, 如果它们不为0<strong>必须</strong>断开连接 [MQTT-3.14.1-1].</p><h4 id="3-14-2-可变报头"><a href="#3-14-2-可变报头" class="headerlink" title="3.14.2 可变报头"></a>3.14.2 可变报头</h4><p>DISCONNECT报文没有可变报头.</p><h4 id="3-14-3-有效载荷"><a href="#3-14-3-有效载荷" class="headerlink" title="3.14.3 有效载荷"></a>3.14.3 有效载荷</h4><p>DISCONNECT报文没有有效载荷.</p><h4 id="3-14-4-响应"><a href="#3-14-4-响应" class="headerlink" title="3.14.4 响应"></a>3.14.4 响应</h4><p>客户端发送DISCONNECT报文之后：</p><ul><li><strong>必须</strong>关闭网络连接 [MQTT-3.14.4-1].</li><li><strong>不能</strong>通过那个网络连接再发送任何控制报文 [MQTT-3.14.4-2].</li></ul><p>服务端在收到DISCONNECT报文时：</p><ul><li><strong>必须</strong>丢弃任何与当前连接关联的未发布的遗嘱消息, 具体描述见 3.1.2.5节 [MQTT-3.14.4-3].</li><li><strong>应该</strong>关闭网络连接, 如果客户端 还没有这么做.</li></ul><h2 id="第四章-操作行为-Operational-behavior"><a href="#第四章-操作行为-Operational-behavior" class="headerlink" title="第四章 操作行为 Operational behavior"></a>第四章 操作行为 Operational behavior</h2><h3 id="4-1-状态存储-Storing-state"><a href="#4-1-状态存储-Storing-state" class="headerlink" title="4.1 状态存储 Storing state"></a>4.1 状态存储 Storing state</h3><p>为了提供服务质量保证, 客户端和服务端有必要存储会话状态. 在整个会话期间, 客户端和服务端都<strong>必须</strong>存储会话状态 [MQTT-4.1.0-1]. 会话<strong>必须</strong>至少持续和它的活跃网络连接同样长的时间 [MQTT-4.1.0-2].</p><p>服务端的保留消息不是会话状态的组成部分. 服务端<strong>应该</strong>保留那种消息直到客户端删除它.</p><blockquote><p><strong>非规范评注</strong></p><p>客户端和服务端实现的存储容量必然是有限的, 还可能要受管理策略的限制, 比如跨网络连接的会话状态的最大存储时间. 已保存的会话状态丢失可能是某个管理操作造成的, 例如对某个预定义条件的自动响应. 它造成的后果就是会话终止. 这些操作可能是资源限制或其他操作原因引发的. 需要谨慎的评估客户端和服务端的存储容量, 以确保存储空间够用.</p><p><strong>非规范评注</strong></p><p>客户端或服务端的软硬件故障都可能导致会话状态的丢失或损坏.</p><p><strong>非规范评注</strong></p><p>服务器和客户端操作正常可能意味着, 已保存的状态丢失或损坏是管理操作或软硬件故障造成的. 管理操作可能是对某个预定义条件的自动响应. 这些操作可能是资源限制或其他操作原因引发的. 例如, 服务端可能会基于外部条件, 决定不再将某个消息或某些消息分发给任何当前的或以后的客户端.</p><p><strong>非规范评注</strong></p><p>MQTT用户应该评估MQTT客户端和服务端实现的存储容量, 确保能满足需求.</p></blockquote><h5 id="非规范示例"><a href="#非规范示例" class="headerlink" title="非规范示例"></a>非规范示例</h5><p>例如, 想要收集电表读数的用户可能会决定使用QoS 1等级的消息, 因为他们不能接受数据在网络传输途中丢失, 但是, 他们可能认为客户端和服务端的数据可以存储在内存(易失性存储器)中, 因为(他们觉得)电力供应是非常可靠的, 不会有太大的数据丢失风险.</p><p>与之相反, 停车计费支付应用的提供商可能决定任何情况下都不能让数据支付消息丢失, 因此他们要求在通过网络传输之前, 所有的数据必须写入到非易失性存储器中(如硬盘).</p><h3 id="4-2-网络连接-Network-Connections"><a href="#4-2-网络连接-Network-Connections" class="headerlink" title="4.2 网络连接 Network Connections"></a>4.2 网络连接 Network Connections</h3><p>MQTT协议要求基础传输层能够提供有序的、可靠的、双向传输(从客户端到服务端 和从服务端到客户端)的字节流.</p><blockquote><p><strong>非规范评注</strong></p><p>MQTT 3.1使用的传输层协议是 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC793" target="_blank" rel="noopener">RFC793</a>] 定义的TCP/IP协议. 下面的协议也支持：</p></blockquote><ul><li>TLS协议 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a></li><li>WebSocket协议 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC6455" target="_blank" rel="noopener">[RFC6455]</a></li></ul><blockquote><p><strong>非规范评注</strong></p><p>TCP端口8883和1883已在IANA注册, 分别用于MQTT的TLS和非TLS通信.</p></blockquote><p>无连接的网络传输协议如UDP是不支持的, 因为他们可能会丢失数据包或对数据包重排序.</p><h3 id="4-3-服务质量等级和协议流程-QoS"><a href="#4-3-服务质量等级和协议流程-QoS" class="headerlink" title="4.3 服务质量等级和协议流程 QoS"></a>4.3 服务质量等级和协议流程 QoS</h3><p>MQTT按照这里定义的服务质量 (QoS) 等级分发应用消息. 分发协议是对称的, 在下面的描述中, 客户端和服务端既可以是发送者也可以是接收者. 分发协议关注的是从单个发送者到单个接收者的应用消息. 服务端分发应用消息给多个客户端时, 每个客户端独立处理. 分发给客户端的出站应用消息和入站应用消息的QoS等级可能是不同的.</p><p>下面的非规范流程图展示了可能的实现方法.</p><h4 id="4-3-1-QoS-0-最多分发一次"><a href="#4-3-1-QoS-0-最多分发一次" class="headerlink" title="4.3.1 QoS 0:最多分发一次"></a>4.3.1 QoS 0:最多分发一次</h4><p>消息的分发依赖于底层网络的能力. 接收者不会发送响应, 发送者也不会重试. 消息可能送达一次也可能根本没送达.</p><p>对于QoS 0的分发协议, 发送者</p><ul><li><strong>必须</strong>发送QoS等于0, DUP等于0的PUBLISH报文 [MQTT-4.3.1-1].</li></ul><p>对于QoS 0的分发协议, 接收者</p><ul><li>接受PUBLISH报文时同时接受消息的所有权.</li></ul><h6 id="图例-4-1-–-QoS-0协议流程图-非规范示例"><a href="#图例-4-1-–-QoS-0协议流程图-非规范示例" class="headerlink" title="图例 4.1 – QoS 0协议流程图, 非规范示例"></a>图例 4.1 – QoS 0协议流程图, 非规范示例</h6><table><thead><tr><th align="left"><strong>发送者动作</strong></th><th align="left"><strong>控制报文</strong></th><th align="left"><strong>接收者动作</strong></th></tr></thead><tbody><tr><td align="left">PUBLISH 报文 QoS 0, DUP=0</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">———-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">分发应用消息给适当的后续接收者(们)</td></tr></tbody></table><h4 id="4-3-2-QoS-1-至少分发一次"><a href="#4-3-2-QoS-1-至少分发一次" class="headerlink" title="4.3.2 QoS 1: 至少分发一次"></a>4.3.2 QoS 1: 至少分发一次</h4><p>服务质量确保消息至少送达一次. QoS 1的PUBLISH报文的可变报头中包含一个报文标识符, 需要PUBACK报文确认. 2.3.1节提供了有关报文标识符的更多信息.</p><p>对于QoS 1的分发协议, 发送者</p><ul><li>每次发送新的应用消息都<strong>必须</strong>分配一个未使用的报文标识符.</li><li>发送的PUBLISH报文<strong>必须</strong>包含报文标识符且QoS等于1, DUP等于0.</li><li><strong>必须</strong>将这个PUBLISH报文看作是 <em>未确认的</em> , 直到从接收者那收到对应的PUBACK报文. 4.4节有一个关于未确认消息的讨论.</li></ul><blockquote><p>[MQTT-4.3.2-1].</p><p>一旦发送者收到PUBACK报文, 这个报文标识符就可以重用.</p></blockquote><p>注意：允许发送者在等待确认时使用不同的报文标识符发送后续的PUBLISH报文.</p><p>对于QoS 1的分发协议, 接收者</p><ul><li>响应的PUBACK报文<strong>必须</strong>包含一个报文标识符, 这个标识符来自接收到的、已经接受所有权的PUBLISH报文.</li><li>发送了PUBACK报文之后, 接收者必须将任何包含相同报文标识符的入站PUBLISH报文当作一个新的消息, 并忽略它的DUP标志的值.</li></ul><blockquote><p>[MQTT-4.3.2-2].</p></blockquote><h6 id="图例-4-2-–-QoS-1协议流程图-非规范示例"><a href="#图例-4-2-–-QoS-1协议流程图-非规范示例" class="headerlink" title="图例 4.2 – QoS 1协议流程图, 非规范示例"></a>图例 4.2 – QoS 1协议流程图, 非规范示例</h6><table><thead><tr><th align="left"><strong>发送者动作</strong></th><th align="left"><strong>控制报文</strong></th><th align="left"><strong>接收者动作</strong></th></tr></thead><tbody><tr><td align="left">存储消息</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">发送PUBLISH报文 QoS=1, DUP=0, 带报文标识符</td><td align="left">———-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">开始应用消息的后续分发1</td></tr><tr><td align="left"></td><td align="left">&lt;———-</td><td align="left">发送PUBACK报文, 带报文标识符</td></tr><tr><td align="left">丢弃消息</td><td align="left"></td><td align="left"></td></tr></tbody></table><blockquote><p>1不要求接收者在发送PUBACK之前完整分发应用消息. 原来的发送者收到PUBACK报文之后, 应用消息的所有权就会转移给这个接收者.</p></blockquote><h4 id="4-3-3-QoS-2-仅分发一次"><a href="#4-3-3-QoS-2-仅分发一次" class="headerlink" title="4.3.3 QoS 2: 仅分发一次"></a>4.3.3 QoS 2: 仅分发一次</h4><p>这是最高等级的服务质量, 消息丢失和重复都是不可接受的. 使用这个服务质量等级会有额外的开销.</p><p>QoS 2的消息可变报头中有报文标识符. 2.3.1节提供了有关报文标识符的更多信息. QoS 2的PUBLISH报文的接收者使用一个两步确认过程来确认收到.</p><p>对于QoS 2的分发协议, 发送者</p><ul><li>必须给要发送的新应用消息分配一个未使用的报文标识符.</li><li>发送的PUBLISH报文<strong>必须</strong>包含报文标识符且报文的QoS等于2,, DUP等于0.</li><li><strong>必须</strong>将这个PUBLISH报文看作是 <em>未确认的</em> , 直到从接收者那收到对应的PUBREC报文. 4.4节有一个关于未确认消息的讨论.</li><li>收到PUBREC报文后<strong>必须</strong>发送一个PUBREL报文. PUBREL报文必须包含与原始PUBLISH报文相同的报文标识符.</li><li><strong>必须</strong>将这个PUBREL报文看作是 <em>未确认的</em> , 直到从接收者那收到对应的PUBCOMP报文.</li><li>一旦发送了对应的PUBREL报文就<strong>不能</strong>重发这个PUBLISH报文.</li></ul><p>[MQTT-4.3.3-1].</p><blockquote><p>一旦发送者收到PUBCOMP报文, 这个报文标识符就可以重用.</p></blockquote><p>注意：允许发送者在等待确认时使用不同的报文标识符发送后续的PUBLISH报文.</p><p>对于QoS 2的分发协议, 接收者</p><ul><li>响应的PUBREC报文<strong>必须</strong>包含报文标识符, 这个标识符来自接收到的、已经接受所有权的PUBLISH报文.</li><li>在收到对应的PUBREL报文之前, 接收者<strong>必须</strong>发送PUBREC报文确认任何后续的具有相同标识符的PUBLISH报文. 在这种情况下, 它<strong>不能</strong>重复分发消息给任何后续的接收者.</li><li>响应PUBREL报文的PUBCOMP报文<strong>必须</strong>包含与PUBREL报文相同的标识符.</li><li>发送PUBCOMP报文之后, 接收者必须将包含相同报文标识符的任何后续PUBLISH报文当作一个新的发布.</li></ul><p>[MQTT-4.3.3-2].</p><h6 id="图例-4-3-–-QoS-2协议流程图-非规范示例"><a href="#图例-4-3-–-QoS-2协议流程图-非规范示例" class="headerlink" title="图例 4.3 – QoS 2协议流程图, 非规范示例"></a>图例 4.3 – QoS 2协议流程图, 非规范示例</h6><table><thead><tr><th align="left"><strong>发送者动作</strong></th><th align="left"><strong>控制报文</strong></th><th align="left"><strong>接收者动作</strong></th></tr></thead><tbody><tr><td align="left">存储消息</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">发送PUBLISH报文, QoS=2, DUP=0, 带报文标识符</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">———-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">方法A：存储消息, 或方法B：存储报文标识符, 然后开始向前分发这个应用消息1.</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">发送PUBREC报文, 带报文标识符.</td></tr><tr><td align="left"></td><td align="left">&lt;———-</td><td align="left"></td></tr><tr><td align="left">丢弃消息, 存储PUBREC中的报文标识符</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">发送PUBREL报文, 带报文标识符</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">———-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">方法A：开始向前分发应用消息1然后丢弃消息 或方法B：丢弃报文标识符</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">发送PUBCOMP报文, 带报文标识符</td></tr><tr><td align="left"></td><td align="left">&lt;———-</td><td align="left"></td></tr><tr><td align="left">丢弃已保存的状态</td><td align="left"></td><td align="left"></td></tr></tbody></table><blockquote><p>1 不要求接收者在发送PUBREC或PUBCOMP之前完整分发应用消息. 原来的发送者收到PUBREC报文之后, 应用消息的所有权就会转移给这个接收者.</p><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#_Figure_4.3_–" target="_blank" rel="noopener">图例 4.3 – QoS 2协议流程图, 非规范示例</a> 展示了接收者对QoS 2等级消息的两种处理方法. 他们的区别是消息什么时候可以开始分发. 实现者可以决定使用哪种方法. 只要实现者只选择了一种方法, 就不会影响QoS流程的可靠性.</p></blockquote><h3 id="4-4-消息分发重试-Message-delivery-retry"><a href="#4-4-消息分发重试-Message-delivery-retry" class="headerlink" title="4.4 消息分发重试 Message delivery retry"></a>4.4 消息分发重试 Message delivery retry</h3><p>客户端设置清理会话(CleanSession)标志为0重连时, 客户端和服务端<strong>必须</strong>使用原始的报文标识符重发任何未确认的PUBLISH报文(如果QoS&gt;0)和PUBREL报文 [MQTT-4.4.0-1]. 这是唯一<strong>要求</strong>客户端或服务端重发消息的情况.</p><blockquote><p><strong>非规范评注</strong></p><p>控制报文的重发曾经需要克服某些陈旧TCP网络上的数据丢失问题. 部署在那些环境中的MQTT 3.1.1实现可能仍然需要关注这个问题.</p></blockquote><h3 id="4-5-消息收到-Message-receipt"><a href="#4-5-消息收到-Message-receipt" class="headerlink" title="4.5 消息收到 Message receipt"></a>4.5 消息收到 Message receipt</h3><p>服务端接管入站应用消息的所有权时, 它<strong>必须</strong>将消息添加到订阅匹配的客户端的会话状态中. 匹配规则定义见 4.7节 [MQTT-4.5.0-1].</p><p>正常情况下, 客户端收到发送给它的订阅的消息. 客户端也可能收到不是与它的订阅精确匹配的消息. 如果服务端自动给客户端分配了一个订阅, 可能发生这种情况. 正在处理UBSUBSCRIBE请求时也可能收到消息. 客户端<strong>必须</strong>按照可用的服务质量(QoS)规则确认它收到的任何PUBLISH报文, 不管它选择是否处理报文包含的应用消息 [MQTT-4.5.0-2].</p><h3 id="4-6-消息排序-Message-ordering"><a href="#4-6-消息排序-Message-ordering" class="headerlink" title="4.6 消息排序 Message ordering"></a>4.6 消息排序 Message ordering</h3><p>实现本章定义的协议流程时, 客户端<strong>必须</strong>遵循下列规则：</p><ul><li>重发任何之前的PUBLISH报文时, <strong>必须</strong>按原始PUBLISH报文的发送顺序重发(适用于QoS 1和QoS 2消息)[MQTT-4.6.0-1].</li><li><strong>必须</strong>按照对应的PUBLISH报文的顺序发送PUBACK报文(QoS 1消息)[MQTT-4.6.0-2].</li><li><strong>必须</strong>按照对应的PUBLISH报文的顺序发送PUBREC报文(QoS 2消息)[MQTT-4.6.0-3].</li><li><strong>必须</strong>按照对应的PUBREC报文的顺序发送PUBREL报文(QoS 2消息)[MQTT-4.6.0-4].</li></ul><p>服务端<strong>必须</strong>默认认为每个主题都是有序的. 它<strong>可以</strong>提供一个管理功能或其它机制, 以允许将一个或多个主题当作是无序的 [MQTT-4.6.0-5].</p><p>服务端处理发送给有序主题的消息时, <strong>必须</strong>按照上面的规则将消息分发给每个订阅者. 此外, 它<strong>必须</strong>按照从客户端收到的顺序发送PUBLISH报文给消费者(对相同的主题和QoS)[MQTT-4.6.0-6].</p><blockquote><p><strong>非规范评注</strong></p><p>上面列出的规则确保, 使用QoS 1发布和订阅的消息流, 订阅者按照消息发布时的顺序收到每条消息的最终副本, 但是消息可能会重复, 这可能导致在它的后继消息之后收到某个已经收到消息的重发版本. 例如, 发布者按顺序1,2,3,4发送消息, 订阅者收到的顺序可能是1,2,3,2,3,4.</p><p>如果客户端和服务端能保证任何时刻最多有一条消息在 <em>传输中(in-flight)</em>(在某条消息被确认前不发送后面的那条消息), 那么, 不会有QoS 1的消息会在它的任何后续消息之后收到. 例如, 订阅者收到的顺序可能是1,2,3,3,4, 而不是1,2,3,2,3,4. 将传输窗口 (in-flight window)设为1意味着, 在同一个主题上, 即使发布者发送了一系列不同QoS等级的消息, 它们的顺序也被保留.</p></blockquote><h3 id="4-7-主题名和主题过滤器-Topic-Names-and-Topic-Filters"><a href="#4-7-主题名和主题过滤器-Topic-Names-and-Topic-Filters" class="headerlink" title="4.7 主题名和主题过滤器 Topic Names and Topic Filters"></a>4.7 主题名和主题过滤器 Topic Names and Topic Filters</h3><h4 id="4-7-1-主题通配符-Topic-wildcards"><a href="#4-7-1-主题通配符-Topic-wildcards" class="headerlink" title="4.7.1 主题通配符 Topic wildcards"></a>4.7.1 主题通配符 Topic wildcards</h4><p>主题层级(topic level)分隔符用于将结构化引入主题名. 如果存在分隔符, 它将主题名分割为多个<em>主题层级 topic level</em> .</p><p>订阅的主题过滤器可以包含特殊的通配符, 允许你一次订阅多个主题.</p><p>主题过滤器中可以使用通配符, 但是主题名<strong>不能</strong>使用通配符 [MQTT-4.7.1-1].</p><h5 id="主题层级分隔符-Topic-level-separator"><a href="#主题层级分隔符-Topic-level-separator" class="headerlink" title="主题层级分隔符 Topic level separator"></a>主题层级分隔符 Topic level separator</h5><p>斜杠(‘/’ U+002F)用于分割主题的每个层级, 为主题名提供一个分层结构. 当客户端订阅指定的主题过滤器包含两种通配符时, 主题层级分隔符就很有用了. 主题层级分隔符可以出现在主题过滤器或主题名字的任何位置. 相邻的主题层次分隔符表示一个零长度的主题层级.</p><h5 id="多层通配符-Multi-level-wildcard"><a href="#多层通配符-Multi-level-wildcard" class="headerlink" title="多层通配符 Multi-level wildcard"></a>多层通配符 Multi-level wildcard</h5><p>数字标志(‘#’ U+0023)是用于匹配主题中任意层级的通配符. 多层通配符表示它的父级和任意数量的子层级. 多层通配符必须位于它自己的层级或者跟在主题层级分隔符后面. 不管哪种情况, 它都<strong>必须</strong>是主题过滤器的最后一个字符 [MQTT-4.7.1-2].</p><blockquote><p><strong>非规范评注</strong></p><p>例如, 如果客户端订阅主题 “sport/tennis/player1/#”, 它会收到使用下列主题名发布的消息：</p></blockquote><ul><li>“sport/tennis/player1”</li><li>“sport/tennis/player1/ranking”</li><li>“sport/tennis/player1/score/wimbledon”</li></ul><blockquote><p><strong>非规范评注</strong></p></blockquote><ul><li>“sport/#”也匹配单独的 “sport” , 因为 # 包括它的父级.</li><li>“#”是有效的, 会收到所有的应用消息.</li><li>“sport/tennis/#”也是有效的.</li><li>“sport/tennis#”是无效的.</li><li>“sport/tennis/#/ranking”是无效的.</li></ul><h5 id="单层通配符"><a href="#单层通配符" class="headerlink" title="单层通配符"></a>单层通配符</h5><p>加号 (‘+’ U+002B) 是只能用于单个主题层级匹配的通配符.</p><p>在主题过滤器的任意层级都可以使用单层通配符, 包括第一个和最后一个层级. 然而它<strong>必须</strong>占据过滤器的整个层级 [MQTT-4.7.1-3]. 可以在主题过滤器中的多个层级中使用它, 也可以和多层通配符一起使用.</p><blockquote><p><strong>非规范评注</strong></p><p>例如, “sport/tennis/+” 匹配 “sport/tennis/player1” 和 “sport/tennis/player2” , 但是不匹配 “sport/tennis/player1/ranking” . 同时, 由于单层通配符只能匹配一个层级, “sport/+” 不匹配 “sport” 但是却匹配 “sport/”.</p><p><strong>非规范评注</strong></p></blockquote><ul><li>“+” 是有效的.</li><li>“+/tennis/#” 是有效的.</li><li>“sport+” 是无效的.</li><li>“sport/+/player1” 也是有效的.</li><li>“/finance” 匹配 “+/+” 和 “/+” , 但是不匹配 “+”.</li></ul><h4 id="4-7-2-以-开头的主题-Topics-beginning-with"><a href="#4-7-2-以-开头的主题-Topics-beginning-with" class="headerlink" title="4.7.2 以$开头的主题 Topics beginning with $"></a>4.7.2 以$开头的主题 Topics beginning with $</h4><p>服务端<strong>不能</strong>将 字符开头的主题名匹配通配符或开头的主题过滤器服务端应该阻止客户端使用这种主题名与其它客户端交换消息服务端实现可以将 开头的主题名用作其他目的.</p><blockquote><p><strong>非规范评注</strong></p></blockquote><ul><li>被广泛用作包含服务器特定信息或控制接口的主题的前缀应用不能使用 字符开头的主题.</li></ul><blockquote><p><strong>非规范评注</strong></p></blockquote><ul><li>订阅 “#” 的客户端不会收到任何发布到以 “开头主题的消息订阅的客户端不会收到任何发布到SYS/monitor/Clients” 的消息.</li><li>订阅 “的客户端会收到发布到以SYS/” 开头主题的消息.</li><li>订阅 “的客户端会收到发布到SYS/monitor/Clients” 主题的消息.</li><li>如果客户端想同时接受以 “开头主题的消息和不以 开头主题的消息, 它需要同时订阅 “#” 和 ““$SYS/#”.</li></ul><h4 id="4-7-3-主题语义和用法-Topic-semantic-and-usage"><a href="#4-7-3-主题语义和用法-Topic-semantic-and-usage" class="headerlink" title="4.7.3 主题语义和用法 Topic semantic and usage"></a>4.7.3 主题语义和用法 Topic semantic and usage</h4><p>主题名和主题过滤器必须符合下列规则：</p><ul><li>所有的主题名和主题过滤器<strong>必须</strong>至少包含一个字符 [MQTT-4.7.3-1].</li><li>主题名和主题过滤器是区分大小写的.</li><li>主题名和主题过滤器可以包含空格.</li><li>主题名或主题过滤器以前置或后置斜杠 “/” 区分.</li><li>只包含斜杠 “/” 的主题名或主题过滤器是合法的.</li><li>主题名和主题过滤器<strong>不能</strong>包含空字符 (Unicode U+0000) <a href="https://www.zybuluo.com/khan-lau/note/1326839#Unicode" target="_blank" rel="noopener">Unicode</a>] [MQTT-4.7.3-2].</li><li>主题名和主题过滤器是UTF-8编码字符串, 它们<strong>不能</strong>超过65535字节 [MQTT-4.7.3-3]. 见 <a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>.</li></ul><p>除了不能超过UTF-编码字符串的长度限制之外, 主题名或主题过滤器的层级数量没有其它限制.</p><p>匹配订阅时, 服务端<strong>不能</strong>对主题名或主题过滤器执行任何规范化(normalization)处理, 不能修改或替换任何未识别的字符 [MQTT-4.7.3-4]. 主题过滤器中的每个非通配符层级需要逐字符匹配主题名中对应的层级才算匹配成功.</p><blockquote><p><strong>非规范评注</strong></p><p>使用UTF-8编码规则意味着, 主题过滤器和主题名的比较可以通过比较编码后的UTF-8字节或解码后的Unicode字符.</p><p><strong>非规范评注</strong></p></blockquote><ul><li>“ACCOUNTS” 和 “Accounts” 是不同的主题名.</li><li>“Accounts payable” 是合法的主题名</li><li>“/finance” 和 “finance” 是不同的.</li></ul><p>如果订阅的主题过滤器与消息的主题名匹配, 应用消息会被发送给每一个匹配的客户端订阅. 主题可能是管理员在服务端预先定义好的, 也可能是服务端收到第一个订阅或使用那个主题名的应用消息时动态添加的. 服务端也可以使用一个安全组件有选择地授权客户端使用某个主题资源.</p><h3 id="4-8-错误处理-Handling-errors"><a href="#4-8-错误处理-Handling-errors" class="headerlink" title="4.8 错误处理 Handling errors"></a>4.8 错误处理 Handling errors</h3><p>除非另有说明, 如果服务端或客户端遇到了协议违规的行为, 它<strong>必须</strong>关闭传输这个协议违规控制报文的网络连接 [MQTT-4.8.0-1].</p><p>客户端或服务端实现可能会遇到瞬时错误(Transient Error)(例如内部缓冲区满了的情况)导致无法成功处理MQTT报文.</p><p>如果客户端或服务端处理入站控制报文时遇到了瞬时错误, 它<strong>必须</strong>关闭传输那个控制报文的网络连接 [MQTT-4.8.0-2]. 如果服务端发现了瞬时错误, 它<strong>不应该</strong>断开连接或者执行任何对其它客户端有影响的操作.</p><h2 id="第五章-安全"><a href="#第五章-安全" class="headerlink" title="第五章 安全"></a>第五章 安全</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>本章的内容仅供参考, 是非规范化的. 然而, 强烈推荐提供TLS的服务端实现<strong>应该</strong>使用TCP端口8883(IANA服务名：secure-mqtt).</p><p>解决方案提供者需要考虑很多风险. 例如：</p><ul><li>设备可能会被盗用</li><li>客户端和服务端的静态数据可能是可访问的(可能会被修改)</li><li>协议行为可能有副作用(如计时器攻击)</li><li>拒绝服务攻击</li><li>通信可能会被拦截、修改、重定向或者泄露</li><li>虚假控制报文注入</li></ul><p>MQTT方案通常部署在不安全的通信环境中. 在这种情况下, 协议实现通常需要提供这些机制：</p><ul><li>用户和设备身份认证</li><li>服务端资源访问授权</li><li>MQTT控制报文和内嵌应用数据的完整性校验</li><li>MQTT控制报文和内嵌应用数据的隐私控制</li></ul><p>作为传输层协议, MQTT仅关注消息传输, 提供合适的安全功能是实现者的责任. 使用TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 是比较普遍的选择. 除了技术上的安全问题外, 还有地理因素(例如美国欧盟安全港原则 <a href="https://www.zybuluo.com/khan-lau/note/1326839#USEUSAFEHARB" target="_blank" rel="noopener">[USEUSAFEHARB]</a>), 行业标准(例如第三方支付行业数据安全标准 <a href="https://www.zybuluo.com/khan-lau/note/1326839#PCIDSS" target="_blank" rel="noopener">[PCIDSS]</a>), 监管方面的考虑(例如萨班斯-奥克斯利法案 <a href="https://www.zybuluo.com/khan-lau/note/1326839#SARBANES" target="_blank" rel="noopener">[SARBANES]</a>)等问题.</p><h3 id="5-2-MQTT解决方案：安全和认证"><a href="#5-2-MQTT解决方案：安全和认证" class="headerlink" title="5.2 MQTT解决方案：安全和认证"></a>5.2 MQTT解决方案：安全和认证</h3><p>MQTT solutions: security and certification</p><p>协议实现可能想要符合特定的工业安全标准, 如NIST网络安全框架 [NISTCSF]](#NISTCSF) , 第三方支付行业数据安全标准 <a href="https://www.zybuluo.com/khan-lau/note/1326839#PCIDSS" target="_blank" rel="noopener">[PCIDSS]</a> , 美国联邦信息处理标准 <a href="https://www.zybuluo.com/khan-lau/note/1326839#FIPS1402" target="_blank" rel="noopener">[FIPS1402]</a> 和 NSA 加密组合B <a href="https://www.zybuluo.com/khan-lau/note/1326839#NSAB" target="_blank" rel="noopener">NSAB</a>] .</p><p>在MQTT的补充出版物 (MQTT and the NIST Framework for Improving Critical Infrastructure Cybersecurity <a href="https://www.zybuluo.com/khan-lau/note/1326839#NISTCSF" target="_blank" rel="noopener">[MQTT NIST]</a>) 中可以找到在NIST网络安全框架 [NISTCSF]](#NISTCSF) 中使用MQTT的指导. 使用行业证明、独立审计和认证技术有助于满足合规要求.</p><h3 id="5-3-轻量级的加密与受限设备"><a href="#5-3-轻量级的加密与受限设备" class="headerlink" title="5.3 轻量级的加密与受限设备"></a>5.3 轻量级的加密与受限设备</h3><p>Lightweight cryptography and constrained devices</p><p>广泛采用高级加密标准 <a href="https://www.zybuluo.com/khan-lau/note/1326839#AES" target="_blank" rel="noopener">[AES]</a> 数据加密标准 <a href="https://www.zybuluo.com/khan-lau/note/1326839#DES" target="_blank" rel="noopener">[DES]</a> .</p><p>推荐使用为受限的低端设备特别优化过的轻量级加密国际标准 ISO 29192 <a href="https://www.zybuluo.com/khan-lau/note/1326839#ISO29192" target="_blank" rel="noopener">[ISO29192]</a> .</p><h3 id="5-4-实现注意事项-Implementation-notes"><a href="#5-4-实现注意事项-Implementation-notes" class="headerlink" title="5.4 实现注意事项 Implementation notes"></a>5.4 实现注意事项 Implementation notes</h3><p>实现和使用MQTT时需要考虑许多安全问题. 下面的部分不应该被当作是一个 核对清单 .</p><p>协议实现可以实现下面的一部分或全部：</p><h4 id="5-4-1-客户端身份验证-Authentication-of-Clients-by-the-Server"><a href="#5-4-1-客户端身份验证-Authentication-of-Clients-by-the-Server" class="headerlink" title="5.4.1 客户端身份验证 Authentication of Clients by the Server"></a>5.4.1 客户端身份验证 Authentication of Clients by the Server</h4><p>CONNECT报文包含用户名和密码字段. 实现可以决定如何使用这些字段的内容. 实现者可以提供自己的身份验证机制, 或者使用外部的认证系统如LDAP <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC4511" target="_blank" rel="noopener">[RFC4511]</a> 或OAuth <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC6749" target="_blank" rel="noopener">[RFC6749]</a> , 还可以利用操作系统的认证机制.</p><p>实现可以明文传递认证数据, 混淆那些数据, 或者不要求任何认证数据, 但应该意识到这会增加中间人攻击和重放攻击的风险. 5.4.5节介绍了确保数据私密的方法.</p><p>在客户端和服务端之间使用虚拟专用网(VPN)可以确保数据只被授权的客户端收到.</p><p>使用TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 时, 服务端可以使用客户端发送的SSL证书验证客户端的身份.</p><p>实现可以允许客户端通过应用消息给服务端发送凭证用于身份验证.</p><h3 id="5-4-2-客户端授权-Authorization-of-Clients-by-the-Server"><a href="#5-4-2-客户端授权-Authorization-of-Clients-by-the-Server" class="headerlink" title="5.4.2 客户端授权 Authorization of Clients by the Server"></a>5.4.2 客户端授权 Authorization of Clients by the Server</h3><p>基于客户端提供的信息如用户名、客户端标识符(ClientId)、客户端的主机名或IP地址, 或者身份认证的结果, 服务端可以限制对某些服务端资源的访问.</p><h4 id="5-4-3-服务端身份验证-Authentication-of-the-Server-by-the-Client"><a href="#5-4-3-服务端身份验证-Authentication-of-the-Server-by-the-Client" class="headerlink" title="5.4.3 服务端身份验证 Authentication of the Server by the Client"></a>5.4.3 服务端身份验证 Authentication of the Server by the Client</h4><p>MQTT协议不是双向信任的, 它没有提供客户端验证服务端身份的机制.</p><p>但是使用TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 时, 客户端可以使用服务端发送的SSL证书验证服务端的身份. 从单IP多域名提供MQTT服务的实现应该考虑RFC6066 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC6066" target="_blank" rel="noopener">[RFC6066]</a> 第3节定义的TLS的SNI扩展. SNI允许客户端告诉服务端它要连接的服务端主机名.</p><p>实现可以允许服务端通过应用消息给客户端发送凭证用于身份验证.</p><p>在客户端和服务端之间使用虚拟专用网(VPN)可以确保客户端连接的是预期的服务器.</p><h4 id="5-4-4-控制报文和应用消息的完整性-Integrity-of-Application-Messages-and-Control-Packets"><a href="#5-4-4-控制报文和应用消息的完整性-Integrity-of-Application-Messages-and-Control-Packets" class="headerlink" title="5.4.4 控制报文和应用消息的完整性 Integrity of Application Messages and Control Packets"></a>5.4.4 控制报文和应用消息的完整性 Integrity of Application Messages and Control Packets</h4><p>应用可以在应用消息中单独包含哈希值. 这样做可以为PUBLISH控制报文的网络传输和静态数据提供内容的完整性检查.</p><p>TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 提供了对网络传输的数据做完整性校验的哈希算法.</p><p>在客户端和服务端之间使用虚拟专用网(VPN)连接可以在VPN覆盖的网络段提供数据完整性检查.</p><h4 id="5-4-5-控制报文和应用消息的保密性-Privacy-of-Application-Messages-and-Control-Packets"><a href="#5-4-5-控制报文和应用消息的保密性-Privacy-of-Application-Messages-and-Control-Packets" class="headerlink" title="5.4.5 控制报文和应用消息的保密性 Privacy of Application Messages and Control Packets"></a>5.4.5 控制报文和应用消息的保密性 Privacy of Application Messages and Control Packets</h4><p>TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 可以对网络传输的数据加密. 如果有效的TLS密码组合包含的加密算法为NULL, 那么它不会加密数据. 要确保客户端和服务端的保密, 应避免使用这些密码组合.</p><p>应用可以单独加密应用消息的内容. 这可以提供应用消息传输途中和静态数据的私密性. 但不能给应用消息的其它属性如主题名加密.</p><p>客户端和服务端实现可以加密存储静态数据, 例如可以将应用消息作为会话的一部分存储.</p><p>在客户端和服务端之间使用虚拟专用网(VPN)连接可以在VPN覆盖的网络段保证数据的私密性.</p><h4 id="5-4-6-消息传输的不可抵赖性-Non-repudiation-of-message-transmission"><a href="#5-4-6-消息传输的不可抵赖性-Non-repudiation-of-message-transmission" class="headerlink" title=".5.4.6 消息传输的不可抵赖性 Non-repudiation of message transmission"></a>.5.4.6 消息传输的不可抵赖性 Non-repudiation of message transmission</h4><p>应用设计者可能需要考虑适当的策略, 以实现端到端的不可抵赖性(non-repudiation).</p><h4 id="5-4-7-检测客户端和服务端的盗用-Detecting-compromise-of-Clients-and-Servers"><a href="#5-4-7-检测客户端和服务端的盗用-Detecting-compromise-of-Clients-and-Servers" class="headerlink" title="5.4.7 检测客户端和服务端的盗用 Detecting compromise of Clients and Servers"></a>5.4.7 检测客户端和服务端的盗用 Detecting compromise of Clients and Servers</h4><p>使用TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 的客户端和服务端实现应该能够确保, 初始化TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 连接时提供的SSL证书是与主机名(客户端要连接的或服务端将被连接的)关联的.</p><p>使用TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 的客户端和服务端实现, 可以选择提供检查证书吊销列表 (CRLs <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5280" target="_blank" rel="noopener">[RFC5280]</a>) 和在线证书状态协议 (OSCP) <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC6960" target="_blank" rel="noopener">[RFC6960]</a> 的功能, 拒绝使用被吊销的证书.</p><p>物理部署可以将防篡改硬件与应用消息的特殊数据传输结合. 例如, 一个仪表可能会内置一个GPS以确保没有在未授权的地区使用. IEEE安全设备认证 <a href="https://www.zybuluo.com/khan-lau/note/1326839#IEEE8021AR" target="_blank" rel="noopener">[IEEE 802.1AR]</a> 就是用于实现这个机制的一个标准, 它使用加密绑定标识符验证设备身份.</p><h4 id="5-4-8-检测异常行为-Detecting-abnormal-behaviors"><a href="#5-4-8-检测异常行为-Detecting-abnormal-behaviors" class="headerlink" title="5.4.8 检测异常行为 Detecting abnormal behaviors"></a>5.4.8 检测异常行为 Detecting abnormal behaviors</h4><p>服务端实现可以监视客户端的行为, 检测潜在的安全风险. 例如：</p><ul><li>重复的连接请求</li><li>重复的身份验证请求</li><li>连接的异常终止</li><li>主题扫描(请求发送或订阅大量主题)</li><li>发送无法送达的消息(没有订阅者的主题)</li><li>客户端连接但是不发送数据</li></ul><p>发现违反安全规则的行为, 服务端实现可以断开客户端连接.</p><p>服务端实现检测不受欢迎的行为, 可以基于IP地址或客户端标识符实现一个动态黑名单列表.</p><p>服务部署可以使用网络层次控制(如果可用)实现基于IP地址或其它信息的速率限制或黑名单.</p><h4 id="5-4-9-其它的安全注意事项-Other-security-considerations"><a href="#5-4-9-其它的安全注意事项-Other-security-considerations" class="headerlink" title="5.4.9 其它的安全注意事项 Other security considerations"></a>5.4.9 其它的安全注意事项 Other security considerations</h4><p>如果客户端或服务端的SSL证书丢失, 或者我们考虑证书被盗用或者被吊销(利用 CRLs <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5280" target="_blank" rel="noopener">[RFC5280]</a> 和 OSCP <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC6960" target="_blank" rel="noopener">[RFC6960]</a>)的情况.</p><p>客户端或服务端验证凭证时, 如果发现用户名和密码丢失或被盗用, 应该吊销或者重新发放.</p><p>在使用长连接时：</p><ul><li>客户端和服务端使用TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 时应该允许重新协商会话以确认新的加密参数(替换会话密钥, 更换密码组合, 更换认证凭证).</li><li>服务端可以断开客户端连接, 并要求他们使用新的凭证重新验证身份.</li></ul><p>受限网络上的受限设备和客户端可以使用TLS会话恢复 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5077" target="_blank" rel="noopener">[RFC5077]</a> 降低TLS会话重连 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 的成本.</p><p>连接到服务端的客户端与其它连接到服务端的客户端 之间有一个信任传递关系, 它们都有权在同一个主题上发布消息.</p><h4 id="5-4-10-使用SOCKS代理-Use-of-SOCKS"><a href="#5-4-10-使用SOCKS代理-Use-of-SOCKS" class="headerlink" title="5.4.10 使用SOCKS代理 Use of SOCKS"></a>5.4.10 使用SOCKS代理 Use of SOCKS</h4><p>客户端实现应该意识到某些环境要求使用SOCKSv5 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC1928" target="_blank" rel="noopener">[RFC1928]</a> 代理创建出站的网络连接. 某些MQTT实现可以利用安全隧道(如SSH)通过SOCKS代理. 一个实现决定支持SOCKS时, 它们应该同时支持匿名的和用户名密码验证的SOCKS代理. 对于后一种情况, 实现应该意识到SOCKS可能使用明文认证, 因此应该避免使用相同的凭证连接MQTT服务器.</p><h4 id="5-4-11-安全配置文件-Security-profiles"><a href="#5-4-11-安全配置文件-Security-profiles" class="headerlink" title="5.4.11 安全配置文件 Security profiles"></a>5.4.11 安全配置文件 Security profiles</h4><p>实现者和方案设计者可能希望将安全当作配置文件集合应用到MQTT协议中. 下面描述的是一个分层的安全等级结构.</p><h5 id="开放通信配置"><a href="#开放通信配置" class="headerlink" title="开放通信配置"></a>开放通信配置</h5><p>使用开放通信配置时, MQTT协议运行在一个没有内置额外安全通信机制的开放网络上.</p><h5 id="安全网络通信配置"><a href="#安全网络通信配置" class="headerlink" title="安全网络通信配置"></a>安全网络通信配置</h5><p>使用安全网络通信配置时, MQTT协议运行在有安全控制的物理或虚拟网络上, 如VPN或物理安全网络.</p><h5 id="安全传输配置"><a href="#安全传输配置" class="headerlink" title="安全传输配置"></a>安全传输配置</h5><p>使用安全传输配置时, MQTT协议运行在使用TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 的物理或虚拟网络上, 它提供了身份认证, 完整性和保密性.</p><p>使用内置的用户名和密码字段, TLS <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC5246" target="_blank" rel="noopener">[RFC5246]</a> 客户端身份认证可被用于(或者代替)MQTT客户端认证.</p><h5 id="工业标准的安全配置"><a href="#工业标准的安全配置" class="headerlink" title="工业标准的安全配置"></a>工业标准的安全配置</h5><p>可以预料的是, MQTT被设计为支持很多工业标准的应用配置, 每一种定义一个威胁模型和用于定位威胁的特殊安全机制. 特殊的安全机制推荐从下面的方案中选择：</p><p><a href="https://www.zybuluo.com/khan-lau/note/1326839#NISTCSF" target="_blank" rel="noopener">[NISTCSF]</a> NIST网络安全框架**<br><strong>[NIST7628] NISTIR 7628智能电网网络安全指南</strong><br><strong>[FIPS1402] (FIPS PUB 140-2) 加密模块的安全要求</strong><br><strong>[PCIDSS] PCI-DSS第三方支付行业数据安全标准</strong><br>**<a href="https://www.zybuluo.com/khan-lau/note/1326839#NSAB" target="_blank" rel="noopener">[NSAB]</a> NSA加密组合B</p><h2 id="第六章-使用WebSocket作为网络层"><a href="#第六章-使用WebSocket作为网络层" class="headerlink" title="第六章 使用WebSocket作为网络层"></a>第六章 使用WebSocket作为网络层</h2><p>如果MQTT在WebSocket <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC6455" target="_blank" rel="noopener">[RFC6455]</a> 连接上传输, <strong>必须</strong>满足下面的条件：</p><ul><li>MQTT控制报文<strong>必须</strong>使用WebSocket二进制数据帧发送. 如果收到任何其它类型的数据帧, 接收者<strong>必须</strong>关闭网络连接 [MQTT-6.0.0-1].</li><li>单个WebSocket数据帧可以包含多个或者部分MQTT报文. 接收者<strong>不能</strong>假设MQTT控制报文按WebSocket帧边界对齐 [MQTT-6.0.0-2].</li><li>客户端<strong>必须</strong>将字符串 <strong>mqtt</strong> 包含在它提供的WebSocket子协议列表里 [MQTT-6.0.0-3].</li><li>服务端选择和返回的WebSocket子协议名<strong>必须</strong>是 <strong>mqtt</strong> [MQTT-6.0.0-4] .</li><li>用于连接客户端和服务器的WebSocket URI对MQTT协议没有任何影响.</li></ul><h3 id="6-1-IANA注意事项-IANA-Considerations"><a href="#6-1-IANA注意事项-IANA-Considerations" class="headerlink" title="6.1 IANA注意事项 IANA Considerations"></a>6.1 IANA注意事项 IANA Considerations</h3><blockquote><p>本规范请求IANA在WebSocket子协议名条目下注册WebSocket MQTT子协议, 使用下列数据：</p></blockquote><h6 id="图例-6-1-IANA-WebSocket标识符"><a href="#图例-6-1-IANA-WebSocket标识符" class="headerlink" title="图例 6.1 - IANA WebSocket标识符"></a>图例 6.1 - IANA WebSocket标识符</h6><table><thead><tr><th align="left">子协议标识符</th><th align="left">mqtt</th></tr></thead><tbody><tr><td align="left">子协议通用名</td><td align="left">mqtt</td></tr><tr><td align="left">子协议定义</td><td align="left"><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html</a></td></tr></tbody></table><h2 id="第七章-一致性-Conformance"><a href="#第七章-一致性-Conformance" class="headerlink" title="第七章 一致性 Conformance"></a>第七章 一致性 Conformance</h2><p>MQTT规范定义了MQTT客户端实现和MQTT服务端实现的一致性要求</p><p>MQTT实现可以同时是MQTT客户端和MQTT服务端. 接受入站连接和建立到其它服务端的出站连接的服务端必须同时符合MQTT客户端和MQTT服务端的要求 [MQTT-7.0.0-1].</p><p>为了与任何其它的一致性实现交互操作, 一致性实现不能要求使用在本规范之外定义的任何扩展 [MQTT-7.0.0-2].</p><h3 id="7-1-一致性目标-Conformance-Targets"><a href="#7-1-一致性目标-Conformance-Targets" class="headerlink" title="7.1 一致性目标 Conformance Targets"></a>7.1 一致性目标 Conformance Targets</h3><h4 id="7-1-1-MQTT服务端-MQTT-Server"><a href="#7-1-1-MQTT服务端-MQTT-Server" class="headerlink" title="7.1.1 MQTT服务端 MQTT Server"></a>7.1.1 MQTT服务端 MQTT Server</h4><p>一个MQTT服务端只有满足下面所有的要求才算是符合本规范：</p><ol><li><p>服务端发送的所有控制报文的格式必须符合第二章和第三章描述的格式</p></li><li><p>遵守第4.7节描述的主题匹配规则.</p></li><li><p>满足下列章节中所有</p><p>必须</p><p>级别的要求, 明确仅适用于对客户端的除外：</p><ul><li>第一章 – 介绍</li><li>第二章 – MQTT控制报文格式</li><li>第三章 – MQTT控制报文</li><li>第四章 – 操作行为</li><li>第六章 –(如果MQTT的网络层是WebSocket)</li><li>第七章 – 一致性目标</li></ul></li></ol><p>满足一致性要求的服务端<strong>必须</strong>支持使用一个或多个底层传输协议, 只要它提供有序的、可靠的、双向字节流(从客户端到服务端和从服务端到客户端)[MQTT-7.1.1-1]. 但是一致性并不依赖于它支持任何特定的传输协议. 服务端<strong>可以</strong>支持第<a href="https://www.zybuluo.com/khan-lau/note/1326839#42-网络连接-network-connections" target="_blank" rel="noopener">4.2节</a>列出的任何传输协议, 或者任何其它满足 [MQTT-7.1.1-1] 要求的传输协议.</p><h4 id="7-1-2-MQTT客户端-MQTT-Client"><a href="#7-1-2-MQTT客户端-MQTT-Client" class="headerlink" title="7.1.2 MQTT客户端 MQTT Client"></a>7.1.2 MQTT客户端 MQTT Client</h4><p>一个MQTT客户端只有满足下面所有的要求才算是符合本规范：</p><ol><li><p>客户端发送的所有控制报文的格式必须符合第二章和第三章描述的格式</p></li><li><p>满足下列章节中所有</p><p>必须</p><p>级别的要求, 明确仅适用于对服务端的除外：</p><ul><li>第一章 – 介绍</li><li>第二章 – MQTT控制报文格式</li><li>第三章 – MQTT控制报文</li><li>第四章 – 操作行为</li><li>第六章 – (如果MQTT的网络层是WebSocket)</li><li>第七章 – 一致性目标</li></ul></li></ol><p>满足一致性要求的客户端<strong>必须</strong>支持使用一个或多个底层传输协议, 只要它提供有序的、可靠的、双向字节流(从客户端到服务端和从服务端到客户端)[MQTT-7.1.2-1]. 但是一致性并不依赖于它支持任何特定的传输协议. 客户端<strong>可以</strong>支持第<a href="https://www.zybuluo.com/khan-lau/note/1326839#42-网络连接-network-connections" target="_blank" rel="noopener">4.2节</a>列出的任何传输协议, 或者任何其它满足 [MQTT-7.1.2-1] 要求的传输协议.</p><h2 id="附录B-强制性规范声明-非规范"><a href="#附录B-强制性规范声明-非规范" class="headerlink" title="附录B 强制性规范声明(非规范)"></a>附录B 强制性规范声明(非规范)</h2><p>这个附录是非规范的, 只作为本文档正文中可以找到的大量一致性声明的摘要提供. 一致性要求的限制列表见第七章.</p><h4 id="表格：强制性规范声明"><a href="#表格：强制性规范声明" class="headerlink" title="表格：强制性规范声明"></a>表格：强制性规范声明</h4><table><thead><tr><th align="left"><strong>声明序号</strong></th><th align="left"><strong>规范声明</strong></th></tr></thead><tbody><tr><td align="left">[MQTT-1.5.3-1]</td><td align="left">UTF-8编码字符串中的字符数据<strong>必须</strong>是按照Unicode规范 <a href="https://www.zybuluo.com/khan-lau/note/1326839#Unicode" target="_blank" rel="noopener">Unicode</a>] 定义的和在RFC3629 <a href="https://www.zybuluo.com/khan-lau/note/1326839#RFC3629" target="_blank" rel="noopener">RFC3629</a>] 中重申的有效的UTF-8格式. 特别需要指出的是, 这些数据<strong>不能</strong>包含字符码在U+D800和U+DFFF之间的数据. 如果服务端或客户端收到了一个包含无效UTF-8字符的控制报文, 它<strong>必须</strong>关闭网络连接.</td></tr><tr><td align="left">[MQTT-1.5.3-2]</td><td align="left">UTF-8编码的字符串<strong>不能</strong>包含空字符U+0000. 如果客户端或服务端收到了一个包含U+0000的控制报文, 它<strong>必须</strong>关闭网络连接.</td></tr><tr><td align="left">[MQTT-1.5.3-3]</td><td align="left">UTF-8编码序列0XEF 0xBB 0xBF总是被解释为U+FEFF(零宽度非换行空白字符), 无论它出现在字符串的什么位置, 报文接收者都不能跳过或者剥离它.</td></tr><tr><td align="left">[MQTT-2.2.2-1]</td><td align="left">表格 2.2中任何标记为“保留”的标志位, 都是保留给以后使用的, <strong>必须</strong>设置为表格中列出的值.</td></tr><tr><td align="left">[MQTT-2.2.2-2]</td><td align="left">如果收到非法的标志, 接收者<strong>必须</strong>关闭网络连接.</td></tr><tr><td align="left">[MQTT-2.3.1-1]</td><td align="left">SUBSCRIBE, UNSUBSCRIBE和PUBLISH(QoS大于0)控制报文<strong>必须</strong>包含一个非零的16位报文标识符(Packet Identifier.</td></tr><tr><td align="left">[MQTT-2.3.1-2]</td><td align="left">客户端每次发送一个新的这些类型的报文时都<strong>必须</strong>分配一个当前未使用的报文标识符.</td></tr><tr><td align="left">[MQTT-2.3.1-3]</td><td align="left">如果一个客户端要重发这个特殊的控制报文, 在随后重发那个报文时, 它<strong>必须</strong>使用相同的标识符. 当客户端处理完这个报文对应的确认后, 这个报文标识符就释放可重用. QoS 1的PUBLISH对应的是PUBACK, QoS 2的PUBLISH对应的是PUBCOMP, 与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK</td></tr><tr><td align="left">[MQTT-2.3.1-4]</td><td align="left">发送一个QoS 0的PUBLISH报文时, 相同的条件也适用于服务端.</td></tr><tr><td align="left">[MQTT-2.3.1-5]</td><td align="left">QoS设置为0的PUBLISH报文<strong>不能</strong>包含报文标识符.</td></tr><tr><td align="left">[MQTT-2.3.1-6]</td><td align="left">PUBACK, PUBREC, PUBREL报文<strong>必须</strong>包含与最初发送的PUBLISH报文相同的报文标识符.</td></tr><tr><td align="left">[MQTT-2.3.1-7]</td><td align="left">与 [MQTT-2.3.1-6] 类似, SUBACK和UNSUBACK<strong>必须</strong>包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符.</td></tr><tr><td align="left">[MQTT-3.1.0-1]</td><td align="left">客户端到服务端的网络连接建立后, 客户端发送给服务端的第一个报文<strong>必须</strong>是CONNECT报文.</td></tr><tr><td align="left">[MQTT-3.1.0-2]</td><td align="left">在一个网络连接上, 客户端只能发送一次CONNECT报文. 服务端<strong>必须</strong>将客户端发送的第二个CONNECT报文当作协议违规处理并断开客户端的连接.</td></tr><tr><td align="left">[MQTT-3.1.2-1]</td><td align="left">如果协议名不正确服务端<strong>可以</strong>断开客户端的连接, 也<strong>可以</strong>按照某些其它规范继续处理CONNECT报文. 对于后一种情况, 按照本规范, 服务端<strong>不能</strong>继续处理CONNECT报文.</td></tr><tr><td align="left">[MQTT-3.1.2-2]</td><td align="left">如果发现不支持的协议级别, 服务端<strong>必须</strong>给发送一个返回码为0x01(不支持的协议级别)的CONNACK报文响应CONNECT报文, 然后断开客户端的连接.</td></tr><tr><td align="left">[MQTT-3.1.2-3]</td><td align="left">服务端<strong>必须</strong>验证CONNECT控制报文的保留标志位(第0位)是否为0, 如果不为0必须断开客户端连接.</td></tr><tr><td align="left">[MQTT-3.1.2-4]</td><td align="left">如果清理会话(CleanSession)标志被设置为0, 服务端<strong>必须</strong>基于当前会话(使用客户端标识符识别)的状态恢复与客户端的通信. 如果没有与这个客户端标识符关联的会话, 服务端<strong>必须</strong>创建一个新的会话. 在连接断开之后, 当连接断开后, 客户端和服务端<strong>必须</strong>保存会话信息.</td></tr><tr><td align="left">[MQTT-3.1.2-5]</td><td align="left">当清理会话标志为0的会话连接断开之后, 服务端<strong>必须</strong>将之后的QoS 1和QoS 2级别的消息保存为会话状态的一部分, 如果这些消息匹配断开连接时客户端的任何订阅.</td></tr><tr><td align="left">[MQTT-3.1.2-6]</td><td align="left">如果清理会话(CleanSession)标志被设置为1, 客户端和服务端<strong>必须</strong>丢弃之前的任何会话并开始一个新的会话. 会话仅持续和网络连接同样长的时间. 与这个会话关联的状态数据<strong>不能</strong>被任何之后的会话重用.</td></tr><tr><td align="left">[MQTT-3.1.2.7]</td><td align="left">保留消息不是服务端会话状态的一部分, 会话终止时<strong>不能</strong>删除保留消息.</td></tr><tr><td align="left">[MQTT-3.1.2-8]</td><td align="left">遗嘱标志(Will Flag)被设置为1, 表示如果连接请求被接受了, 遗嘱(Will Message)消息<strong>必须</strong>被存储在服务端并且与这个网络连接关联. 之后网络连接关闭时, 服务端<strong>必须</strong>发布这个遗嘱消息, 除非服务端收到DISCONNECT报文时删除了这个遗嘱消息.</td></tr><tr><td align="left">[MQTT-3.1.2-9]</td><td align="left">如果遗嘱标志被设置为1, 连接标志中的Will QoS和Will Retain字段会被服务端用到, 同时有效载荷中<strong>必须</strong>包含Will Topic和Will Message字段.</td></tr><tr><td align="left">[MQTT-3.1.2-10]</td><td align="left">一旦被发布或者服务端收到了客户端发送的DISCONNECT报文, 遗嘱消息就<strong>必须</strong>从存储的会话状态中移除.</td></tr><tr><td align="left">[MQTT-3.1.2-11]</td><td align="left">如果遗嘱标志被设置为0, 连接标志中的Will QoS和Will Retain字段<strong>必须</strong>设置为0, 并且有效载荷中<strong>不能</strong>包含Will Topic和Will Message字段.</td></tr><tr><td align="left">[MQTT-3.1.2-12]</td><td align="left">如果遗嘱标志被设置为0, 网络连接断开时, <strong>不能</strong>发送遗嘱消息. .</td></tr><tr><td align="left">[MQTT-3.1.2-13]</td><td align="left">如果遗嘱标志被设置为0, 遗嘱QoS也<strong>必须</strong>设置为0(0x00).</td></tr><tr><td align="left">[MQTT-3.1.2-14]</td><td align="left">如果遗嘱标志被设置为1, 遗嘱QoS的值可以等于0(0x00), 1(0x01), 2(0x02). 它的值<strong>不能</strong>等于3.</td></tr><tr><td align="left">[MQTT-3.1.2-15]</td><td align="left">如果遗嘱标志被设置为0, 遗嘱保留(Will Retain)标志也<strong>必须</strong>设置为0.</td></tr><tr><td align="left">[MQTT-3.1.2-16]</td><td align="left">如果遗嘱保留被设置为0, 服务端<strong>必须</strong>将遗嘱消息当作非保留消息发布.</td></tr><tr><td align="left">[MQTT-3.1.2-17]</td><td align="left">如果遗嘱保留被设置为1, 服务端<strong>必须</strong>将遗嘱消息当作保留消息发布.</td></tr><tr><td align="left">[MQTT-3.1.2-18]</td><td align="left">如果用户名(User Name)标志被设置为0, 有效载荷中<strong>不能</strong>包含用户名字段.</td></tr><tr><td align="left">[MQTT-3.1.2-19]</td><td align="left">如果用户名(User Name)标志被设置为1, 有效载荷中<strong>必须</strong>包含用户名字段.</td></tr><tr><td align="left">[MQTT-3.1.2-20]</td><td align="left">如果密码(Password)标志被设置为0, 有效载荷中<strong>不能</strong>包含密码字段.</td></tr><tr><td align="left">[MQTT-3.1.2-21]</td><td align="left">如果密码(Password)标志被设置为1, 有效载荷中<strong>必须</strong>包含密码字段</td></tr><tr><td align="left">[MQTT-3.1.2-22]</td><td align="left">如果用户名标志被设置为0, 密码标志也<strong>必须</strong>设置为0.</td></tr><tr><td align="left">[MQTT-3.1.2-23]</td><td align="left">客户端负责保证控制报文发送的时间间隔不超过保持连接的值. 如果没有任何其它的控制报文可以发送, 客户端<strong>必须</strong>发送一个PINGREQ报文.</td></tr><tr><td align="left">[MQTT-3.1.2-24]</td><td align="left">如果保持连接的值非零, 并且服务端在一点五倍的保持连接时间内没有收到客户端的控制报文, 它<strong>必须</strong>断开客户端的网络连接, 认为网络连接已断开.</td></tr><tr><td align="left">[MQTT-3.1.3-1]</td><td align="left">如果包含的话, <strong>必须</strong>按这个顺序出现：客户端标识符, 遗嘱主题, 遗嘱消息, 用户名, 密码.</td></tr><tr><td align="left">[MQTT-3.1.3-2]</td><td align="left">服务端使用客户端标识符 (ClientId) 识别客户端. 连接服务端的每个客户端都有唯一的客户端标识符(ClientId). 客户端和服务端都必须使用ClientId识别两者之间的MQTT会话相关的状态.</td></tr><tr><td align="left">[MQTT-3.1.3-3]</td><td align="left">客户端标识符 (ClientId) <strong>必须</strong>存在而且<strong>必须</strong>是CONNECT报文有效载荷的第一个字段.</td></tr><tr><td align="left">[MQTT-3.1.3-4]</td><td align="left">客户端标识符<strong>必须</strong>是<a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码字符串.</td></tr><tr><td align="left">[MQTT-3.1.3-5]</td><td align="left">服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的客户端标识符, 客户端标识符只能包含这些字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”(大写字母, 小写字母和数字).</td></tr><tr><td align="left">[MQTT-3.1.3-6]</td><td align="left">服务端<strong>可以</strong>允许客户端提供一个零字节的客户端标识符 (ClientId) , 如果这样做了, 服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户端标识符给那个客户端. 然后它<strong>必须</strong>假设客户端提供了那个唯一的客户端标识符, 正常处理这个CONNECT报文.</td></tr><tr><td align="left">[MQTT-3.1.3-7]</td><td align="left">如果客户端提供了一个零字节的客户端标识符, 它<strong>必须</strong>同时将清理会话标志设置为1.</td></tr><tr><td align="left">[MQTT-3.1.3-8]</td><td align="left">如果客户端提供的ClientId为零字节且清理会话标志为0, 服务端<strong>必须</strong>发送返回码为0x02(表示标识符不合格)的CONNACK报文响应客户端的CONNECT报文, 然后关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.1.3-9]</td><td align="left">如果服务端拒绝了这个ClientId, 它<strong>必须</strong>发送返回码为0x02(表示标识符不合格)的CONNACK报文响应客户端的CONNECT报文, 然后关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.1.3-10]</td><td align="left">遗嘱主题<strong>必须</strong>是 <a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码字符串.</td></tr><tr><td align="left">[MQTT-3.1.3-11]</td><td align="left">用户名<strong>必须</strong>是 <a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码字符串.</td></tr><tr><td align="left">[MQTT-3.1.4-1]</td><td align="left">服务端<strong>必须</strong>按照3.1节的要求验证CONNECT报文, 如果报文不符合规范, 服务端不发送CONNACK报文直接关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.1.4-2]</td><td align="left">如果ClientId表明客户端已经连接到这个服务端, 那么服务端<strong>必须</strong>断开原有的客户端连接.</td></tr><tr><td align="left">[MQTT-3.1.4-3]</td><td align="left">服务端<strong>必须</strong>按照 3.1.2.4节的描述执行清理会话的过程.</td></tr><tr><td align="left">[MQTT-3.1.4-4]</td><td align="left">服务端<strong>必须</strong>发送返回码为零的CONNACK报文作为CONNECT报文的确认响应.</td></tr><tr><td align="left">[MQTT-3.1.4-5]</td><td align="left">如果服务端拒绝了CONNECT, 它<strong>不能</strong>处理客户端在CONNECT报文之后发送的任何数据.</td></tr><tr><td align="left">[MQTT-3.2.0-1]</td><td align="left">服务端发送CONNACK报文响应从客户端收到的CONNECT报文. 服务端发送给客户端的第一个报文<strong>必须</strong>是CONNACK.</td></tr><tr><td align="left">[MQTT-3.2.2-1]</td><td align="left">如果服务端收到清理会话(CleanSession)标志为1的连接, 除了将CONNACK报文中的返回码设置为0之外, 还<strong>必须</strong>将CONNACK报文中的当前会话设置(Session Present)标志为0.</td></tr><tr><td align="left">[MQTT-3.2.2-2]</td><td align="left">如果服务端收到一个CleanSession为0的连接, 当前会话标志的值取决于服务端是否已经保存了ClientId对应客户端的会话状态. 如果服务端已经保存了会话状态, 它<strong>必须</strong>将CONNACK报文中的当前会话标志设置为1.</td></tr><tr><td align="left">[MQTT-3.2.2-3]</td><td align="left">如果服务端没有已保存的会话状态, 它<strong>必须</strong>将CONNACK报文中的当前会话设置为0. 还需要将CONNACK报文中的返回码设置为0.</td></tr><tr><td align="left">[MQTT-3.2.2-4]</td><td align="left">如果服务端发送了一个包含非零返回码的CONNACK报文, 它<strong>必须</strong>将当前会话标志设置为0.</td></tr><tr><td align="left">[MQTT-3.2.2-5]</td><td align="left">如果服务端发送了一个包含非零返回码的CONNACK报文, 那么它<strong>必须</strong>关闭网络连接. .</td></tr><tr><td align="left">[MQTT-3.2.2-6]</td><td align="left">如果认为上表格3.1中的所有连接返回码都不太合适, 那么服务端<strong>必须</strong>关闭网络连接, 不需要发送CONNACK报文.</td></tr><tr><td align="left">[MQTT-3.3.1-1]</td><td align="left">客户端或服务端请求重发一个PUBLISH报文时, <strong>必须</strong>将DUP标志设置为1.</td></tr><tr><td align="left">[MQTT-3.3.1-2]</td><td align="left">对于QoS 0的消息, DUP标志<strong>必须</strong>设置为0</td></tr><tr><td align="left">[MQTT-3.3.1-3]</td><td align="left">服务端发送PUBLISH报文给订阅者时, 收到(入站)的PUBLISH报文的DUP标志的值不会被传播. 发送(出站)的PUBLISH报文与收到(入站)的PUBLISH报文中的DUP标志是独立设置的, 它的值<strong>必须</strong>单独的根据发送(出站)的PUBLISH报文是否是一个重发来确定.</td></tr><tr><td align="left">[MQTT-3.3.1-4]</td><td align="left">PUBLISH报文<strong>不能</strong>将QoS所有的位设置为1. 如果服务端或客户端收到QoS所有位都为1的PUBLISH报文, 它<strong>必须</strong>关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.3.1-5]</td><td align="left">如果客户端发给服务端的PUBLISH报文的保留(RETAIN)标志被设置为1, 服务端<strong>必须</strong>存储这个应用消息和它的服务质量等级(QoS), 以便它可以被分发给未来的主题名匹配的订阅者.</td></tr><tr><td align="left">[MQTT-3.3.1-6]</td><td align="left">一个新的订阅建立时, 对每个匹配的主题名, 如果存在最近保留的消息, 它<strong>必须</strong>被发送给这个订阅者.</td></tr><tr><td align="left">[MQTT-3.3.1-7]</td><td align="left">如果服务端收到一条保留(RETAIN)标志为1的QoS 0消息, 它<strong>必须</strong>丢弃之前为那个主题保留的任何消息. 它<strong>应该</strong>将这个新的QoS 0消息当作那个主题的新保留消息, 但是任何时候都<strong>可以</strong>选择丢弃它 — 如果这种情况发生了, 那个主题将没有保留消息.</td></tr><tr><td align="left">[MQTT-3.3.1-8]</td><td align="left">服务端发送PUBLISH报文给客户端时, 如果消息是作为客户端一个新订阅的结果发送, 它<strong>必须</strong>将报文的保留标志设为1.</td></tr><tr><td align="left">[MQTT-3.3.1-9]</td><td align="left">当一个PUBLISH报文发送给客户端是因为匹配一个已建立的订阅时, 服务端<strong>必须</strong>将保留标志设为0, 不管它收到的这个消息中保留标志的值是多少.</td></tr><tr><td align="left">[MQTT-3.3.1-10]</td><td align="left">保留标志为1且有效载荷为零字节的PUBLISH报文会被服务端当作正常消息处理, 它会被发送给订阅主题匹配的客户端. 此外, 同一个主题下任何现存的保留消息必须被移除, 因此这个主题之后的任何订阅者都不会收到一个保留消息.</td></tr><tr><td align="left">[MQTT-3.3.1-11]</td><td align="left">服务端<strong>不能</strong>存储零字节的保留消息.</td></tr><tr><td align="left">[MQTT-3.3.1-12]</td><td align="left">如果客户端发给服务端的PUBLISH报文的保留标志位0, 服务端<strong>不能</strong>存储这个消息也<strong>不能</strong>移除或替换任何现存的保留消息.</td></tr><tr><td align="left">[MQTT-3.3.2-1]</td><td align="left">主题名<strong>必须</strong>是PUBLISH报文可变报头的第一个字段. 它<strong>必须</strong>是 <a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码的字符串.</td></tr><tr><td align="left">[MQTT-3.3.2-2]</td><td align="left">PUBLISH报文中的主题名<strong>不能</strong>包含通配符.</td></tr><tr><td align="left">[MQTT-3.3.2-3]</td><td align="left">服务端发送给订阅客户端的PUBLISH报文的主题名<strong>必须</strong>匹配该订阅的主题过滤器(根据 4.7节定义的匹配过程).</td></tr><tr><td align="left">[MQTT-3.3.4-1]</td><td align="left">PUBLISH报文的接收者<strong>必须</strong>按照根据PUBLISH报文中的QoS等级发送响应, 见表格3.4的描述.</td></tr><tr><td align="left">[MQTT-3.3.5-1]</td><td align="left">服务端<strong>必须</strong>将消息分发给所有订阅匹配的QoS等级最高的客户端.</td></tr><tr><td align="left">[MQTT-3.3.5-2]</td><td align="left">如果服务端实现不授权某个客户端发布PUBLISH报文, 它没有办法通知那个客户端. 它<strong>必须</strong>按照正常的QoS规则发送一个正面的确认, 或者关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.6.1-1]</td><td align="left">PUBREL控制报文固定报头的第3,2,1,0位是保留位, <strong>必须</strong>被设置为0,0,1,0. 服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.8.1-1]</td><td align="left">SUBSCRIBE控制报固定报头的第3,2,1,0位是保留位, <strong>必须</strong>分别设置为0,0,1,0. 服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.8.3-1]</td><td align="left">SUBSCRIBE报文有效载荷中的主题过滤器列表<strong>必须</strong>是<a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8字符串.</td></tr><tr><td align="left">[MQTT-3.8.3-2]</td><td align="left">如果服务端选择不支持包含通配符的主题过滤器, <strong>必须</strong>拒绝任何包含通配符过滤器的订阅请求.</td></tr><tr><td align="left">[MQTT-3.8.3-3]</td><td align="left">SUBSCRIBE报文的有效载荷<strong>必须</strong>包含至少一对主题过滤器 和 QoS等级字段组合. 没有有效载荷的SUBSCRIBE报文是违反协议的.</td></tr><tr><td align="left">[MQTT-3-8.3-4]</td><td align="left">如果有效载荷中的任何位是非零值, 或者QoS不等于0,1或2, 服务端<strong>必须</strong>认为SUBSCRIBE报文是不合法的并关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.8.4-1]</td><td align="left">服务端收到客户端发送的一个SUBSCRIBE报文时, <strong>必须</strong>使用SUBACK报文响应.</td></tr><tr><td align="left">[MQTT-3.8.4-2]</td><td align="left">SUBACK报文<strong>必须</strong>和等待确认的SUBSCRIBE报文有相同的报文标识符.</td></tr><tr><td align="left">[MQTT-3.8.4-3]</td><td align="left">如果服务端收到一个SUBSCRIBE报文, 报文的主题过滤器与一个现存订阅的主题过滤器相同, 那么<strong>必须</strong>使用新的订阅彻底替换现存的订阅. 新订阅的主题过滤器和之前订阅的相同, 但是它的最大QoS值可以不同. 与这个主题过滤器匹配的任何现存的保留消息<strong>必须</strong>被重发, 但是发布流程<strong>不能</strong>中断.</td></tr><tr><td align="left">[MQTT-3.8.4-4]</td><td align="left">如果服务端收到包含多个主题过滤器的SUBSCRIBE报文, 它<strong>必须</strong>如同收到了一系列的多个SUBSCRIBE报文一样处理那个, 除了需要将它们的响应合并到一个单独的SUBACK报文发送.</td></tr><tr><td align="left">[MQTT-3.8.4-5]</td><td align="left">服务端发送给客户端的SUBACK报文对每一对主题过滤器 和QoS等级都<strong>必须</strong>包含一个返回码. 这个返回码<strong>必须</strong>表示那个订阅被授予的最大QoS等级, 或者表示这个订阅失败.</td></tr><tr><td align="left">[MQTT-3.8.4-6]</td><td align="left">服务端可以授予比订阅者要求的低一些的QoS等级. 为响应订阅而发出的消息的有效载荷的QoS<strong>必须</strong>是原始发布消息的QoS和服务端授予的QoS两者中的最小值. 如果原始消息的QoS是1而被授予的最大QoS是0, 允许服务端重复发送一个消息的副本给订阅者.</td></tr><tr><td align="left">[MQTT-3.9.3-1]</td><td align="left">返回码的顺序<strong>必须</strong>和SUBSCRIBE报文中主题过滤器的顺序相同.</td></tr><tr><td align="left">[MQTT-3.9.3-2]</td><td align="left">0x00, 0x01, 0x02, 0x80之外的SUBACK返回码是保留的, <strong>不能</strong>使用.</td></tr><tr><td align="left">[MQTT-3.10.1-1]</td><td align="left">UNSUBSCRIBE报文固定报头的第3,2,1,0位是保留位且<strong>必须</strong>分别设置为0,0,1,0. 服务端<strong>必须</strong>认为任何其它的值都是不合法的并关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.10.3-1]</td><td align="left">UNSUBSCRIBE报文中的主题过滤器<strong>必须</strong>是连续打包的、按照<a href="https://www.zybuluo.com/khan-lau/note/1326839#153-utf-8编码字符串-utf-8-encoded-strings" target="_blank" rel="noopener">1.5.3节</a>定义的UTF-8编码字符串.</td></tr><tr><td align="left">[MQTT-3.10.3-2]</td><td align="left">UNSUBSCRIBE报文的有效载荷<strong>必须</strong>至少包含一个消息过滤器. 没有有效载荷的UNSUBSCRIBE报文是违反协议的.</td></tr><tr><td align="left">[MQTT-3.10.4-1]</td><td align="left">UNSUBSCRIBE报文提供的主题过滤器(无论是否包含通配符)<strong>必须</strong>与服务端持有的这个客户端的当前主题过滤器集合逐个字符比较. 如果有任何过滤器完全匹配, 那么它(服务端)自己的订阅将被删除, 否则不会有进一步的处理.</td></tr><tr><td align="left">[MQTT-3.10.4-2]</td><td align="left">如果服务端删除了一个订阅, 它<strong>必须</strong>停止分发任何新消息给这个客户端.</td></tr><tr><td align="left">[MQTT-3.10.4-3]</td><td align="left">如果服务端删除了一个订阅, 它<strong>必须</strong>完成分发任何已经开始往客户端发送的QoS 1和QoS 2的消息.</td></tr><tr><td align="left">[MQTT-3.10.4-4]</td><td align="left">服务端<strong>必须</strong>发送UNSUBACK报文响应客户端的UNSUBSCRIBE请求. UNSUBACK报文<strong>必须</strong>包含和UNSUBSCRIBE报文相同的报文标识符.</td></tr><tr><td align="left">[MQTT-3.10.4-5]</td><td align="left">即使没有删除任何主题订阅, 服务端也<strong>必须</strong>发送一个SUBACK响应.</td></tr><tr><td align="left">[MQTT-3.10.4-6]</td><td align="left">如果服务端收到包含多个主题过滤器的UNSUBSCRIBE报文, 它<strong>必须</strong>如同收到了一系列的多个UNSUBSCRIBE报文一样处理那个报文, 除了将它们的响应合并到一个单独的UNSUBACK报文外.</td></tr><tr><td align="left">[MQTT-3.12.4-1]</td><td align="left">服务端<strong>必须</strong>发送 PINGRESP报文响应客户端的PINGREQ报文.</td></tr><tr><td align="left">[MQTT-3.14.1-1]</td><td align="left">服务端<strong>必须</strong>验证所有的保留位都被设置为0, 如果它们不为0<strong>必须</strong>断开连接.</td></tr><tr><td align="left">[MQTT-3.14.4-1]</td><td align="left">客户端发送DISCONNECT报文之后, <strong>必须</strong>关闭网络连接.</td></tr><tr><td align="left">[MQTT-3.14.4-2]</td><td align="left">客户端发送DISCONNECT报文之后, <strong>不能</strong>通过那个网络连接再发送任何控制报文.</td></tr><tr><td align="left">[MQTT-3.14.4-3]</td><td align="left">服务端收到DISCONNECT报文时, <strong>必须</strong>丢弃任何与当前连接关联的未发布的遗嘱消息, 具体描述见 3.1.2.5节.</td></tr><tr><td align="left">[MQTT-4.1.0-1]</td><td align="left">在整个会话期间, 客户端和服务端都<strong>必须</strong>存储会话状态.</td></tr><tr><td align="left">[MQTT-4.1.0-2]</td><td align="left">会话<strong>必须</strong>至少持续和它的活跃网络连接同样长的时间.</td></tr><tr><td align="left">[MQTT-4.3.1-1]</td><td align="left">对于QoS 0的分发协议, 发送者<strong>必须</strong>发送QoS等于0, DUP等于0的PUBLISH报文.</td></tr><tr><td align="left">[MQTT-4.4.0-1]</td><td align="left">客户端设置清理会话(CleanSession)标志为0重连时, 客户端和服务端<strong>必须</strong>使用原始的报文标识符重发任何未确认的PUBLISH报文(如果QoS&gt;0)和PUBREL报文.</td></tr><tr><td align="left">[MQTT-4.5.0-1]</td><td align="left">服务端接管入站应用消息的所有权时, 它<strong>必须</strong>将消息添加到订阅匹配的客户端的会话状态中. 匹配规则定义见 4.7节.</td></tr><tr><td align="left">[MQTT-4.5.0-2]</td><td align="left">客户端<strong>必须</strong>按照可用的服务质量(QoS)规则确认它收到的任何PUBLISH报文, 不管它选择是否处理报文包含的应用消息.</td></tr><tr><td align="left">[MQTT-4.6.0-1]</td><td align="left">重发任何之前的PUBLISH报文时, <strong>必须</strong>按原始PUBLISH报文的发送顺序重发(适用于QoS 1和QoS 2消息).</td></tr><tr><td align="left">[MQTT-4.6.0-2]</td><td align="left"><strong>必须</strong>按照对应的PUBLISH报文的顺序发送PUBACK报文(QoS 1消息).</td></tr><tr><td align="left">[MQTT-4.6.0-3]</td><td align="left"><strong>必须</strong>按照对应的PUBLISH报文的顺序发送PUBREC报文(QoS 2消息).</td></tr><tr><td align="left">[MQTT-4.6.0-4]</td><td align="left"><strong>必须</strong>按照对应的PUBREC报文的顺序发送PUBREL报文(QoS 2消息).</td></tr><tr><td align="left">[MQTT-4.6.0-5]</td><td align="left">服务端<strong>必须</strong>默认认为每个主题都是有序的. 它<strong>可以</strong>提供一个管理功能或其它机制, 以允许将一个或多个主题当作是<strong>无序的</strong>.</td></tr><tr><td align="left">[MQTT-4.6.0-6]</td><td align="left">服务端处理发送给有序主题的消息时, <strong>必须</strong>按照上面的规则将消息分发给每个订阅者. 此外, 它<strong>必须</strong>按照从客户端收到的顺序发送PUBLISH报文给消费者(对相同的主题和QoS).</td></tr><tr><td align="left">[MQTT-4.7.1-1]</td><td align="left">主题过滤器中可以使用通配符, 但是主题名<strong>不能</strong>使用通配符.</td></tr><tr><td align="left">[MQTT-4.7.1-2]</td><td align="left">多层通配符必须位于它自己的层级或者跟在主题层级分隔符后面. 不管哪种情况, 它都<strong>必须</strong>是主题过滤器的最后一个字符.</td></tr><tr><td align="left">[MQTT-4.7.1-3]</td><td align="left">在主题过滤器的任意层级都可以使用单层通配符, 包括第一个和最后一个层级. 然而它<strong>必须</strong>占据过滤器的整个层级.</td></tr><tr><td align="left">[MQTT-4.7.2-1]</td><td align="left">服务端<strong>不能</strong>将 $ 字符开头的主题名匹配通配符 (#或+) 开头的主题过滤器.</td></tr><tr><td align="left">[MQTT-4.7.3-1]</td><td align="left">所有的主题名和主题过滤器<strong>必须</strong>至少包含一个字符.</td></tr><tr><td align="left">[MQTT-4.7.3-2]</td><td align="left">主题名和主题过滤器<strong>不能</strong>包含空字符 (Unicode U+0000) <a href="https://www.zybuluo.com/khan-lau/note/1326839#Unicode" target="_blank" rel="noopener">Unicode</a>] .</td></tr><tr><td align="left">[MQTT-4.7.3-3]</td><td align="left">主题名和主题过滤器是UTF-8编码字符串, 它们<strong>不能</strong>超过65535字节.</td></tr><tr><td align="left">[MQTT-4.7.3-4]</td><td align="left">匹配订阅时, 服务端<strong>不能</strong>对主题名或主题过滤器执行任何规范化(normalization)处理, 不能修改或替换任何未识别的字符.</td></tr><tr><td align="left">[MQTT-4.8.0-1]</td><td align="left">除非另有说明, 如果服务端或客户端遇到了协议违规的行为, 它<strong>必须</strong>关闭传输这个协议违规控制报文的网络连接.</td></tr><tr><td align="left">[MQTT-4.8.0-2]</td><td align="left">如果客户端或服务端处理入站控制报文时遇到了瞬时错误, 它<strong>必须</strong>关闭传输那个控制报文的网络连接.</td></tr><tr><td align="left">[MQTT-6.0.0-1]</td><td align="left">MQTT控制报文<strong>必须</strong>使用WebSocket二进制数据帧发送. 如果收到任何其它类型的数据帧, 接收者<strong>必须</strong>关闭网络连接.</td></tr><tr><td align="left">[MQTT-6.0.0-2]</td><td align="left">单个WebSocket数据帧可以包含多个或者部分MQTT报文. 接收者<strong>不能</strong>假设MQTT控制报文按WebSocket帧边界对齐.</td></tr><tr><td align="left">[MQTT-6.0.0-3]</td><td align="left">客户端<strong>必须</strong>将字符串 <strong>mqtt</strong> 包含在它提供的WebSocket子协议列表里.</td></tr><tr><td align="left">[MQTT-6.0.0-4]</td><td align="left">服务端选择和返回的WebSocket子协议名<strong>必须</strong>是 <strong>mqtt</strong></td></tr><tr><td align="left">[MQTT-7.0.0-1]</td><td align="left">MQTT实现可以同时是MQTT客户端和MQTT服务端. 接受入站连接和建立到其它服务端的出站连接的服务端必须同时符合MQTT客户端和MQTT服务端的要求.</td></tr><tr><td align="left">[MQTT-7.0.0-2]</td><td align="left">为了与任何其它的一致性实现交互操作, 一致性实现不能要求使用在本规范之外定义的任何扩展.</td></tr><tr><td align="left">[MQTT-7.1.1-1]</td><td align="left">满足一致性要求的服务端<strong>必须</strong>支持使用一个或多个底层传输协议, 只要它提供有序的、可靠的、双向字节流(从客户端到服务端和从服务端到客户端)</td></tr><tr><td align="left">[MQTT-7.1.2-1]</td><td align="left">满足一致性要求的客户端<strong>必须</strong>支持使用一个或多个底层传输协议, 只要它提供有序的、可靠的、双向字节流(从客户端到服务端和从服务端到客户端)</td></tr></tbody></table><h4 id="关于QoS的补充说明"><a href="#关于QoS的补充说明" class="headerlink" title="关于QoS的补充说明"></a>关于QoS的补充说明</h4><h5 id="MQTT-4-3-2-1-对于QoS-1的分发协议-发送者"><a href="#MQTT-4-3-2-1-对于QoS-1的分发协议-发送者" class="headerlink" title="[MQTT-4.3.2-1] 对于QoS 1的分发协议, 发送者"></a>[MQTT-4.3.2-1] 对于QoS 1的分发协议, 发送者</h5><ul><li>每次发送新的应用消息都<strong>必须</strong>分配一个未使用的报文标识符.</li><li>MUST send a PUBLISH Packet containing this Packet Identifier with QoS=1, DUP=0.</li><li>发送的PUBLISH报文<strong>必须</strong>包含报文标识符且QoS等于1, DUP等于0.</li><li><strong>必须</strong>将这个PUBLISH报文看作是 <em>未确认的</em> , 直到从接收者那收到对应的PUBACK报文. 4.4节有一个关于未确认消息的讨论.</li></ul><h5 id="MQTT-4-3-2-2-对于QoS-1的分发协议-接收者"><a href="#MQTT-4-3-2-2-对于QoS-1的分发协议-接收者" class="headerlink" title="[MQTT-4.3.2-2] 对于QoS 1的分发协议, 接收者"></a>[MQTT-4.3.2-2] 对于QoS 1的分发协议, 接收者</h5><ul><li>响应的PUBACK报文<strong>必须</strong>包含一个报文标识符, 这个标识符来自接收到的、已经接受所有权的PUBLISH报文.</li><li>发送了PUBACK报文之后, 接收者必须将任何包含相同报文标识符的入站PUBLISH报文当作一个新的消息, 并忽略它的DUP标志的值.</li></ul><h5 id="MQTT-4-3-3-1-对于QoS-2的分发协议-发送者"><a href="#MQTT-4-3-3-1-对于QoS-2的分发协议-发送者" class="headerlink" title="[MQTT-4.3.3-1] 对于QoS 2的分发协议, 发送者"></a>[MQTT-4.3.3-1] 对于QoS 2的分发协议, 发送者</h5><ul><li><p>必须给要发送的新应用消息分配一个未使用的报文标识符.</p><ul><li>MUST send a PUBLISH packet containing this Packet Identifier with QoS=2, DUP=0.</li></ul></li><li><p>发送的PUBLISH报文</p><p>必须</p><p>包含报文标识符且报文的QoS等于2,, DUP等于0.</p><ul><li><strong>必须</strong>将这个 <code>PUBLISH</code> 报文看作是 <em>未确认的</em> , 直到从接收者那收到对应的 PUBREC 报文. 4.4节有一个关于未确认消息的讨论.</li><li>收到PUBREC报文后<strong>必须</strong>发送一个PUBREL报文. PUBREL报文必须包含与原始 PUBLISH 报文相同的报文标识符.</li><li><strong>必须</strong>将这个PUBREL报文看作是 <em>未确认的</em> , 直到从接收者那收到对应的PUBCOMP报文.</li><li>一旦发送了对应的PUBREL报文就<strong>不能</strong>重发这个PUBLISH报文.</li></ul></li></ul><h5 id="MQTT-4-3-3-2-对于QoS-2的分发协议-接收者"><a href="#MQTT-4-3-3-2-对于QoS-2的分发协议-接收者" class="headerlink" title="[MQTT-4.3.3-2] 对于QoS 2的分发协议, 接收者"></a>[MQTT-4.3.3-2] 对于QoS 2的分发协议, 接收者</h5><ul><li><p>响应的PUBREC报文<strong>必须</strong>包含报文标识符, 这个标识符来自接收到的、已经接受所有权的PUBLISH报文.</p></li><li><p>在收到对应的PUBREL报文之前, 接收者<strong>必须</strong>发送PUBREC报文确认任何后续的具有相同标识符的PUBLISH报文. 在这种情况下, 它<strong>不能</strong>重复分发消息给任何后续的接收者.</p></li><li><p>响应PUBREL报文的PUBCOMP报文</p><p>必须</p><p>包含与PUBREL报文相同的标识符.</p><ul><li>发送PUBCOMP报文之后, 接收者必须将包含相同报文标识符的任何后续PUBLISH报文当作一个新的发布.</li></ul></li></ul><h4 id="项目主页"><a href="#项目主页" class="headerlink" title="项目主页"></a>项目主页</h4><ul><li><a href="https://github.com/mcxiaoke/mqtt" target="_blank" rel="noopener">MQTT协议中文版</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT 协议 5.0</title>
    <link href="/Network/MQTT-%E5%8D%8F%E8%AE%AE-5-0/"/>
    <url>/Network/MQTT-%E5%8D%8F%E8%AE%AE-5-0/</url>
    
    <content type="html"><![CDATA[<h1 id="MQTT-协议-5-0中文版"><a href="#MQTT-协议-5-0中文版" class="headerlink" title="MQTT 协议 5.0中文版"></a>MQTT 协议 5.0中文版</h1><hr><pre><code>委员会规范草案 02 公开评审草案 022017年10月26日</code></pre><ul><li><p>规范链接</p><ul><li>当前版本:<ul><li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.docx" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.docx</a> (Authoritative)</li><li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.html</a></li><li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.pdf" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.pdf</a></li></ul></li><li>以前的版本:<ul><li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.docx" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.docx</a> (Authoritative)</li><li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.html</a></li><li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.pdf" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.pdf</a></li></ul></li><li>最新版本:<ul><li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.docx" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.docx</a> (Authoritative)</li><li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html</a></li><li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.pdf" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.pdf</a></li></ul></li></ul></li><li><p>技术委员会:<br><code>OASIS Message Queuing Telemetry Transport (MQTT) TC</code></p><ul><li>主席:</li><li>Brian Raymor (<a href="mailto:brian.raymor@microsoft.com" target="_blank" rel="noopener">brian.raymor@microsoft.com</a>), Microsoft</li><li>Richard Coppen (<a href="mailto:coppen@uk.ibm.com" target="_blank" rel="noopener">coppen@uk.ibm.com</a>), IBM</li><li>编辑:</li><li>Andrew Banks (<a href="mailto:andrew_banks@uk.ibm.com" target="_blank" rel="noopener">andrew_banks@uk.ibm.com</a>), IBM</li><li>Ed Briggs (<a href="mailto:edbriggs@microsoft.com" target="_blank" rel="noopener">edbriggs@microsoft.com</a>), Microsoft</li><li>Ken Borgendale (<a href="mailto:kwb@us.ibm.com" target="_blank" rel="noopener">kwb@us.ibm.com</a>), IBM</li><li>Rahul Gupta (<a href="mailto:rahul.gupta@us.ibm.com" target="_blank" rel="noopener">rahul.gupta@us.ibm.com</a>), IBM</li></ul></li><li><p>相关文档:</p><ul><li>本规范代替:</li><li>MQTT协议3.1.1版本. 编辑是Andrew Banks和Rahul Gupta, 发布于2014年10月29日, OASIS标准:<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a>.</li></ul></li><li><p>本规范与此有关:</p><ul><li>MQTT 和 NIST 网络安全框架 1.0 版. 编辑是Geoff Brown和Louis-Philippe Lamoureux.最新版本:<a href="http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html</a>.</li></ul></li><li><p>摘要:</p><ul><li>MQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议. 它的设计思想是轻巧、开放、简单、规范, 因此易于实现. 这些特点使得它对很多场景来说都是很好的选择, 包括受限的环境如<code>机器与机器的通信(M2M)</code>以及<code>物联网环境(IoT)</code>, 这些场景要求很小的代码封装或者网络带宽非常昂贵.</li><li>本协议运行在TCP/IP, 或其他提供了有序、可靠、双向连接的网络连接上. 它有以下特点:</li><li>使用发布/订阅消息模式, 提供了一对多的消息分发和应用之间的解耦.</li><li>消息传输不需要知道负载内容.</li><li>提供三种等级的服务质量:<ul><li>“<code>最多一次</code>”, 尽操作环境所能提供的最大努力分发消息. 消息可能会丢失. 例如, 这个等级可用于环境传感器数据, 单次的数据丢失没关系, 因为不久之后会再次发送.</li><li>“<code>至少一次</code>”, 保证消息可以到达, 但是可能会重复.</li><li>“<code>仅一次</code>”, 保证消息只到达一次. 例如, 这个等级可用在一个计费系统中, 这里如果消息重复或丢失会导致不正确的收费.</li></ul></li><li>很小的传输消耗和协议数据交换, 最大限度减少网络流量.</li><li>异常连接断开发生时, 能通知到相关各方.</li></ul></li><li><p>状态:</p><ul><li>本文档最后由OASIS成员在上面标示的日期最终修订或批准. 批准的级别也在上面列出了. 如果要查看本文档最新的修订版请检查上面的 最新版本位置. 技术委员会产生的其他修订版和其他技术文档都列在这里:<a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt#technical" target="_blank" rel="noopener">https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt#technical</a> .</li><li>技术委员会成员对本规范的评论应该发送到技术委员会的邮件列表. 其他人应该发送评论到技术委员会的公共评论列表, 方法是点击技术委员会网站的发送评论按钮, 网页地址是<a href="https://www.oasis-open.org/committees/mqtt/" target="_blank" rel="noopener">https://www.oasis-open.org/committees/mqtt/</a> .</li><li>本规范草案的发布基于OASIS 知识产权政策的Non-Assertion模式. 关于实现本规范必不可少的任何专利是否已公开, 以及其他的专利许可条款相关的信息, 请参考技术委员会网站的知识产权部分 (<a href="https://www.oasis-open.org/committees/mqtt/ipr.php" target="_blank" rel="noopener">https://www.oasis-open.org/committees/mqtt/ipr.php</a>).</li><li>请注意, 为本产品声明的任何机器可读内容(计算机语言定义)单独提供纯文本文件. 对于产品叙述文档中出现的任何不一致, 以纯文本文档为准.</li></ul></li><li><p>引用格式:</p><ul><li><p>引用此规范时应该使用下面的引文格式:</p></li><li><p>[mqtt-v5.0]</p><p>MQTT Version 5.0. Edited by Andrew Banks, Ed Briggs, Ken Borgendale, and Rahul Gupta. 26 October 2017. OASIS Committee Specification Draft 02</p><ul><li>Public Review Draft 02. <a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.html</a>.</li><li>Latest version: <a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html</a>.</li></ul></li></ul></li><li><p>文档链接</p><ul><li><a href="https://github.com/hui6075/mqtt_v5" target="_blank" rel="noopener">MQTT v5.0草案公开审阅版中文翻译项目</a></li><li><a href="https://github.com/hui6075/mqtt_v5/tree/master/protocol/mqtt-v5.0-zh_cn.pdf" target="_blank" rel="noopener">MQTT v5.0草案公开审阅版中文版PDF</a></li></ul></li><li><p>修订记录</p></li></ul><table><thead><tr><th align="left">版本</th><th align="left">日期</th><th align="left">发布说明</th></tr></thead><tbody><tr><td align="left">0.0.1</td><td align="left">2018-05-18</td><td align="left">发布全部文本, 完成初步审校, 公开发布第一版</td></tr></tbody></table><p>- 关于译者<br>- <a href="https://github.com/hui6075" target="_blank" rel="noopener">GitHub</a><br>- Email</p><ul><li>注意<ul><li>Copyright © OASIS Open 2017. All Rights Reserved.<br>All capitalized terms in the following text have the meanings assigned to them in the OASIS Intellectual Property Rights Policy (the “OASIS IPR Policy”). The full Policy may be found at the OASIS website.</li><li>This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published, and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this section are included on all such copies and derivative works. However, this document itself may not be modified in any way, including by removing the copyright notice or references to OASIS, except as needed for the purpose of developing any document or deliverable produced by an OASIS Technical Committee (in which case the rules applicable to copyrights, as set forth in the OASIS IPR Policy, must be followed) or as required to translate it into languages other than English.</li><li>The limited permissions granted above are perpetual and will not be revoked by OASIS or its successors or assigns.</li><li>This document and the information contained herein is provided on an “AS IS” basis and OASIS DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</li><li>OASIS requests that any OASIS Party or any other party that believes it has patent claims that would necessarily be infringed by implementations of this OASIS Committee Specification or OASIS Standard, to notify OASIS TC Administrator and provide an indication of its willingness to grant patent licenses to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification.</li><li>OASIS invites any party to contact the OASIS TC Administrator if it is aware of a claim of ownership of any patent claims that would necessarily be infringed by implementations of this specification by a patent holder that is not willing to provide a license to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification. OASIS may include such claims on its website, but disclaims any obligation to do so.</li><li>OASIS takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on OASIS’ procedures with respect to rights in any document or deliverable produced by an OASIS Technical Committee can be found on the OASIS website. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this OASIS Committee Specification or OASIS Standard, can be obtained from the OASIS TC Administrator. OASIS makes no representation that any information or list of intellectual property rights will at any time be complete, or that any claims in such list are, in fact, Essential Claims.</li><li>The name “OASIS” is a trademark of OASIS, the owner and developer of this specification, and should be used only to refer to the organization and its official outputs. OASIS welcomes reference to, and implementation and use of, specifications, while reserving the right to enforce its marks against misleading uses. Please see <a href="https://www.oasis-open.org/policies-guidelines/trademark" target="_blank" rel="noopener">https://www.oasis-open.org/policies-guidelines/trademark</a> for above guidance.</li></ul></li></ul><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-0-知识产权政策"><a href="#1-0-知识产权政策" class="headerlink" title="1.0 知识产权政策"></a>1.0 知识产权政策</h3><pre><code>此公开评审草案的发布基于OASIS IPR Policy的Non-Assertion模式. 关于实现本规范必不可少的任何专利是否已公开, 以及其他的专利许可条款相关的信息, 请参考技术委员会网站的知识产权部分(https://www.oasis-open.org/committees/mqtt/ipr.php).</code></pre><h3 id="1-1-MQTT协议的组织结构"><a href="#1-1-MQTT协议的组织结构" class="headerlink" title="1.1 MQTT协议的组织结构"></a>1.1 MQTT协议的组织结构</h3><ul><li>本规范分为七个章节:<ul><li><a href="https://www.zybuluo.com/khan-lau/note/1325300#1-概述" target="_blank" rel="noopener">第一章 - 介绍</a></li><li><a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章 - MQTT控制报文格式</a></li><li><a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章 - MQTT控制报文</a></li><li><a href="https://www.zybuluo.com/khan-lau/note/1325300#4-操作行为" target="_blank" rel="noopener">第四章 - 操作行为</a></li><li><a href="https://www.zybuluo.com/khan-lau/note/1325300#5-安全非规范" target="_blank" rel="noopener">第五章 - 安全</a></li><li><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">第六章 - 使用Websocket作为网络传输层</a></li><li><a href="https://www.zybuluo.com/khan-lau/note/1325300#7-一致性" target="_blank" rel="noopener">第七章 - 一致性目标</a></li></ul></li></ul><h3 id="1-2-术语"><a href="#1-2-术语" class="headerlink" title="1.2 术语"></a>1.2 术语</h3><p>本规范中用到的关键字 <code>必须</code> <code>MUST</code>, <code>不能</code> <code>MUST NOT</code>, <code>要求</code> <code>REQUIRED</code>, <code>将会</code> <code>SHALL</code>, <code>不会</code> <code>SHALL NOT</code>, <code>应该</code> <code>SHOULD</code>, <code>不应该</code> <code>SHOULD NOT</code>, <code>推荐</code> <code>RECOMMENDED</code>, <code>可以</code> <code>MAY</code>, <code>可选</code> <code>OPTIONAL</code>都是按照<code>IETF RFC 2119 [RFC2119]</code> 中的描述解释.</p><ul><li>网络连接(Network Connection):<ul><li>MQTT使用的底层传输协议基础设施.</li><li>客户端使用它连接服务端.</li><li>它提供有序的、可靠的、双向字节流传输.</li><li>例子见<a href="https://www.zybuluo.com/khan-lau/note/1325300#42-网络连接" target="_blank" rel="noopener">4.2节</a>.</li></ul></li><li>应用消息(Application Message):<ul><li>MQTT协议通过网络传输应用数据.应用消息通过MQTT传输时, 它们有关联的服务质量(QoS)和主题(Topic).</li></ul></li><li>客户端(Client):<ul><li>使用MQTT的程序或设备.客户端总是通过网络连接到服务端. 它可以:</li><li>打开连接到服务端的网络连接</li><li>发布应用消息给其他相关的客户端</li><li>订阅以请求接受相关的应用消息</li><li>取消订阅以移除接受相应消息的请求</li><li>关闭连接到服务端的网络连接</li></ul></li><li>服务端(Server):<ul><li>一个程序或设备, 作为发送消息的客户端和请求订阅的客户端之间的中介. 服务端:</li><li>接受来自客户端的网络连接</li><li>接受客户端发布的应用消息</li><li>处理客户端的订阅和取消订阅请求</li><li>转发应用消息给符合条件的客户端订阅</li><li>关闭来自客户端的网络连接</li></ul></li><li>会话(Session):<ul><li>客户端和服务端之间的状态交互.一些会话持续时长与网络连接一样, 另一些可以在客户端和服务端的多个连续网络连接间扩展.</li></ul></li><li>订阅(Subscription):<ul><li>订阅包含一个<code>主题过滤器(Topic Filter)</code>和一个最大的<code>服务质量(QoS)</code>等级. 订阅与单个<code>会话(Session)</code>关联.会话可以包含多于一个的订阅. 会话的每个订阅都有一个不同的主题过滤器.</li></ul></li><li>共享订阅(Shared Subscription):<ul><li>一个共享订阅包含一个<code>主题过滤器(Topic Filter)</code>和一个最大的<code>服务质量(QoS)</code>等级. 一个共享订阅可以与多个订阅会话相关联, 便于支持大范围消息交换模式. 一条主题匹配的应用消息只发送给关联到此共享订阅的多个会话中的一个会话. 一个会话可以包括多个共享订阅, 可以同时包含共享订阅与非共享订阅.</li></ul></li><li>通配符订阅(Wildcard Subscription):<ul><li>通配符订阅是指<code>主题过滤器(Topic Filter)</code>包含一个或多个通配符的订阅.通配符订阅使得一次订阅匹配多个<code>主题名(Topic Name)</code>. <a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> 描述了主题过滤器中的通配符.</li></ul></li><li>主题名(Topic Name):<ul><li>附加在应用消息上的一个标签, 服务端已知且与订阅匹配. 服务端发送应用消息的一个副本给每一个匹配的客户端订阅.</li></ul></li><li>主题过滤器(Topic Filter):<ul><li>订阅中包含的一个表达式, 用于表示相关的一个或多个主题.主题过滤器可以使用通配符.</li></ul></li><li>MQTT控制报文(MQTT Control Packet):<ul><li>通过网络连接发送的信息数据包. MQTT 规范定义了十四种不同类型的MQTT控制报文, 其中一个(<code>PUBLISH</code> 报文)用于传输应用消息.</li></ul></li><li>无效报文(Malformed Packet):<ul><li>根据规范不能被正确解析的控制报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 描述了如何进行相应的错误处理.</li></ul></li><li>协议错误(Protocol Error):<ul><li>在报文解析之后发现包含协议不允许或与客户端或服务端当前状态不一致的数据的错误. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 描述了如何进行相应的错误处理.</li></ul></li><li>遗嘱消息(Will Message):<ul><li>在网络连接非正常关闭的情况下, 由服务端发布的应用消息. <a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a> 描述了遗嘱消息.</li></ul></li></ul><h3 id="1-3-规范引用"><a href="#1-3-规范引用" class="headerlink" title="1.3 规范引用"></a>1.3 规范引用</h3><ul><li>[RFC2119]<ul><li>Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <a href="http://www.rfc-editor.org/info/rfc2119" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc2119</a></li></ul></li><li>[RFC3629]<br>-Yergeau, F., “UTF-8, a transformation format of ISO 10646”, STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <a href="http://www.rfc-editor.org/info/rfc3629" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc3629</a></li><li>[RFC6455]<ul><li>Fette, I. and A. Melnikov, “The WebSocket Protocol”, RFC 6455, DOI 10.17487/RFC6455, December 2011, <a href="http://www.rfc-editor.org/info/rfc6455" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6455</a></li></ul></li><li>[Unicode]<ul><li>The Unicode Consortium. The Unicode Standard, <a href="http://www.unicode.org/versions/latest/" target="_blank" rel="noopener">http://www.unicode.org/versions/latest/</a></li></ul></li></ul><h3 id="1-4-非规范引用"><a href="#1-4-非规范引用" class="headerlink" title="1.4 非规范引用"></a>1.4 非规范引用</h3><ul><li>[RFC0793]<ul><li>Postel, J., “Transmission Control Protocol”, STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <a href="http://www.rfc-editor.org/info/rfc793" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc793</a></li></ul></li><li>[RFC5246]<ul><li>Dierks, T. and E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.2”, RFC 5246, DOI 10.17487/RFC5246, August 2008, <a href="http://www.rfc-editor.org/info/rfc5246" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc5246</a></li></ul></li><li>[AES]<ul><li>Advanced Encryption Standard (AES) (FIPS PUB 197). <a href="https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf" target="_blank" rel="noopener">https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf</a></li></ul></li><li>[CHACHA20]<ul><li>ChaCha20 and Poly1305 for IETF Protocols, <a href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7539</a></li></ul></li><li>[FIPS1402]<ul><li>Security Requirements for Cryptographic Modules (FIPS PUB 140-2), <a href="https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf" target="_blank" rel="noopener">https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf</a></li></ul></li><li>[IEEE 802.1AR]<ul><li>IEEE Standard for Local and metropolitan area networks - Secure Device Identity, <a href="http://standards.ieee.org/findstds/standard/802.1AR-2009.html" target="_blank" rel="noopener">http://standards.ieee.org/findstds/standard/802.1AR-2009.html</a></li></ul></li><li>[ISO29192]<ul><li>ISO/IEC 29192-1:2012 Information technology – Security techniques – Lightweight cryptography – Part 1: General, <a href="https://www.iso.org/standard/56425.html" target="_blank" rel="noopener">https://www.iso.org/standard/56425.html</a></li></ul></li><li>[MQTT NIST]<ul><li>MQTT supplemental publication, MQTT and the NIST Framework for Improving Critical Infrastructure Cybersecurity, <a href="http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html</a></li></ul></li><li>[MQTTV311]<ul><li>MQTT V3.1.1 Protocol Specification, <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></li></ul></li><li>[ISO20922]<ul><li>MQTT V3.1.1 ISO Standard (ISO/IEC 20922:2016), <a href="https://www.iso.org/standard/69466.html" target="_blank" rel="noopener">https://www.iso.org/standard/69466.html</a></li></ul></li><li>[NISTCSF]<ul><li>Improving Critical Infrastructure Cybersecurity Executive Order 13636, <a href="https://www.nist.gov/sites/default/files/documents/itl/preliminary-cybersecurity-framework.pdf" target="_blank" rel="noopener">https://www.nist.gov/sites/default/files/documents/itl/preliminary-cybersecurity-framework.pdf</a></li></ul></li><li>[NIST7628]<ul><li>NISTIR 7628 Guidelines for Smart Grid Cyber Security Catalogue, <a href="https://www.nist.gov/sites/default/files/documents/smartgrid/nistir-7628_total.pdf" target="_blank" rel="noopener">https://www.nist.gov/sites/default/files/documents/smartgrid/nistir-7628_total.pdf</a></li></ul></li><li>[NSAB]<ul><li>NSA Suite B Cryptography, <a href="http://www.nsa.gov/ia/programs/suiteb_cryptography/" target="_blank" rel="noopener">http://www.nsa.gov/ia/programs/suiteb_cryptography/</a></li></ul></li><li>[PCIDSS]<ul><li>PCI-DSS Payment Card Industry Data Security Standard, <a href="https://www.pcisecuritystandards.org/pci_security/" target="_blank" rel="noopener">https://www.pcisecuritystandards.org/pci_security/</a></li></ul></li><li>[RFC1928]<ul><li>Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, “SOCKS Protocol Version 5”, RFC 1928, DOI 10.17487/RFC1928, March 1996, <a href="http://www.rfc-editor.org/info/rfc1928" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc1928</a></li></ul></li><li>[RFC4511]<ul><li>Sermersheim, J., Ed., “Lightweight Directory Access Protocol (LDAP): The Protocol”, RFC 4511, DOI 10.17487/RFC4511, June 2006, <a href="http://www.rfc-editor.org/info/rfc4511" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc4511</a></li></ul></li><li>[RFC5280]<ul><li>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, “Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile”, RFC 5280, DOI 10.17487/RFC5280, May 2008, <a href="http://www.rfc-editor.org/info/rfc5280" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc5280</a></li></ul></li><li>[RFC6066]<ul><li>Eastlake 3rd, D., “Transport Layer Security (TLS) Extensions: Extension Definitions”, RFC 6066, DOI 10.17487/RFC6066, January 2011, <a href="http://www.rfc-editor.org/info/rfc6066" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6066</a></li></ul></li><li>[RFC6749]<ul><li>Hardt, D., Ed., “The OAuth 2.0 Authorization Framework”, RFC 6749, DOI 10.17487/RFC6749, October 2012, <a href="http://www.rfc-editor.org/info/rfc6749" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6749</a></li></ul></li><li>[RFC6960]<ul><li>Santesson, S., Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, “X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP”, RFC 6960, DOI 10.17487/RFC6960, June 2013, <a href="http://www.rfc-editor.org/info/rfc6960" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6960</a></li></ul></li><li>[SARBANES]<ul><li>Sarbanes-Oxley Act of 2002.<br><a href="http://www.gpo.gov/fdsys/pkg/PLAW-107publ204/html/PLAW-107publ204.htm" target="_blank" rel="noopener">http://www.gpo.gov/fdsys/pkg/PLAW-107publ204/html/PLAW-107publ204.htm</a></li></ul></li><li>[USEUPRIVSH]<ul><li>U.S.-EU Privacy Shield Framework, <a href="https://www.privacyshield.gov/" target="_blank" rel="noopener">https://www.privacyshield.gov</a></li></ul></li><li>[RFC3986]<ul><li>Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax”, STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <a href="http://www.rfc-editor.org/info/rfc3986" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc3986</a></li></ul></li><li>[RFC1035]<ul><li>Mockapetris, P., “Domain names - implementation and specification”, STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987, <a href="http://www.rfc-editor.org/info/rfc1035" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc1035</a></li></ul></li><li>[RFC2782]<ul><li>Gulbrandsen, A., Vixie, P., and L. Esibov, “A DNS RR for specifying the location of services (DNS SRV)”, RFC 2782, DOI 10.17487/RFC2782, February 2000, <a href="http://www.rfc-editor.org/info/rfc2782" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc2782</a></li></ul></li></ul><h3 id="1-5-数据表示"><a href="#1-5-数据表示" class="headerlink" title="1.5 数据表示"></a>1.5 数据表示</h3><h4 id="1-5-1-二进制位"><a href="#1-5-1-二进制位" class="headerlink" title="1.5.1 二进制位"></a>1.5.1 二进制位</h4><p>字节中的位从0到7. <code>第7位</code>是<code>最高有效位</code>, <code>第0位</code>是<code>最低有效位</code>.</p><h4 id="1-5-2-双字节整数"><a href="#1-5-2-双字节整数" class="headerlink" title="1.5.2 双字节整数"></a>1.5.2 双字节整数</h4><p><code>双字节整数</code>是 16 位, 使用<code>大端序(big-endian, 高位字节在低位字节前面)</code>. 这意味着一个 16 位的字在网络上表示为最高有效字节(MSB), 后面跟着最低有效字节(LSB).</p><h4 id="1-5-3-四字节整数"><a href="#1-5-3-四字节整数" class="headerlink" title="1.5.3 四字节整数"></a>1.5.3 四字节整数</h4><p><code>四字节整数</code>是32位, 使用<code>大端序(big-endian, 高位字节在低位字节前面)</code>. 这意味着一个32位的字在网络上表示为第一个最高有效字节(MSB)后面跟着第一个最低有效字节(LSB), 再后面为第二个最高有效字节(MSB)后面跟着第二个最低有效字节(LSB).</p><h4 id="1-5-4-UTF-8-编码字符串"><a href="#1-5-4-UTF-8-编码字符串" class="headerlink" title="1.5.4 UTF-8 编码字符串"></a>1.5.4 UTF-8 编码字符串</h4><p>后续描述的MQTT控制报文中的文本字段编码为 <code>UTF-8 格式</code>的字符串. UTF-8 [RFC3629] 是一个高效的Unicode 字符编码格式, 为了支持基于文本的通信, 它对 ASCII 字符的编码做了优化.</p><p>每一个字符串都有一个两字节的长度字段作为前缀, 它给出这个字符串 UTF-8 编码的字节数, 它们在图1-1 UTF-8编码字符串的结构中描述. 因此可以传送的UTF-8编码的字符串大小有一个限制, <strong>不能</strong>超过65535字节.</p><p>除非另有说明, 所有的 UTF-8 编码字符串的长度都在 0 到 65535 字节这个范围内.</p><ul><li>图 1-1 UTF-8编码字符串的结构</li></ul><table><thead><tr><th align="left">二进制位</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">字符串长度的最高有效字节(MSB)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">字符串长度的最低有效字节(LSB)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 3 …</td><td align="left">如果长度大于0, 这里是UTF-8编码的字符数据</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li>UTF-8 编码字符串中的字符数据<strong>必须</strong>是按照Unicode 规范 [Unicode] 定义的和在RFC3629 [RFC3629]中重申的有效的UTF-8格式. 特别需要指出的是, 这些数据<strong>不能</strong>包含字符码在 U+D800 和 U+DFFF 之间的数据. 如果服务端或客户端收到了一个包含无效 <code>UTF-8</code> 字符的<code>MQTT控制报文</code>, 它<strong>必须</strong>关闭网络连接[MQTT-1.5.4-1].</li><li>UTF-8 编码的字符串<strong>不能</strong>包含空字符 U+0000[MQTT-1.5.4-2]. 如果客户端或服务端收到了一个包含 U+0000 的控制报文, 它<strong>必须</strong>关闭网络连接.</li><li>数据中<strong>不应该</strong>包含下面这些 Unicode 代码点的编码. 如果一个接收者(服务端或客户端)收到了包含下列任意字符的MQTT控制报文, 它<strong>可以</strong>把此报文当做无效报文.<ul><li>U+0001 和 U+001F 之间的控制字符</li><li>U+007F 和 U+009F 之间的控制字符</li><li>[Unicode] 规范定义的非字符代码点(例如U+0FFFF)</li></ul></li><li>UTF-8 编码序列 0XEF 0xBB 0xBF 总是被解释为 U+FEFF(零宽度非换行空白字符), 无论它出现在字符串的什么位置, 报文接收者都<strong>不能</strong>跳过或者剥离它 [MQTT-1.5.4-3].</li></ul><pre><code>- 非规范示例    例如, 字符串 `A𪛔` 是一个大写拉丁字母 A 后面跟着一个`代码点 U+2A6D4` (它表示一个中日韩统一表意文字扩展 B 中的字符), 这个字符串编码如下:</code></pre><ul><li>图1-2 UTF-8编码字符串非规范示例</li></ul><table><thead><tr><th align="left">bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">字符串长度MSB (0x00)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">字符串长度LSB (0x05)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left">‘A’ (0x41)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 4</td><td align="left">(0xF0)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 5</td><td align="left">(0xAA)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 6</td><td align="left">(0x9B)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 7</td><td align="left">(0x94)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h4 id="1-5-5-变长字节整数"><a href="#1-5-5-变长字节整数" class="headerlink" title="1.5.5 变长字节整数"></a>1.5.5 变长字节整数</h4><ul><li><code>剩余长度</code>字段使用一个变长字节编码方案, 对小于 128 的值它使用单字节编码. 更大的值按下面的方式处理. 低 7 位有效位用于编码数据, 最高有效位用于指示是否有更多的字节. 因此每个字节可以编码 128 个数值和一个延续位(continuation bit). <code>剩余长度</code>字段最大 4 个字节 [MQTT-1.5.5-1], 如表 1-1 所示.</li><li>表 1-1 变长字节整数大小</li></ul><table><thead><tr><th align="left">字节数</th><th align="left">最小值</th><th align="left">最大值</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0 (0x00)</td><td align="left">127 (0x7F)</td></tr><tr><td align="left">2</td><td align="left">128 (0x80, 0x01)</td><td align="left">16,383 (0xFF, 0x7F)</td></tr><tr><td align="left">3</td><td align="left">16,384 (0x80, 0x80, 0x01)</td><td align="left">2,097,151 (0xFF, 0xFF, 0x7F)</td></tr><tr><td align="left">4</td><td align="left">2,097,152 (0x80, 0x80, 0x80, 0x01)</td><td align="left">268,435,455 (0xFF, 0xFF, 0xFF, 0x7F)</td></tr></tbody></table><p>非规范评注<br>非负整数 X 使用变长编码方案的算法如下:</p><pre><code>    do    encodedByte = X MOD 128    X = X DIV 128    // if there are more data to encode, set the top bit of this byte    if (X &gt; 0)        encodedByte = encodedByte OR 128    endif    &#39;output&#39; encodedByte    while (X &gt; 0)MOD是模运算, DIV是整数除法, OR是位操作或(C语言中分别是%, /, |).- 非规范评注剩余长度字段的解码算法如下:</code></pre><pre><code>    multiplier = 1    value = 0    do    encodedByte = &#39;next byte from stream&#39;     value += (encodedByte AND 127) * multiplier    if (multiplier &gt; 128*128*128)        throw Error(Malformed Variable Byte Integer)    multiplier *= 128    while ((encodedByte AND 128) != 0)    AND 是位操作与(C 语言中的&amp;)    这个算法终止时, value 包含的就是剩余长度的值.</code></pre><h4 id="1-5-6-二进制数据"><a href="#1-5-6-二进制数据" class="headerlink" title="1.5.6 二进制数据"></a>1.5.6 二进制数据</h4><p>二进制数据由一个双字节整数指示其数据长度, 因此, 二进制数据的长度被限制为0到65,535字节.</p><h4 id="1-5-7-UTF-8字符串对"><a href="#1-5-7-UTF-8字符串对" class="headerlink" title="1.5.7 UTF-8字符串对"></a>1.5.7 UTF-8字符串对</h4><p><code>UTF-8字符串对</code>由两个UTF-8编码的字符串组成, 用来表示名字-值对, 第一个字符串表示名字, 第二个字符串表示值.</p><p>所有的字符串<strong>必须</strong>遵循<code>UTF-8字符串编码</code>规范 [MQTT-1.5.7-1]. 如果接受者(客户端或者服务端)接受到一个字符串对, 然而其编码并不遵循规范, 则此报文为无效报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>描述了错误处理的信息.</p><h3 id="1-6-安全"><a href="#1-6-安全" class="headerlink" title="1.6 安全"></a>1.6 安全</h3><p>MQTT客户端和服务端实现应该提供认证、授权和安全通信功能, 如 <a href="https://www.zybuluo.com/khan-lau/note/1325300#5-安全非规范" target="_blank" rel="noopener">第5章</a> 所描述. 强烈建议任何关注于个人身份信息或敏感信息的应用使用这些安全设施.</p><h3 id="1-7-编辑约定"><a href="#1-7-编辑约定" class="headerlink" title="1.7 编辑约定"></a>1.7 编辑约定</h3><p>本规范用蓝色文本标识一致性声明, 每个一致性声明都分配了一个这种格式的引用:[MQTT-x.x.x-y].</p><h3 id="1-8-变更历史"><a href="#1-8-变更历史" class="headerlink" title="1.8 变更历史"></a>1.8 变更历史</h3><h4 id="1-8-1-MQTT-v3-1-1"><a href="#1-8-1-MQTT-v3-1-1" class="headerlink" title="1.8.1 MQTT v3.1.1"></a>1.8.1 MQTT v3.1.1</h4><ul><li>MQTT v3.1.1 是首个OASIS标准版本MQTT [MQTTV311].</li><li>MQTT v3.1.1 也是ISO/IEC 20922:2016 [ISO20922] 标准.</li></ul><h4 id="1-8-2-MQTT-v5-0"><a href="#1-8-2-MQTT-v5-0" class="headerlink" title="1.8.2 MQTT v5.0"></a>1.8.2 MQTT v5.0</h4><ul><li>MQTT v5.0 在保持MQTT核心不变的基础上添加了大量的新功能. 这些功能的主要目标如下:<ul><li>进一步支持大规模可扩展系统</li><li>改进的错误报告Improved error reporting</li><li>规范化包括容量探索和请求响应在内的通用模式</li><li>包括用户属性在内的可扩展机制</li><li>改进性能并支持小型客户端</li></ul></li></ul><p><a href="https://www.zybuluo.com/khan-lau/note/1325300#appendix-c-mqtt-v50新特性总结非规范" target="_blank" rel="noopener">附录C</a>对MQTT v5.0的改进做出了总结.</p><h2 id="2-MQTT控制报文格式"><a href="#2-MQTT控制报文格式" class="headerlink" title="2 MQTT控制报文格式"></a>2 MQTT控制报文格式</h2><h3 id="2-1-MQTT控制报文结构"><a href="#2-1-MQTT控制报文结构" class="headerlink" title="2.1 MQTT控制报文结构"></a>2.1 MQTT控制报文结构</h3><p>MQTT协议通过交换预定义的 MQTT 控制报文来通信. 这一节描述这些报文的格式.</p><p>MQTT控制报文由三部分组成, 按照下图描述的顺序.</p><p>图 2 1 - MQTT控制报文的结构</p><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left">Fixed Header固定报头, 所有控制报文都包含</td></tr><tr><td align="left">Variable Header 可变报头, 部分控制报文包含</td></tr><tr><td align="left">Payload 有效载荷, 部分控制报文包含</td></tr></tbody></table><h4 id="2-1-1-固定报头"><a href="#2-1-1-固定报头" class="headerlink" title="2.1.1 固定报头"></a>2.1.1 固定报头</h4><p>如下图所示, 每个MQTT控制报文都包含一个固定报头.</p><ul><li>图 2-2 - 固定报头的格式</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文的类型</td><td align="left">用于指定控制报文类型的标志位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2…</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h4 id="2-1-2-MQTT控制报文的类型"><a href="#2-1-2-MQTT控制报文的类型" class="headerlink" title="2.1.2 MQTT控制报文的类型"></a>2.1.2 MQTT控制报文的类型</h4><p>位置:第<code>1</code>个字节, 二进制位<code>7-4</code>.<br>表示为4位无符号值, 这些值的定义见下表.</p><ul><li>表 2-1 - MQTT控制报文的类型</li></ul><table><thead><tr><th align="left">名字</th><th align="left">值</th><th align="left">报文流动方向</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Reserved</td><td align="left">0</td><td align="left">禁止</td><td align="left">保留</td></tr><tr><td align="left">CONNECT</td><td align="left">1</td><td align="left">客户端到服务端</td><td align="left">客户端请求连接服务端</td></tr><tr><td align="left">CONNACK</td><td align="left">2</td><td align="left">服务端到客户端</td><td align="left">连接报文确认</td></tr><tr><td align="left">PUBLISH</td><td align="left">3</td><td align="left">两个方向都允许</td><td align="left">发布消息</td></tr><tr><td align="left">PUBACK</td><td align="left">4</td><td align="left">两个方向都允许</td><td align="left"><code>QoS 1</code> 消息发布收到确认</td></tr><tr><td align="left">PUBREC</td><td align="left">5</td><td align="left">两个方向都允许</td><td align="left">发布收到(保证交付第一步)</td></tr><tr><td align="left">PUBREL</td><td align="left">6</td><td align="left">两个方向都允许</td><td align="left">发布释放(保证交付第二步)</td></tr><tr><td align="left">PUBCOMP</td><td align="left">7</td><td align="left">两个方向都允许</td><td align="left"><code>QoS 2</code> 消息发布完成(保证交付第三步)</td></tr><tr><td align="left">SUBSCRIBE</td><td align="left">8</td><td align="left">客户端到服务端</td><td align="left">客户端订阅请求</td></tr><tr><td align="left">SUBACK</td><td align="left">9</td><td align="left">服务端到客户端</td><td align="left">订阅请求报文确认</td></tr><tr><td align="left">UNSUBSCRIBE</td><td align="left">10</td><td align="left">客户端到服务端</td><td align="left">客户端取消订阅请求</td></tr><tr><td align="left">UNSUBACK</td><td align="left">11</td><td align="left">服务端到客户端</td><td align="left">取消订阅报文确认</td></tr><tr><td align="left">PINGREQ</td><td align="left">12</td><td align="left">客户端到服务端</td><td align="left">心跳请求</td></tr><tr><td align="left">PINGRESP</td><td align="left">13</td><td align="left">服务端到客户端</td><td align="left">心跳响应</td></tr><tr><td align="left">DISCONNECT</td><td align="left">14</td><td align="left">两个方向都允许</td><td align="left">断开连接通知</td></tr><tr><td align="left">AUTH</td><td align="left">15</td><td align="left">两个方向都允许</td><td align="left">认证信息交换</td></tr></tbody></table><h4 id="2-1-3-标志"><a href="#2-1-3-标志" class="headerlink" title="2.1.3 标志"></a>2.1.3 标志</h4><p>固定报头第1个字节的剩余的 4 位 [3-0]包含每个 MQTT 控制报文类型特定的标志如下表所示. 表格中任何标记为“保留”的标志位, 都是保留给以后使用的, <strong>必须</strong>设置为表格中列出的值 [MQTT-2.1.3-1]. 如果收到非法的标志, 此报文被当做无效报文. 有关错误处理的详细信息见<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p><ul><li>表格 2-2 - 标志位</li></ul><table><thead><tr><th align="left">MQTT控制报文</th><th align="left">固定报头标志</th><th align="left">Bit 3</th><th align="left">Bit 2</th><th align="left">Bit 1</th><th align="left">Bit 0</th></tr></thead><tbody><tr><td align="left">CONNECT</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">CONNACK</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PUBLISH</td><td align="left">Used in MQTT v5.0</td><td align="left">DUP</td><td align="left">QOS</td><td align="left">RETAIN</td><td align="left"></td></tr><tr><td align="left">PUBACK</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PUBREC</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PUBREL</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">PUBCOMP</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">SUBSCRIBE</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">SUBACK</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">UNSUBSCRIBE</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">UNSUBACK</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PINGREQ</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">PINGRESP</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">DISCONNECT</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">AUTH</td><td align="left">Reserved</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><ul><li>DUP = PUBLISH报文的重复分发标志</li><li>QoS = PUBLISH报文的服务质量等级</li><li>RETAIN = PUBLISH报文的保留标志</li><li>PUBLISH报文中的DUP、QoS和RETAIN标志的描述见<a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">3.3.1节</a>.</li></ul><h4 id="2-1-4-剩余长度"><a href="#2-1-4-剩余长度" class="headerlink" title="2.1.4 剩余长度"></a>2.1.4 剩余长度</h4><p>位置:从第 2 个字节开始.</p><p><code>剩余长度(Remaining Length)</code>是一个变长字节整数, 用来表示当前控制报文剩余部分的字节数, 包括可变报头和负载的数据. 剩余长度不包括用于编码剩余长度字段本身的字节数. MQTT控制报文总长度等于固定报头的长度加上剩余长度.</p><h3 id="2-2-可变报头"><a href="#2-2-可变报头" class="headerlink" title="2.2 可变报头"></a>2.2 可变报头</h3><p>某些MQTT控制报文包含一个可变报头部分. 它在固定报头和有效载荷之间. 可变报头的内容根据报文类型的不同而不同. 可变报头的<code>报文标识符(Packet Identifier)</code>字段存在于在多个类型的报文里.</p><h4 id="2-2-1-报文标识符"><a href="#2-2-1-报文标识符" class="headerlink" title="2.2.1 报文标识符"></a>2.2.1 报文标识符</h4><p>部分类型MQTT控制报文的可变报头部分包含了2个字节的报文标识符字段. 这些MQTT控制报文类型为:<code>PUBLISH</code>报文(当QoS&gt;0时), <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBSCRIBE</code>, <code>SUBACK</code>, <code>UNSUBSCRIBE</code>, <code>UNSUBACK.</code></p><p>需要报文标识符的MQTT控制报文如下表所示.</p><ul><li>表 2-3 包含报文标识符的MQTT控制报文</li></ul><table><thead><tr><th align="left">MQTT控制报文</th><th align="left">报文标识符字段</th></tr></thead><tbody><tr><td align="left">CONNECT</td><td align="left">不需要</td></tr><tr><td align="left">CONNACK</td><td align="left">不需要</td></tr><tr><td align="left">PUBLISH</td><td align="left">需要(如果QoS &gt; 0)</td></tr><tr><td align="left">PUBACK</td><td align="left">需要</td></tr><tr><td align="left">PUBREC</td><td align="left">需要</td></tr><tr><td align="left">PUBREL</td><td align="left">需要</td></tr><tr><td align="left">PUBCOMP</td><td align="left">需要</td></tr><tr><td align="left">SUBSCRIBE</td><td align="left">需要</td></tr><tr><td align="left">SUBACK</td><td align="left">需要</td></tr><tr><td align="left">UNSUBSCRIBE</td><td align="left">需要</td></tr><tr><td align="left">UNSUBACK</td><td align="left">需要</td></tr><tr><td align="left">PINGREQ</td><td align="left">不需要</td></tr><tr><td align="left">PINGRESP</td><td align="left">不需要</td></tr><tr><td align="left">DISCONNECT</td><td align="left">不需要</td></tr><tr><td align="left">AUTH</td><td align="left">不需要</td></tr></tbody></table><p>- <code>QoS</code>设置为0的<code>PUBLISH</code>报文<strong>不能</strong>包含报文标识符[MQTT-2.2.1-2].</p><ul><li>客户端每次发送一个新的SUBSCRIBE, <code>UNSUBSCRIBE</code>或者<code>PUBLISH</code>(当QoS&gt;0时)MQTT控制报文时都<strong>必须</strong>分配一个当前未使用的非零报文标识符 [MQTT-2.2.1-3].</li><li>服务端每次发送一个新的PUBLISH(当QoS&gt;0)MQTT控制报文时都<strong>必须</strong>分配一个当前未使用的非零报文标识符 [MQTT-2.2.1-4].</li><li>当客户端处理完这个报文对应的确认后, 这个报文标识符就释放可重用. <code>QoS 1</code>的<code>PUBLISH</code>对应的是<code>PUBACK</code>, <code>QoS 2</code>的<code>PUBLISH</code>对应的是包含原因码128以上的<code>PUBCOMP</code>或<code>PUBREC</code>, 与<code>SUBSCRIBE</code>或<code>UNSUBSCRIBE</code>对应的分别是<code>SUBACK</code>或<code>UNSUBACK</code>.</li><li><code>PUBLISH</code>, <code>SUBSCRIBE</code>和<code>UNSUBSCRIBE</code>的报文标识符, 在一次会话中对于客户端和服务端来说分属于不同的组. 某个报文标识符在某一时刻<strong>不能</strong>被多个命令所使用.</li><li><code>PUBACK</code>, <code>PUBREC</code>和<code>PUBREL</code>报文<strong>必须</strong>包含与最初发送的<code>PUBLISH</code>报文相同的报文标识符 [MQTT-2.2.1-5]. 类似地, <code>SUBACK</code>和<code>UNSUBACK</code> <strong>必须</strong> 包含在对应的<code>SUBSCRIBE</code>和<code>UNSUBSCRIBE</code>报文中使用的报文标识符 [MQTT-2.2.1-6].</li></ul><p>客户端和服务端彼此独立地分配报文标识符. 因此, 客户端服务端组合使用相同的报文标识符可以实现并发的消息交换.</p><pre><code>非规范评注客户端发送标识符为 0x1234 的`PUBLISH`报文, 它有可能会在收到那个报文的`PUBACK`之前, 先收到服务端发送的另一个不同的但是报文标识符也为0x1234的`PUBLISH` 报文.</code></pre><table><thead><tr><th align="left">客户端</th><th align="left">服务端</th></tr></thead><tbody><tr><td align="left">PUBLISH报文标识符 = 0x1234 —-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&lt;—- PUBLISH报文标识符 = 0x1234</td></tr><tr><td align="left">PUBACK报文标识符 = 0x1234 —-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&lt;—- PUBACK报文标识符 = 0x1234</td></tr></tbody></table><h4 id="2-2-2-属性"><a href="#2-2-2-属性" class="headerlink" title="2.2.2 属性"></a>2.2.2 属性</h4><p><code>CONNECT</code>, <code>CONNACK</code>, <code>PUBLISH</code>, <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBSCRIBE</code>, <code>SUBACK</code>, <code>UNSUBACK</code>, <code>DISCONNECT</code> 和 <code>AUTH</code> 报文可变报头的最后一部分是一组属性. <code>CONNECT</code> 报文的<code>遗嘱(Will)</code>属性字段中也包含了一组可选的属性.</p><p><code>属性字段</code>由<code>属性长度</code>和<code>所有属性</code>组成.</p><h5 id="2-2-2-1-属性长度"><a href="#2-2-2-1-属性长度" class="headerlink" title="2.2.2.1 属性长度"></a>2.2.2.1 属性长度</h5><p>属性长度被编码为变长字节整数. 属性长度不包含用于编码属性长度自身的字节数, 但包含所有属性的长度. 如果没有任何属性, <strong>必须</strong>由属性长度为零的字段来指示 [MQTT-2.2.2-1].</p><h5 id="2-2-2-2-属性"><a href="#2-2-2-2-属性" class="headerlink" title="2.2.2.2 属性"></a>2.2.2.2 属性</h5><h5 id="2-2-2-2-属性-1"><a href="#2-2-2-2-属性-1" class="headerlink" title="2.2.2.2 属性"></a>2.2.2.2 属性</h5><p>一个属性包含一段数据和一个定义了属性用途和数据类型的标识符. 标识符被编码为<code>变长字节整数</code>. 任何控制报文, 如果包含了对于该报文类型无效的标识符, 或者错误类型的数据, 都是无效报文. 收到无效报文时, 服务端或客户端使用包含原因码<code>0x81(无效报文)</code> <code>CONNACK</code>或<code>DISCONNECT</code>报文进行错误处理, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 标识符排序不分先后.</p><ul><li>表 2-4 属性</li></ul><table><thead><tr><th align="left">标识符</th><th align="left">属性名(用途)</th><th align="left">数据类型</th><th align="left">报文/遗嘱属性</th><th></th></tr></thead><tbody><tr><td align="left">DEC</td><td align="left">HEX</td><td align="left"></td><td align="left"></td><td></td></tr><tr><td align="left">1</td><td align="left">0x01</td><td align="left">载荷格式说明</td><td align="left">字节</td><td>PUBLISH, Will Properties</td></tr><tr><td align="left">2</td><td align="left">0x02</td><td align="left">消息过期时间</td><td align="left">四字节整数</td><td>PUBLISH, Will Properties</td></tr><tr><td align="left">3</td><td align="left">0x03</td><td align="left">内容类型</td><td align="left">UTF-8编码字符串</td><td>PUBLISH, Will Properties</td></tr><tr><td align="left">8</td><td align="left">0x08</td><td align="left">响应主题</td><td align="left">UTF-8编码字符串</td><td>PUBLISH, Will Properties</td></tr><tr><td align="left">9</td><td align="left">0x09</td><td align="left">相关数据</td><td align="left">二进制数据</td><td>PUBLISH, Will Properties</td></tr><tr><td align="left">11</td><td align="left">0x0B</td><td align="left">定义标识符</td><td align="left">变长字节整数</td><td>PUBLISH, SUBSCRIBE</td></tr><tr><td align="left">17</td><td align="left">0x11</td><td align="left">会话过期间隔</td><td align="left">四字节整数</td><td>CONNECT, CONNACK, DISCONNECT</td></tr><tr><td align="left">18</td><td align="left">0x12</td><td align="left">分配客户标识符</td><td align="left">UTF-8编码字符串</td><td>CONNACK</td></tr><tr><td align="left">19</td><td align="left">0x13</td><td align="left">服务端保活时间</td><td align="left">双字节整数</td><td>CONNACK</td></tr><tr><td align="left">21</td><td align="left">0x15</td><td align="left">认证方法</td><td align="left">UTF-8编码字符串</td><td>CONNECT, CONNACK, AUTH</td></tr><tr><td align="left">22</td><td align="left">0x16</td><td align="left">认证数据</td><td align="left">二进制数据</td><td>CONNECT, CONNACK, AUTH</td></tr><tr><td align="left">23</td><td align="left">0x17</td><td align="left">请求问题信息</td><td align="left">字节</td><td>CONNECT</td></tr><tr><td align="left">24</td><td align="left">0x18</td><td align="left">遗嘱延时间隔</td><td align="left">四字节整数</td><td>Will Properties</td></tr><tr><td align="left">25</td><td align="left">0x19</td><td align="left">请求响应信息</td><td align="left">字节</td><td>CONNECT</td></tr><tr><td align="left">26</td><td align="left">0x1A</td><td align="left">请求信息</td><td align="left">UTF-8编码字符串</td><td>CONNACK</td></tr><tr><td align="left">28</td><td align="left">0x1C</td><td align="left">服务端参考</td><td align="left">UTF-8编码字符串</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">31</td><td align="left">0x1F</td><td align="left">原因字符串</td><td align="left">UTF-8编码字符串</td><td>CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, UNSUBACK, DISCONNECT, AUTH</td></tr><tr><td align="left">33</td><td align="left">0x21</td><td align="left">接收最大数量</td><td align="left">双字节整数</td><td>CONNECT, CONNACK</td></tr><tr><td align="left">34</td><td align="left">0x22</td><td align="left">主题别名最大长度</td><td align="left">双字节整数</td><td>CONNECT, CONNACK</td></tr><tr><td align="left">35</td><td align="left">0x23</td><td align="left">主题别名</td><td align="left">双字节整数</td><td>PUBLISH</td></tr><tr><td align="left">36</td><td align="left">0x24</td><td align="left">最大QoS</td><td align="left">字节</td><td>CONNACK</td></tr><tr><td align="left">38</td><td align="left">0x26</td><td align="left">用户属性</td><td align="left">UTF-8字符串对</td><td>CONNECT, CONNACK, PUBLISH, Will Properties, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK, DISCONNECT, AUTH</td></tr><tr><td align="left">39</td><td align="left">0x27</td><td align="left">最大报文长度</td><td align="left">四字节整数</td><td>CONNECT, CONNACK</td></tr><tr><td align="left">40</td><td align="left">0x28</td><td align="left">通配符订阅可用性</td><td align="left">字节</td><td>CONNACK</td></tr><tr><td align="left">41</td><td align="left">0x29</td><td align="left">订阅标识符可用性</td><td align="left">字节</td><td>CONNACK</td></tr><tr><td align="left">42</td><td align="left">0x2A</td><td align="left">共享订阅可用性</td><td align="left">字节</td><td>CONNACK</td></tr></tbody></table><pre><code>非规范评注尽管属性标识符用变长字节整数来表示, 但在此版本协议中, 所有的标识符均由一个字节来表示.</code></pre><h3 id="2-3-有效载荷"><a href="#2-3-有效载荷" class="headerlink" title="2.3 有效载荷"></a>2.3 有效载荷</h3><p>某些MQTT控制报文在报文的最后部分包含一个有效载荷, 这将在<a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章</a>论述. 对于 <code>PUBLISH</code> 来说有效载荷就是应用消息.</p><p>表 2-5 包含有效载荷的MQTT控制报文</p><table><thead><tr><th align="left">MQTT控制报文</th><th align="left">有效载荷</th></tr></thead><tbody><tr><td align="left">CONNECT</td><td align="left">需要</td></tr><tr><td align="left">CONNACK</td><td align="left">不需要</td></tr><tr><td align="left">PUBLISH</td><td align="left">可选</td></tr><tr><td align="left">PUBACK</td><td align="left">不需要</td></tr><tr><td align="left">PUBREC</td><td align="left">不需要</td></tr><tr><td align="left">PUBREL</td><td align="left">不需要</td></tr><tr><td align="left">PUBCOMP</td><td align="left">不需要</td></tr><tr><td align="left">SUBSCRIBE</td><td align="left">需要</td></tr><tr><td align="left">SUBACK</td><td align="left">需要</td></tr><tr><td align="left">UNSUBSCRIBE</td><td align="left">需要</td></tr><tr><td align="left">UNSUBACK</td><td align="left">需要</td></tr><tr><td align="left">PINGREQ</td><td align="left">不需要</td></tr><tr><td align="left">PINGRESP</td><td align="left">不需要</td></tr><tr><td align="left">DISCONNECT</td><td align="left">不需要</td></tr><tr><td align="left">AUTH</td><td align="left">不需要</td></tr></tbody></table><h3 id="2-4-原因码"><a href="#2-4-原因码" class="headerlink" title="2.4 原因码"></a>2.4 原因码</h3><p>原因码是一个单字节无符号数, 用来指示一次操作的结果. 小于0x80的原因码指示某次操作成功完成, 通常用0来表示. 大于等于0x80的原因码用来指示操作失败.</p><p><code>CONNACK</code>, <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>DISCONNECT</code> 和 <code>AUTH</code> 控制报文的可变报头有一个单字节的原因码. <code>SUBACK</code>和<code>UNSUBACK</code>报文的载荷字段包含一个或多个原因码.</p><p>原因码如下表所示.</p><ul><li>表 2-6 原因码</li></ul><table><thead><tr><th align="left">原因码</th><th align="left">名称</th><th align="left">报文</th><th></th></tr></thead><tbody><tr><td align="left">DEC</td><td align="left">HEX</td><td align="left"></td><td></td></tr><tr><td align="left">0</td><td align="left">0x00</td><td align="left">成功</td><td>CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, UNSUBACK, AUTH</td></tr><tr><td align="left">0</td><td align="left">0x00</td><td align="left">正常断开</td><td>DISCONNECT</td></tr><tr><td align="left">0</td><td align="left">0x00</td><td align="left">授权的QoS 0</td><td>SUBACK</td></tr><tr><td align="left">1</td><td align="left">0x01</td><td align="left">授权的QoS 1</td><td>SUBACK</td></tr><tr><td align="left">2</td><td align="left">0x02</td><td align="left">授权的QoS 2</td><td>SUBACK</td></tr><tr><td align="left">4</td><td align="left">0x04</td><td align="left">包含遗嘱的断开</td><td>DISCONNECT</td></tr><tr><td align="left">16</td><td align="left">0x10</td><td align="left">无匹配订阅</td><td>PUBACK, PUBREC</td></tr><tr><td align="left">17</td><td align="left">0x11</td><td align="left">订阅不存在</td><td>UNSUBACK</td></tr><tr><td align="left">24</td><td align="left">0x18</td><td align="left">继续认证</td><td>AUTH</td></tr><tr><td align="left">25</td><td align="left">0x19</td><td align="left">重新认证</td><td>AUTH</td></tr><tr><td align="left">128</td><td align="left">0x80</td><td align="left">未指明的错误</td><td>CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT</td></tr><tr><td align="left">129</td><td align="left">0x81</td><td align="left">无效报文</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">130</td><td align="left">0x82</td><td align="left">协议错误</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">131</td><td align="left">0x83</td><td align="left">实现错误</td><td>CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT</td></tr><tr><td align="left">132</td><td align="left">0x84</td><td align="left">协议版本不支持</td><td>CONNACK</td></tr><tr><td align="left">133</td><td align="left">0x85</td><td align="left">客户标识符无效</td><td>CONNACK</td></tr><tr><td align="left">134</td><td align="left">0x86</td><td align="left">用户名密码错误</td><td>CONNACK</td></tr><tr><td align="left">135</td><td align="left">0x87</td><td align="left">未授权</td><td>CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT</td></tr><tr><td align="left">136</td><td align="left">0x88</td><td align="left">服务端不可用</td><td>CONNACK</td></tr><tr><td align="left">137</td><td align="left">0x89</td><td align="left">服务端正忙</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">138</td><td align="left">0x8A</td><td align="left">禁止</td><td>CONNACK</td></tr><tr><td align="left">139</td><td align="left">0x8B</td><td align="left">服务端关闭中</td><td>DISCONNECT</td></tr><tr><td align="left">140</td><td align="left">0x8C</td><td align="left">无效的认证方法</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">141</td><td align="left">0x8D</td><td align="left">保活超时</td><td>DISCONNECT</td></tr><tr><td align="left">142</td><td align="left">0x8E</td><td align="left">会话被接管</td><td>DISCONNECT</td></tr><tr><td align="left">143</td><td align="left">0x8F</td><td align="left">主题过滤器无效</td><td>SUBACK, UNSUBACK, DISCONNECT</td></tr><tr><td align="left">144</td><td align="left">0x90</td><td align="left">主题名无效</td><td>CONNACK, PUBACK, PUBREC, DISCONNECT</td></tr><tr><td align="left">145</td><td align="left">0x91</td><td align="left">报文标识符已被占用</td><td>PUBACK, PUBREC, SUBACK, UNSUBACK</td></tr><tr><td align="left">146</td><td align="left">0x92</td><td align="left">报文标识符无效</td><td>PUBREL, PUBCOMP</td></tr><tr><td align="left">147</td><td align="left">0x93</td><td align="left">接收超出最大数量</td><td>DISCONNECT</td></tr><tr><td align="left">148</td><td align="left">0x94</td><td align="left">主题别名无效</td><td>DISCONNECT</td></tr><tr><td align="left">149</td><td align="left">0x95</td><td align="left">报文过长</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">150</td><td align="left">0x96</td><td align="left">消息太过频繁</td><td>DISCONNECT</td></tr><tr><td align="left">151</td><td align="left">0x97</td><td align="left">超出配额</td><td>CONNACK, PUBACK, PUBREC, SUBACK, DISCONNECT</td></tr><tr><td align="left">152</td><td align="left">0x98</td><td align="left">管理行为</td><td>DISCONNECT</td></tr><tr><td align="left">153</td><td align="left">0x99</td><td align="left">载荷格式无效</td><td>CONNACK, PUBACK, PUBREC, DISCONNECT</td></tr><tr><td align="left">154</td><td align="left">0x9A</td><td align="left">不支持保留</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">155</td><td align="left">0x9B</td><td align="left">不支持的QoS等级</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">156</td><td align="left">0x9C</td><td align="left">(临时)使用其他服务端</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">157</td><td align="left">0x9D</td><td align="left">服务端已(永久)移动</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">158</td><td align="left">0x9E</td><td align="left">不支持共享订阅</td><td>SUBACK, DISCONNECT</td></tr><tr><td align="left">159</td><td align="left">0x9F</td><td align="left">超出连接速率限制</td><td>CONNACK, DISCONNECT</td></tr><tr><td align="left">160</td><td align="left">0xA0</td><td align="left">最大连接时间</td><td>DISCONNECT</td></tr><tr><td align="left">161</td><td align="left">0xA1</td><td align="left">不支持订阅标识符</td><td>SUBACK, DISCONNECT</td></tr><tr><td align="left">162</td><td align="left">0xA2</td><td align="left">不支持通配符订阅</td><td>SUBACK, DISCONNECT</td></tr></tbody></table><pre><code>非规范评注对于原因码0x91(报文标识符已被占用)的处理可以为尝试修复会话、以新会话标志为1重置会话或者判定客户端或服务端实现有缺陷.</code></pre><h2 id="3-MQTT控制报文"><a href="#3-MQTT控制报文" class="headerlink" title="3 MQTT控制报文"></a>3 MQTT控制报文</h2><h3 id="3-1-CONNECT-–-连接请求"><a href="#3-1-CONNECT-–-连接请求" class="headerlink" title="3.1 CONNECT – 连接请求"></a>3.1 CONNECT – 连接请求</h3><p>客户端到服务端的网络连接建立后, 客户端发给服务端的第一个报文<strong>必须</strong>是CONNECT报文 [MQTT-3.1.0-1].</p><p>在一个网络连接上, 客户端只能发送一次 <code>CONNECT</code> 报文. 服务端<strong>必须</strong>将客户端发送的第二个 <code>CONNECT</code>报文当作协议违规处理并断开客户端的连接[MQTT-3.1.0-2]. 有关错误处理的信息请查看<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p><p>有效载荷包含一个或多个编码的字段. 包括客户端的唯一标识符, Will 主题, Will 消息, 用户名和密码. 除了客户端标识之外, 其它的字段都是可选的, 基于标志位来决定可变报头中是否需要包含这些字段.</p><h4 id="3-1-1-CONNECT固定报头"><a href="#3-1-1-CONNECT固定报头" class="headerlink" title="3.1.1 CONNECT固定报头"></a>3.1.1 CONNECT固定报头</h4><ul><li>图 3-1 CONNECT报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT 报文类型 (1)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2…</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><pre><code>剩余长度字段剩余长度等于可变报头的长度加上有效载荷的长度.编码方式为变长字节整数.</code></pre><h4 id="3-1-2-CONNECT可变报头"><a href="#3-1-2-CONNECT可变报头" class="headerlink" title="3.1.2 CONNECT可变报头"></a>3.1.2 CONNECT可变报头</h4><p>CONNECT 报文的可变报头按下列次序包含四个字段:<code>协议名(Protocol Name)</code>, <code>协议级别(Protocol Level)</code>, <code>连接标志(Connect Flags)</code>, <code>保持连接(Keep Alive)</code>和<code>属性(Properties)</code>. <a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 描述了属性(Properties)编码规则.</p><h5 id="3-1-2-1-协议名"><a href="#3-1-2-1-协议名" class="headerlink" title="3.1.2.1 协议名"></a>3.1.2.1 协议名</h5><p>图 3 2 - 协议名字节</p><table><thead><tr><th align="left"></th><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">协议名</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">长度MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">长度 LSB (4)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 3</td><td align="left"><code>M</code></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 4</td><td align="left"><code>Q</code></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 5</td><td align="left"><code>T</code></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 6</td><td align="left"><code>T</code></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><p>协议名是表示协议名MQTT 的UTF-8编码的字符串. MQTT规范的后续版本不会改变这个字符串的偏移和长度.</p><p>支持多种协议的服务端使用协议名字段判断数据是否为MQTT报文. 协议名<strong>必须</strong>是UTF-8字符串“MQTT”. 如果服务端不愿意接受<code>CONNECT</code>但希望表明其MQTT服务端身份, <strong>可以</strong>发送包含原因码为0x84(不支持的协议版本)的<code>CONNACK</code>报文, 然后<strong>必须</strong>关闭网络连接 [MQTT-3.1.2-1].</p><pre><code>非规范评注数据包检测工具, 例如防火墙, 可以使用协议名来识别 MQTT 流量.</code></pre><h5 id="3-1-2-2-协议版本"><a href="#3-1-2-2-协议版本" class="headerlink" title="3.1.2.2 协议版本"></a>3.1.2.2 协议版本</h5><ul><li>图 3-3 协议版本字节</li></ul><table><thead><tr><th align="left"></th><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">协议级别</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">版本(5)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr></tbody></table><p>客户端使用一个字节无符号数表示协议修订级别.MQTT v5.0的协议版本字段为5(0x05).</p><p>支持多版本MQTT协议的服务端使用协议版本 字段判定客户端正使用的MQTT协议版本. 如果协议版本不是5且服务端不愿意接受此<code>CONNECT</code>报文, <strong>可以</strong>发送包含原因码<code>0x84(不支持的协议版本)</code>的<code>CONNACK</code>报文, 然后<strong>必须</strong>关闭网络连接[MQTT-3.1.2-2].</p><h5 id="3-1-2-3-连接标志"><a href="#3-1-2-3-连接标志" class="headerlink" title="3.1.2.3 连接标志"></a>3.1.2.3 连接标志</h5><p>连接标志字节包含一些用于指定 MQTT 连接行为的参数. 它还指出有效载荷中的字段是否存在.<br>- 图 3-4 连接标志位</p><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left"></td><td align="left">User Name Flag</td><td align="left">Password Flag</td><td align="left">Will Retain</td><td align="left">Will QoS</td><td align="left">Clean Start</td><td align="left">Reserved</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 8</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">0</td></tr></tbody></table><p>服务端<strong>必须</strong>验证CONNECT报文的保留标志位(第 0 位)是否为 0 [MQTT-3.1.2-3], 如果不为0则此报文为无效报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 给出了错误处理信息.</p><h5 id="3-1-2-4-新开始"><a href="#3-1-2-4-新开始" class="headerlink" title="3.1.2.4 新开始"></a>3.1.2.4 新开始</h5><p>位置:连接标志字节的第1位</p><p>这个二进制位表明此次连接是一个新的会话还是一个已存在的会话的延续. <a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a> 定义了会话状态.</p><p>如果收到<code>新开始(Clean Start)</code>为1的<code>CONNECT</code>报文, 客户端和服务端必须丢弃任何已存在的会话, 并开始一个新的会话 [MQTT-3.1.2-4]. 相应的, <code>CONNACK</code>报文中的会话存在标志设置为0.</p><p>如果收到<code>新开始(Clean Start)</code>为0的<code>CONNECT</code>报文, 并且存在一个关联此客户标识符的会话, 服务端必须基于此会话的状态恢复与客户端的通信 [MQTT-3.1.2-5]. 如果收到<code>新开始(Clean Start)</code>为0的<code>CONNECT</code>报文, 并且不存在任何关联此客户标识符的会话, 服务端必须创建一个新的会话 [MQTT-3.1.2-6].</p><h5 id="3-1-2-5-遗嘱标志"><a href="#3-1-2-5-遗嘱标志" class="headerlink" title="3.1.2.5 遗嘱标志"></a>3.1.2.5 遗嘱标志</h5><p>位置:连接标志字节的第2位</p><p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, 表示遗嘱消息必须已存储在服务端与此客户标识符相关的会话中[MQTT-3.1.2-7]. <code>遗嘱消息(Will Message)</code>包含遗嘱属性, 遗嘱主题和遗嘱载荷字段. 遗嘱必须在网络连接被关闭、遗嘱延时间隔到期或者会话结束之后被发布, 除非服务端收到包含原因码为<code>0x00(正常关闭)</code>的<code>DISCONNECT</code>报文之后删除了<code>遗嘱消息(Will Message)</code>, 或者一个关于此客户标识符的新的网络连接在<code>遗嘱迟发时间(Will Delay Interval)</code>超时之前被创建 [MQTT-3.1.2-8].<br>- 遗嘱发布的条件, 包括但不限于:<br>- 服务端检测到了一个 I/O 错误或者网络故障<br>- 客户端在保持连接(Keep Alive)的时间内未能通讯<br>- 客户端在没有发送包含原因码0x00(正常关闭)的情况下关闭了网络连接<br>- 服务端在没有收到包含原因码0x00(正常关闭)的情况下关闭了网络连接</p><p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, <code>遗嘱属性(Will Property)</code>、<code>遗嘱主题(Will Topic)</code>和<code>遗嘱载荷(Will Payload)</code>字段必须存在于报文有效载荷中 [MQTT-3.1.2-9]. 一旦<code>遗嘱消息(Will Message)</code>被发布或者服务端收到包含原因码为<code>0x00(正常关闭)</code>的<code>DISCONNECT</code>报文, <code>遗嘱消息(Will Message)</code>必须从服务端的会话中删除 [MQTT-3.1.2-10].</p><p>服务端应该在网络连接断开并且<code>遗嘱迟发时间(Will Delay Interval)</code>到期, 或者会话结束之后立即发<code>布遗嘱消息</code>. 服务端关闭或出错的情况下, 可以在服务重新启动之后发布<code>遗嘱消息(Will Message)</code>. 这种情况下从服务端出错到遗嘱发布之间存在一定的延迟.</p><p>关于<code>遗嘱延时间隔(Will Delay Interval)</code>的详细信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3132-遗嘱属性" target="_blank" rel="noopener">3.1.3.2节</a>.</p><p>非规范评注<br>通过设置晚于<code>会话过期间隔(Session Expiry Interval)</code>的<code>遗嘱迟发时间(Will Delay Interval)</code>并发送包含原因码<code>0x04(包含遗嘱的断开连接)</code>, 客户端得以发出<code>会话过期(Session Expiry)</code>通告.</p><h5 id="3-1-2-6-遗嘱QoS"><a href="#3-1-2-6-遗嘱QoS" class="headerlink" title="3.1.2.6 遗嘱QoS"></a>3.1.2.6 遗嘱QoS</h5><p>位置:连接标志字节的第3、4位</p><p>这两个比特指定了发布<code>遗嘱消息(Will Message)</code>时的<code>服务质量(QoS)</code>.</p><p>如果<code>遗嘱标志(Will Flag)</code>设置为0, <code>遗嘱服务质量(Will QoS)</code>必须也设置为0(0x00) [MQTT-3.1.2-11].<br>如果<code>遗嘱标志</code>设置为1, <code>遗嘱服务质量</code> <strong>可以</strong>被设置为0(0x00), 1(0x01)或2(0x02) [MQTT-3.1.2-12]. 设置为3(0x03)的报文是无效报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 描述了错误处理信息.</p><h5 id="3-1-2-7-遗嘱保留"><a href="#3-1-2-7-遗嘱保留" class="headerlink" title="3.1.2.7 遗嘱保留"></a>3.1.2.7 遗嘱保留</h5><p>位置:连接标志字节的第5位</p><p>此位指<code>定遗嘱消息(Will Message)</code>在发布时是否会被保留.</p><p>如果<code>遗嘱标志</code>被设置为0, <code>遗嘱保留(Will Retain)</code>标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-13]. 如果<code>遗嘱标志</code>被设置为1时, 如果<code>遗嘱保留</code>被设置为0, 则服务端<strong>必须</strong>将<code>遗嘱消息</code>当做<code>非保留消息</code>发布 [MQTT-3.1.2-14]. 如果<code>遗嘱保留</code>被设置为1, 则服务端<strong>必须</strong>将<code>遗嘱消息</code>当做<code>保留消息</code>发布 [MQTT-3.1.2-15].</p><h5 id="3-1-2-8-用户名标志"><a href="#3-1-2-8-用户名标志" class="headerlink" title="3.1.2.8 用户名标志"></a>3.1.2.8 用户名标志</h5><p>位置:连接标志字节的第7位</p><p>如果<code>用户名标志(User Name Flag)</code>被设置为0, 有效载荷中<strong>不能</strong>包含用户名字段 [MQTT-3.1.2-16]. 如果<code>用户名标志</code>被设置为0, 有效载荷中<strong>必须</strong>包含用户名字段 [MQTT-3.1.2-17].</p><h5 id="3-1-2-9-密码标志"><a href="#3-1-2-9-密码标志" class="headerlink" title="3.1.2.9 密码标志"></a>3.1.2.9 密码标志</h5><p>位置:连接标志字节的第6位</p><p>如果<code>密码标志(Password Flag)</code>被设置为0, 有效载荷中<strong>不能</strong>包含密码字段 [MQTT-3.1.2-18]. 如果<code>密码标志</code>被设置为1, 有效载荷中<strong>必须</strong>包含密码字段 [MQTT-3.1.2-19].</p><pre><code>非规范评注相比MQTT v3.1.1, 此版本协议允许在没有用户名的情况下发送密码.  这表明密码除了作为口令之外还可以有其他用途.</code></pre><h5 id="3-1-2-10-保持连接"><a href="#3-1-2-10-保持连接" class="headerlink" title="3.1.2.10 保持连接"></a>3.1.2.10 保持连接</h5><ul><li>图 3-5 保持连接字节</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 9</td><td align="left">保持连接Keep Alive MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 10</td><td align="left">保持连接Keep Alive LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p><code>保持连接(Keep Alive)</code>使用双字节整数来表示以秒为单位的时间间隔. 它是指在客户端传输完成一个MQTT控制报文的时刻到发送下一个报文的时刻, 两者之间允许空闲的最大时间间隔. 客户端负责保证控制报文发送的时间间隔不超过保持连接的值. 如果没有任何其它的MQTT控制报文可以发送, 客户端<strong>必须</strong>发送一个 <code>PINGREQ</code> 报文 [MQTT-3.1.2-20].</p><p>如果服务端返回的<code>CONNACK</code>报文中包含服务端<code>保持连接(Server Keep Alive)</code>, 客户<strong>必须</strong>使用此值代替其发送的<code>保持连接(Keep Alive)</code> [MQTT-3.1.2-21].</p><p>不管保持连接的值是多少, 客户端任何时候都<strong>可以</strong>发送<code>PINGREQ</code>报文, 并且使用<code>PINGRESP</code>报文判断网络和服务端的活动状态.</p><p>如果保持连接的值非零, 并且服务端在1.5倍的保持连接时间内没有收到客户端的控制报文, <strong>必须</strong>断开客户端的网络连接, 并判定网络连接已断开 [MQTT-3.1.2-22].</p><p>客户端发送了<code>PINGREQ</code>报文之后, 如果在合理的时间内仍没有收到<code>PINGRESP</code>报文, 它应该关闭到服务端的网络连接.</p><p><code>保持连接(Keep Alive)</code>值为零的结果是关闭<code>保持连接(Keep Alive)</code>机制. 如果<code>保持连接(Keep Alive)</code>值为零, 客户端不必按照任何特定的时间发送MQTT控制报文.</p><pre><code>非规范评注服务端可能因为其他原因断开客户端连接, 比如服务端将要关闭服务.  设置保持连接(Keep Alive)不保证客户端将一直保持连接状态. 非规范评注保持连接的实际值是由应用指定的, 一般是几分钟.  允许的最大值是18小时12分15秒.</code></pre><h5 id="3-1-2-11-CONNECT属性"><a href="#3-1-2-11-CONNECT属性" class="headerlink" title="3.1.2.11 CONNECT属性"></a>3.1.2.11 CONNECT属性</h5><h6 id="3-1-2-11-1-属性长度"><a href="#3-1-2-11-1-属性长度" class="headerlink" title="3.1.2.11.1 属性长度"></a>3.1.2.11.1 属性长度</h6><p><code>CONNECT</code>报文可变报头中的<code>属性(Properties)</code>长度被编码为变长字节整数.</p><h6 id="3-1-2-11-2-会话过期间隔"><a href="#3-1-2-11-2-会话过期间隔" class="headerlink" title="3.1.2.11.2 会话过期间隔"></a>3.1.2.11.2 会话过期间隔</h6><p>17 (0x11), <code>会话过期间隔(Session Expiry Interval)</code>标识符.<br>跟随其后的是用四字节整数表示的以秒为单位的<code>会话过期间隔(Session Expiry Interval)</code>. 包含多个<code>会话过期间隔(Session Expiry Interval)</code>将造成协议错误(Protocol Error).</p><p>如果<code>会话过期间隔(Session Expiry Interval)</code>值未指定, 则使用0. 如果设置为0或者未指定, 会话将在网络连接(Network Connection)关闭时结束.</p><p>如果<code>会话过期间隔(Session Expiry Interval)</code>为0xFFFFFFFF (UINT_MAX), 则会话永不过期.</p><p>如果网络连接关闭时<code>会话过期间隔(Session Expiry Interval)</code>大于0, 则客户端与服务端必须存储会话状态 [MQTT-3.1.2-23].</p><pre><code>非规范评注客户端或服务端可能会因为中断运行导致会话时钟某些时间未运行.这将导致会话的删除被延迟.</code></pre><p>更多关于会话的信息参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a>. 关于会话存储的状态的详细和限制参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#411-存储会话状态" target="_blank" rel="noopener">4.1.1节</a>.</p><p>当会话过期时, 客户端和服务端无需以原子操作的方式删除会话状态.</p><pre><code>非规范评注把新开始(Clean Start)设置为1且`会话过期间隔(Session Expiry Interval)`设置为0, 等同于在MQTT v3.1.1中把清理会话(CleanSession)设置为1. 把新开始(Clean Start)设置为0且不设置会话过期间隔(Session Expiry Interval), 等同于在MQTT v3.1.1中把清理会话标志设置为0.非规范评注当希望只处理连接上服务端之后才发布的消息, 客户端应该把新开始(Clean Start)设置为1且会话过期间隔(Session Expiry Interval)设置为0, 这样客户端就不会收到它连接之前被服务端所发布的消息, 并且需要每次连接上服务端时重新订阅其感兴趣的主题.非规范评注某些客户端使用的网络可能只能提供断断续续的连接, 这种客户端可以使用较短的会话过期间隔(Session Expiry Interval)以便在网络再次可用后重新连接到服务端时获得持续的消息交付. 如果客户端不再重新连接, 且允许会话过期, 应用消息将会丢失.非规范评注某个客户端设置较长的会话过期间隔(Session Expiry Interval)或设置会话不过期, 即要求服务端为其保持会话到其下一次连接上服务端之后. 只有打算在一段时间之后将会重连服务端时, 客户端才应该设置较长的会话过期间隔(Session Expiry Interval). 当客户端认定其将来不会使用本次会话时, 应该在断开时把会话过期间隔(Session Expiry Interval)设置为0.非规范评注客户端应当使用CONNACK报文中的会话存在(Session Present)来判定服务端是否存储了其会话.非规范评注客户端应当以服务端返回的会话存在(Session Present)标志来判定会话是否已过期, 而不是客户端自己实现的会话过期状态.如果客户端自己实现会话过期状态, 则需要将会话应当被删除的时间作为会话状态的一部分而存储.</code></pre><h6 id="3-1-2-11-3-接收最大值"><a href="#3-1-2-11-3-接收最大值" class="headerlink" title="3.1.2.11.3 接收最大值"></a>3.1.2.11.3 接收最大值</h6><p>33 (0x21), <code>接收最大值(Receive Maximum)</code>标识符.<br>跟随其后的是由双字节整数表示的<code>接收最大值</code>. 包含多个<code>接收最大值</code>或<code>接收最大值</code>为0将造成协议错误(Protocol Error).</p><p>客户端使用此值限制客户端愿意同时处理的<code>QoS等级1</code>和<code>QoS等级2</code>的发布消息最大数量. 没有机制可以限制服务端试图发送的<code>QoS为0</code>的发布消息.</p><p>接收最大值只将被应用在当前网络连接. 如果没有设置最大接收值, 将使用默认值65535.</p><p>关于接收最大值的详细使用, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">4.9节 流控</a>.</p><h6 id="3-1-2-11-4-最大报文长度"><a href="#3-1-2-11-4-最大报文长度" class="headerlink" title="3.1.2.11.4 最大报文长度"></a>3.1.2.11.4 最大报文长度</h6><p>39 (0x27), <code>最大报文长度(Maximum Packet Size)</code>标识符.<br>跟随其后的是由四字节整数表示的客户端愿意接收的<code>最大报文长度(Maximum Packet Size)</code>, 如果没有设置<code>最大报文长度(Maximum Packet Size)</code>, 则按照协议由固定报头中的剩余长度可编码最大值和协议报头对数据包的大小做限制.</p><p>包含多个<code>最大报文长度(Maximum Packet Size)</code>或者<code>最大报文长度(Maximum Packet Size)</code>值为0将造成协议错误.</p><pre><code>非规范评注客户端如果选择了限制最大报文长度, 应该为最大报文长度设置一个合理的值.</code></pre><p>如<a href="https://www.zybuluo.com/khan-lau/note/1325300#214-剩余长度" target="_blank" rel="noopener">2.1.4节</a> 所述, 最大报文长度是MQTT控制报文的总长度. 客户端使用最大报文长度通知服务端其所能处理的单个报文长度限制.</p><p>服务端不能发送超过<code>最大报文长度(Maximum Packet Size)</code>的报文给客户端 [MQTT-3.1.2-24]. 收到长度超过限制的报文将导致协议错误, 客户端发送包含原因码<code>0x95(报文过大)</code>的<code>DISCONNECT</code>报文给服务端, 详见<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p><p>当报文过大而不能发送时, 服务端必须丢弃这些报文, 然后当做应用消息发送已完成处理 [MQTT-3.1.2-25].</p><p>共享订阅的情况下, 如果一条消息对于部分客户端来说太长而不能发送, 服务端可以选择丢弃此消息或者把消息发送给剩余能够接收此消息的客户端.</p><pre><code>非规范评注服务端可以把那些没有发送就被丢弃的报文放在死信队列上, 或者执行其他诊断操作. 具体的操作超出了本规范的范围.</code></pre><h6 id="3-1-2-11-5-主题别名最大值"><a href="#3-1-2-11-5-主题别名最大值" class="headerlink" title="3.1.2.11.5 主题别名最大值"></a>3.1.2.11.5 主题别名最大值</h6><p>34 (0x22), <code>主题别名最大值(Topic Alias Maximum)</code>标识符.<br>跟随其后的是用双字节整数表示的<code>主题别名最大值(Topic Alias Maximum)</code>. 包含多个<code>主题别名最大值(Topic Alias Maximum)</code>将造成协议错误(Protocol Error). 没有设置主题别名最大值属性的情况下, 主题别名最大值默认为零.</p><p>此值指示了客户端能够接收的来自服务端的<code>主题别名(Topic Alias)</code>最大数量. 客户端使用此值来限制本次连接<strong>可以</strong>拥有的主题别名的数量. 服务端在一个<code>PUBLISH</code>报文中发送的主题别名<strong>不能</strong>超过客户端设置的<code>主题别名最大值(Topic Alias Maximum)</code> [MQTT-3.1.2-26]. 值为零表示本次连接客户端不接受任何<code>主题别名(Topic Alias)</code>. 如果<code>主题别名最大值(Topic Alias Maximum)</code>没有设置, 或者设置为零, 则服务端<strong>不能</strong>向此客户端发送任何<code>主题别名(Topic Alias)</code> [MQTT-3.1.2-27].</p><h6 id="3-1-2-11-6-请求响应信息"><a href="#3-1-2-11-6-请求响应信息" class="headerlink" title="3.1.2.11.6 请求响应信息"></a>3.1.2.11.6 请求响应信息</h6><p>25 (0x19), <code>请求响应信息(Request Response Information)</code>标识符.<br>跟随其后的是用一个字节表示的0或1. 包含多个<code>请求响应信息(Request Response Information)</code>, 或者<code>请求响应信息(Request Response Information)</code>的值既不为0也不为1会造成协议错误(Protocol Error). 如果没有<code>请求响应信息(Request Response Information)</code>, 则请求响应默认值为0.</p><p>客户端使用此值向服务端请求<code>CONNACK</code>报文中的响应信息(Response Information). 值为0, 表示服务端不能返回响应信息 [MQTT-3.1.2-28]. 值为1, 表示服务端可以在<code>CONNACK</code>报文中返回响应信息.</p><pre><code>非规范评注即使客户端请求响应信息(Response Information), 服务端也可以选择不发送响应信息(Response Information).</code></pre><p>更多关于请求/响应信息的内容, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p><h6 id="3-1-2-11-7-请求问题信息"><a href="#3-1-2-11-7-请求问题信息" class="headerlink" title="3.1.2.11.7 请求问题信息"></a>3.1.2.11.7 请求问题信息</h6><p>23 (0x17), <code>请求问题信息(Request Problem Information)</code>标识符.<br>跟随其后的是用一个字节表示的0或1. 包含多个<code>请求问题信息(Request Problem Information)</code>, 或者<code>请求问题信息(Request Problem Information)</code>的值既不为0也不为1会造成协议错误(Protocol Error). 如果没有<code>请求问题信息(Request Problem Information)</code>, 则请求问题默认值为1.</p><p>客户端使用此值指示遇到错误时是否发送<code>原因字符串(Reason String)</code>或用<code>户属性(User Properties)</code>.</p><p>如果<code>请求问题信息</code>的值为0, 服务端可以选择在<code>CONNACK</code>或DISCONNECT报文中返回<code>原因字符串(Reason String)</code>或用<code>户属性(User Properties)</code>, 但不能在除<code>PUBLISH</code>, <code>CONNACK</code>或<code>DISCONNECT</code>之外的报文中发送<code>原因字符串(Reason String)</code>或用<code>户属性(User Properties)</code> [MQTT-3.1.2-29]. 如果此值为0, 并且在除<code>PUBLISH</code>, <code>CONNACK</code>或<code>DISCONNECT</code>之外的报文中收到了<code>原因字符串(Reason String)</code>或<code>用户属性(User Properties)</code>, 客户端将发送一个包含原因码<code>0x82(协议错误)</code>的<code>DISCONNECT</code>报文给服务端, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><p>如果此值为1, 服务端<strong>可以</strong>在任何被允许的报文中返回<code>原因字符串(Reason String)</code>或<code>用户属性(User Properties)</code>.</p><h6 id="3-1-2-11-8-用户属性"><a href="#3-1-2-11-8-用户属性" class="headerlink" title="3.1.2.11.8 用户属性"></a>3.1.2.11.8 用户属性</h6><p>38 (0x26), 用<code>户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对.</p><p><code>用户属性(User Property)</code>可以出现多次, 表示多个名字/值对. 相同的名字可以出现多次.</p><pre><code>非规范评注CONNECT报文中的用户属性可以被用来发送客户端到服务端的连接相关的属性. 这些属性的意义本规范不做定义.</code></pre><h6 id="3-1-2-11-9-认证方法"><a href="#3-1-2-11-9-认证方法" class="headerlink" title="3.1.2.11.9 认证方法"></a>3.1.2.11.9 认证方法</h6><p>21 (0x15), <code>认证方法(Authentication Method)</code>标识符.<br>跟随其后的是一个UTF-8编码的字符串, 包含了扩展认证的<code>认证方法(Authentication Method)</code>名称. 包含多个认证方法将造成协议错误(协议错误).<br>如果没有认证方法, 则不进行扩展验证. 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p><p>如果客户端在<code>CONNECT</code>报文中设置了认证方法, 则客户端在收到<code>CONNACK</code>报文之前<strong>不能</strong>发送除<code>AUTH</code>或<code>DISCONNECT</code>之外的报文 [MQTT-3.1.2-30].</p><h6 id="3-1-2-11-10-认证数据"><a href="#3-1-2-11-10-认证数据" class="headerlink" title="3.1.2.11.10 认证数据"></a>3.1.2.11.10 认证数据</h6><p>22 (0x16), <code>认证数据(Authentication Data)</code>标识符.<br>跟随其后的是二进制的认证数据. 没有认证方法却包含了<code>认证数据(Authentication Data)</code>, 或者包含多个<code>认证数据(Authentication Data)</code>将造成协议错误(Protocol Error).</p><p>认证数据的内容由认证方法定义, 关于扩展认证的更多信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p><h5 id="3-1-2-12-可变报头非规范示例"><a href="#3-1-2-12-可变报头非规范示例" class="headerlink" title="3.1.2.12 可变报头非规范示例"></a>3.1.2.12 可变报头非规范示例</h5><ul><li>图 3-6 可变报头示例</li></ul><table><thead><tr><th align="left"></th><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">协议名Protocol Name</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">长度Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">长度Length LSB (4)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 3</td><td align="left"><code>M</code></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 4</td><td align="left"><code>Q</code></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 5</td><td align="left"><code>T</code></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 6</td><td align="left"><code>T</code></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">协议版本Protocol Version</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">说明</td><td align="left">7</td><td align="left">6</td><td align="left">5</td><td align="left">4</td><td align="left">3</td><td align="left">2</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 7</td><td align="left">版本Version (5)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">连接标志Connect Flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 8</td><td align="left">密码标志Password Flag (1)遗嘱保留标志Will Retain (0)遗嘱服务质量Will QoS (01)遗嘱标志Will Flag (1)新开始Clean Start(1)保留Reserved (0)</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">保持连接Keep Alive</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 9</td><td align="left">保持连接Keep Alive MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 10</td><td align="left">保持连接Keep Alive LSB (10)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">属性Properties</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 11</td><td align="left">长度Length (5)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 12</td><td align="left">会话过期间隔标识符 (17)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 13</td><td align="left">会话过期间隔</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 14</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left"></td></tr><tr><td align="left">byte 15</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left"></td></tr></tbody></table><h4 id="3-1-3-CONNECT载荷"><a href="#3-1-3-CONNECT载荷" class="headerlink" title="3.1.3 CONNECT载荷"></a>3.1.3 CONNECT载荷</h4><p><code>CONNECT</code>报文的载荷中包含由<code>可变报头(Variable Header)</code>中的标志确定的一个或多个以长度为前缀的字段. 这些字段若存在, 必须按照<code>客户标识符(Client Identifier)</code>、<code>遗嘱属性(Will Properties)</code>、<code>遗嘱主题(Will Topic)</code>、<code>遗嘱载荷(Will Payload)</code>、<code>用户名(User Name)</code>、<code>密码(Password)</code>的顺序出现 [MQTT-3.1.3-1].</p><h5 id="3-1-3-1-客户标识符"><a href="#3-1-3-1-客户标识符" class="headerlink" title="3.1.3.1 客户标识符"></a>3.1.3.1 客户标识符</h5><p>服务端使用<code>客户标识符(ClientID)</code>识别客户端. 连接服务端的每个客户端都有唯一的<code>客户标识符(ClientID)</code>. 客户端和服务端都必须使用<code>客户标识符(ClientID)</code>识别两者之间的 MQTT 会话相关的状态 [MQTT-3.1.3-2]. 更多关于会话状态的信息请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a>.</p><p><code>客户标识符</code> <strong>必须</strong>存在, 且作为<code>CONNECT</code>报文载荷的第一个字段出现 [MQTT-3.1.3-3].</p><p><code>客户标识符</code> <strong>必须</strong>被编码为<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 中所定义的UTF-8字符串 [MQTT-3.1.3-4].</p><p>服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的<code>客户标识符</code>, <code>客户标识符</code>只能包含这些字符:<br>“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”(大写字母、小写字母和数字) [MQTT-3.1.3-5].</p><p>服务端<strong>可以</strong>允许编码后超过23个字节的<code>客户标识符 (ClientID)</code>. 服务端<strong>可以</strong>允许包含不是上面列表字符的<code>客户标识符 (ClientID)</code>.</p><p>服务端<strong>可以</strong>允许客户端提供一个零字节的<code>客户标识符 (ClientID)</code> , 如果这样做了, 服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户标识符给那个客户端 [MQTT-3.1.3-6]. 然后它<strong>必须</strong>假设客户端提供了那个唯一的客户标识符, 正常处理这个CONNECT报文 [MQTT-3.1.3-7].</p><p>如果服务端拒绝了某个<code>客户标识符(ClientID)</code>, 它<strong>可以</strong>发送包含原因码<code>0x85(客户标识符无效)</code>的CONNACK报文作为对客户端的<code>CONNECT</code>报文的回应, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 之后<strong>必须</strong>关闭网络连接 [MQTT-3.1.3-8].</p><pre><code>非规范评注客户端在实现时可以提供一个便于生成随机客户标识符的算法. 使用此算法时, 客户端需要注意避免创建长期孤儿会话.</code></pre><h5 id="3-1-3-2-遗嘱属性"><a href="#3-1-3-2-遗嘱属性" class="headerlink" title="3.1.3.2 遗嘱属性"></a>3.1.3.2 遗嘱属性</h5><p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, 有效载荷的下一个字段是<code>遗嘱属性(Will Properties)</code>. <code>遗嘱属性</code>字段定义了<code>遗嘱消息(Will Message)</code>将何时被发布, 以及被发布时的<code>应用消息(Application Message)</code>属性. 遗嘱属性包括属性长度和属性.</p><h6 id="3-1-3-2-1-属性长度"><a href="#3-1-3-2-1-属性长度" class="headerlink" title="3.1.3.2.1 属性长度"></a>3.1.3.2.1 属性长度</h6><p><code>遗嘱属性(Will Properties)</code>中的属性长度被编码为可变长字节整数.</p><h6 id="3-1-3-2-2-遗嘱延时间隔"><a href="#3-1-3-2-2-遗嘱延时间隔" class="headerlink" title="3.1.3.2.2 遗嘱延时间隔"></a>3.1.3.2.2 遗嘱延时间隔</h6><p>24 (0x18), <code>遗嘱延时间隔(Will Delay Interval)</code>标识符.<br>跟随其后的是由四字节整数表示的以秒为单位的<code>遗嘱延时间隔(Will Delay Interval)</code>. 包含多个遗嘱延时间隔将造成协议错误(Protocol Error). 如果没有设置遗嘱延时间隔, 遗嘱延时间隔默认值将为0, 即不用延时发布<code>遗嘱消息(Will Message)</code>.</p><p>服务端将在<code>遗嘱延时间隔(Will Delay Interval)</code>到期或者<code>会话(Session)</code>结束时发布客户端的<code>遗嘱消息(Will Message)</code>, 取决于两者谁先发生. 如果某个会话在遗嘱延时间隔到期之前创建了新的网络连接, 则服务端<strong>不能</strong>发送遗嘱消息 [MQTT-3.1.3-9].</p><pre><code>非规范评注遗嘱时间间隔的一个用途是避免在频繁的网络连接临时断开时发布遗嘱消息, 因为客户端往往会很快重新连上网络并继续之前的会话.非规范评注如果某个连接到服务端的网络连接使用已存在的客户标识符, 此已存在的网络连接的遗嘱消息将会被发布, 除非新的网络连接设置了新开始(Clean Start)为0并且遗嘱延时大于0.  如果遗嘱延时为0, 遗嘱消息将在网络连接断开时发布. 如果新开始为1, 遗嘱消息也将被发布, 因为此会话已结束.</code></pre><h6 id="3-1-3-2-3-载荷格式指示"><a href="#3-1-3-2-3-载荷格式指示" class="headerlink" title="3.1.3.2.3 载荷格式指示"></a>3.1.3.2.3 载荷格式指示</h6><p>1 (0x01), <code>载荷格式指示(Payload Format Indicator)</code>标识符.</p><ul><li><p>跟随</p><pre><code>载荷格式指示(Payload Format Indicator )</code></pre><p>之后的可能是:</p><ul><li>0 (0x00), 表示<code>遗嘱消息(Will Message)</code>是未指定的字节, 等同于不发送载荷格式指示.</li><li>1 (0x01), 表示<code>遗嘱消息(Will Message)</code>是UTF-8编码的字符数据. 载荷中的UTF-8数据必须按照Unicode规范[Unicode] 和RFC 3629 [RFC3629]中的申明进行编码.</li></ul></li></ul><p>包含多个<code>载荷格式指示(Payload Format Indicator)</code>将造成协议错误(Protocol Error). 服务端可以按照格式指示对<code>遗嘱消息(Will Message)</code>进行验证, 如果验证失败发送一条包含原因码<code>0x99(载荷格式无效)</code>的<code>CONNACK</code>报文. 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><h6 id="3-1-3-2-4-消息过期间隔"><a href="#3-1-3-2-4-消息过期间隔" class="headerlink" title="3.1.3.2.4 消息过期间隔"></a>3.1.3.2.4 消息过期间隔</h6><p>2 (0x02), <code>消息过期间隔(Message Expiry Interval)</code>标识符.<br>跟随其后的是表示<code>消息过期间隔(Message Expiry Interval)</code>的四字节整数. 包含多个消息过期间隔将导致协议错误(Protocol Error).</p><p>如果设定了<code>消息过期间隔(Message Expiry Interval)</code>, 四字节整数描述了遗嘱消息的生命周期(秒), 并在服务端发布遗嘱消息时被当做<code>发布过期间隔(Publication Expiry Interval)</code>.</p><p>如果没有设定消息过期间隔, 服务端发布遗嘱消息时将不发送<code>消息过期间隔(Message Expiry Interval)</code>.</p><h6 id="3-1-3-2-5-内容类型"><a href="#3-1-3-2-5-内容类型" class="headerlink" title="3.1.3.2.5 内容类型"></a>3.1.3.2.5 内容类型</h6><p>3 (0x03), <code>内容类型(Content Type)</code>标识符.<br>跟随其后的是一个以UTF-8格式编码的字符串, 用来描述<code>遗嘱消息(Will Message)</code>的内容. 包含多个<code>内容类型(Content Type)</code>将造成协议错误(Protocol Error). 内容类型的值由发送应用程序和接收应用程序确定.</p><h6 id="3-1-3-2-6-响应主题"><a href="#3-1-3-2-6-响应主题" class="headerlink" title="3.1.3.2.6 响应主题"></a>3.1.3.2.6 响应主题</h6><p>8 (0x08), <code>响应主题(Response Topic)</code>标识符.<br>跟随其后的是一个以UTF-8格式编码的字符串, 用来表示响应消息的<code>主题名(Topic Name)</code>. 包含多个<code>响应主题(Response Topic)</code>将造成协议错误. 响应主题的存在将<code>遗嘱消息(Will Message)</code>标识为一个请求报文.</p><p>更多关于请求/响应的内容, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p><h6 id="3-1-3-2-7-对比数据"><a href="#3-1-3-2-7-对比数据" class="headerlink" title="3.1.3.2.7 对比数据"></a>3.1.3.2.7 对比数据</h6><p>9 (0x09), <code>对比数据(Correlation Data)</code>标识符.<br>跟随其后的是二进制数据. <code>对比数据</code>被请求消息发送端在收到响应消息时用来标识相应的请求. 包含多个<code>对比数据</code>将造成协议错误(Protocol Error). 如果没有设置对比数据, 则请求方(Requester)不需要任何对比数据.</p><p>对比数据只对<code>请求消息(Request Message)</code>的发送端和<code>响应消息(Response Message)</code>的接收端有意义.</p><p>更多关于请求/响应的内容, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p><h6 id="3-1-3-2-8-用户属性"><a href="#3-1-3-2-8-用户属性" class="headerlink" title="3.1.3.2.8 用户属性"></a>3.1.3.2.8 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是一个UTF-8字符串对. <code>用户属性(User Property)</code> <strong>可以</strong>出现多次, 表示多个名字/值对. 相同的名字<strong>可以</strong>出现多次.</p><p>服务端在发布遗嘱消息(Will Message)时<strong>必须</strong>维护<code>用户属性(User Properties)</code>的顺序 [MQTT-3.1.3-10].</p><pre><code>非规范评注此属性旨在提供一种传递应用层名称-值标签的方法, 其含义和解释仅由负责发送和接收它们的应用程序所有.</code></pre><h5 id="3-1-3-3-遗嘱主题"><a href="#3-1-3-3-遗嘱主题" class="headerlink" title="3.1.3.3 遗嘱主题"></a>3.1.3.3 遗嘱主题</h5><p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, <code>遗嘱主题(Will Topic)</code>为载荷中下一个字段. <code>遗嘱主题(Will Topic)</code>必须为UTF-8编码的字符串, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 所定义 [MQTT-3.1.3-11].</p><h5 id="3-1-3-4-遗嘱载荷"><a href="#3-1-3-4-遗嘱载荷" class="headerlink" title="3.1.3.4 遗嘱载荷"></a>3.1.3.4 遗嘱载荷</h5><p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, <code>遗嘱载荷(Will Payload)</code>为载荷中下一个字段. 遗嘱载荷定义了将要发布到<code>遗嘱主题(Will Topic)</code>的应用消息载荷, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a> 所定义. 此字段为二进制数据.</p><h5 id="3-1-3-5-用户名"><a href="#3-1-3-5-用户名" class="headerlink" title="3.1.3.5 用户名"></a>3.1.3.5 用户名</h5><p>如果<code>用户名标志(User Name Flag)</code>被设置为1, <code>用户名(User Name)</code>为载荷中下一个字段. 用户名<strong>必须</strong>是<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 定义的UTF-8 编码字符串 [MQTT-3.1.3-12]. 服务端<strong>可以</strong>将它用于身份验证和授权.</p><h5 id="3-1-3-6-密码"><a href="#3-1-3-6-密码" class="headerlink" title="3.1.3.6 密码"></a>3.1.3.6 密码</h5><p>如果<code>密码标志(Password Flag)</code>被设置为1, <code>密码(Password)</code>为载荷中下一个字段. 密码字段是二进制数据, 尽管被称为密码, 但<strong>可以</strong>被用来承载任何认证信息.</p><h4 id="3-1-4-CONNECT行为"><a href="#3-1-4-CONNECT行为" class="headerlink" title="3.1.4 CONNECT行为"></a>3.1.4 CONNECT行为</h4><ul><li>注意:服务端<strong>可以</strong>在同一个 TCP 端口或其他网络端点上支持多种协议(包括MQTT协议的早期版本). 如果服务端确定协议是 MQTT v5.0, 那么它按照下面的方法验证连接请求.<ul><li><ol><li>网络连接建立后, 如果服务端在合理的时间内没有收到 <code>CONNECT</code> 报文, 服务端<strong>应该</strong>关闭这个连接.</li></ol></li><li><ol><li>服务端<strong>必须</strong>按照3.1节 的要求验证<code>CONNECT</code>报文, 如果报文不符合规范, 服务端关闭网络连接 [MQTT-3.1.4-1].服务端<strong>可以</strong>在关闭网络连接之前发送包含<a href="https://www.zybuluo.com/khan-lau/note/1325300#3124-新开始" target="_blank" rel="noopener">3.1.2.4节</a>所述的0x80及以上原因码的<code>CONNACK</code>报文.</li></ol></li><li><ol><li>服务端<strong>可以</strong>检查<code>CONNECT</code>报文的内容是不是满足任何进一步的限制, <strong>应该</strong>执行身份验证和授权检查. 如果任何一项检查没通过, 服务端<strong>必须</strong>关闭网络连接 [MQTT-3.1.4-2]. 在关闭网络连接之前, 服务端<strong>可以</strong>发送一个合适的包含如<a href="https://www.zybuluo.com/khan-lau/note/1325300#32-connack--确认连接请求" target="_blank" rel="noopener">3.2节</a> 和<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述的0x80及以上原因码的<code>CONNACK</code>报文.</li></ol></li></ul></li><li>如果验证成功, 服务端会执行下列步骤.</li><li>1 如果<code>客户标识符(ClientID)</code>所代表的客户端已经连接到此服务端, 那么向原有的客户端发送一个包含原因码为<code>0x8E(会话被接管)</code>的<code>DISCONNECT</code>报文, 并且必须关闭原有的网络连接 [MQTT-3.1.4-3]. 如果原有客户端存在<code>遗嘱消息(Will Message)</code>, <code>遗嘱消息</code>按照 <a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a> 所描述的方式发布.</li></ul><pre><code>    非规范评注    如果原有网络连接包含遗嘱消息, 且遗嘱延时间隔为0, 则遗嘱消息会在此网络连接被关闭时发送.  如果原有网络连接会话过期间隔为0, 或者新网络连接新开始标志设置为1且原有网络连接包含遗嘱消息, 则遗嘱消息会被发送, 因为原有会话已结束.</code></pre><ul><li>2 服务端必须按照<a href="https://www.zybuluo.com/khan-lau/note/1325300#3124-新开始" target="_blank" rel="noopener">3.1.2.4节</a> 所描述的方式对新开始标志进行处理[MQTT-3.1.4-4].</li><li>3 服务端必须使用包含原因码为<code>0x00(成功)</code>的<code>CONNACK</code>报文对客户端的<code>CONNECT</code>报文进行确认 [MQTT-3.1.4-5].</li></ul><pre><code>    非规范评注    如果服务端被用来处理商业关键数据, 推荐对网络连接进行认证和授权. 如果认证和授权成功, 服务端可通过发送包含原因码为0x00(成功)的CONNACK报文进行响应, 否则建议服务端根本不要发送CONNACK报文, 因为这是一种潜在的对MQTT服务端的攻击, 可以被用来进行拒绝服务攻击或密码猜测攻击.</code></pre><ul><li>4 开始消息分发和保持连接状态监视.</li></ul><p>允许客户端在发送<code>CONNECT</code>报文之后立即发送其它的MQTT控制报文；客户端不需要等待服务端的<code>CONNACK</code>报文. 如果服务端拒绝了<code>CONNECT</code>报文, 它不能处理客户端在<code>CONNECT</code>报文之后发送的任何除<code>AUTH</code>以外的报文 [MQTT-3.1.4-6].</p><pre><code>非规范评注客户端通常会等待CONNACK报文. 然而, 如果在收到CONNACK报文之前就自由的发送其它MQTT控制报文将会简化客户端的实现, 因为它不必监督连接的状态. 如果连接被拒绝了, 客户端在接收CONNACK报文之前发送的任何数据将不会被服务端所处理.非规范评注选择在收到CONNACK报文之前就发送MQTT控制报文的客户端将不知道服务端所存在的约束以及会话是否被使用. 非规范评注服务端在对某个客户端完成认证之前, 可以选择限制读取该客户端的网络数据或者关闭该客户端的网络连接.这是一种避免拒绝服务攻击的方法.</code></pre><h3 id="3-2-CONNACK-–-确认连接请求"><a href="#3-2-CONNACK-–-确认连接请求" class="headerlink" title="3.2 CONNACK – 确认连接请求"></a>3.2 CONNACK – 确认连接请求</h3><p><code>CONNACK</code>报文由服务端所发送, 作为对来自客户端的<code>CONNECT</code>报文的响应. 服务端在发送任何除<code>AUTH</code>以外的报文之前必须先发送包含原因码为0x00(成功)的<code>CONNACK</code>报文 [MQTT-3.2.0-1].服务端在一次网络连接中不能发送多个<code>CONNACK</code>报文 [MQTT-3.2.0-2].</p><p>如果客户端在合理的时间内没有收到服务端的<code>CONNACK</code>报文, 客户端<strong>应该</strong>关闭网络连接. 合理的时间取决于应用的类型和通信基础设施.</p><h4 id="3-2-1-CONNACK固定报头"><a href="#3-2-1-CONNACK固定报头" class="headerlink" title="3.2.1 CONNACK固定报头"></a>3.2.1 CONNACK固定报头</h4><p>固定报头的格式见图 3-7 的描述.</p><ul><li>图 3-7 CONNACK报文固定报头</li></ul><table><thead><tr><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (2)</td><td align="left">Reserved 保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>剩余长度字段<br>用<code>变长字节整数</code>来编码, 表示可变报头的长度.</p><h4 id="3-2-2-CONNACK可变报头"><a href="#3-2-2-CONNACK可变报头" class="headerlink" title="3.2.2 CONNACK可变报头"></a>3.2.2 CONNACK可变报头</h4><p><code>CONNACK</code>报文的可变报头按顺序包含以下字段:<code>连接确认标志(Connect Acknowledge Flags)</code>, 连接<code>原因码(Reason Code)</code>, <code>属性(Properties)</code>. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所描述.</p><h5 id="3-2-2-1-连接确认标志"><a href="#3-2-2-1-连接确认标志" class="headerlink" title="3.2.2.1 连接确认标志"></a>3.2.2.1 连接确认标志</h5><p>第1个字节是<code>连接确认标志</code>, 位7-1是保留位且<strong>必须</strong>设置为0 [MQTT-3.2.2-1] .</p><p>第0(SP)位是<code>会话存在标志(Session Present Flag)</code>.</p><h6 id="3-2-2-1-1-会话存在"><a href="#3-2-2-1-1-会话存在" class="headerlink" title="3.2.2.1.1 会话存在"></a>3.2.2.1.1 会话存在</h6><p>位置:连接确认标志(Connect Acknowledge Flags)的第0位.</p><p><code>会话存在(Session Present)</code>标志通知客户端, 服务端是否正在使用此客户标识符之前连接的<code>会话状态(Session State)</code>. 会话存在标志使服务端和客户端在是否有已存储的会话状态上保持一致.</p><p>如果服务端接受一个<code>新开始(Clean Start)</code>为1的连接, 服务端在CONNACK报文中除了把原因码设置为0x00(成功)之外, 还必须把会话存在标志设置为0 [MQTT-3.2.2-2].</p><p>如果服务端接受一个<code>新开始(Clean Start)</code>为0的连接, 并且服务端已经保存了此<code>客户标识符(ClientID)</code>的<code>会话状态(Session State)</code>, 服务端在<code>CONNACK</code>报文中<strong>必须</strong>把会话存在标志设置为1. 否则, 服务端<strong>必须</strong>把会话存在标志设置为0. 无论如何, 服务端在<code>CONNACK</code>报文中<strong>必须</strong>把原因码设置为<code>0x00(成功)</code> [MQTT-3.2.2-3].</p><p>如果客户端从服务端接收到的会话存在标志值与预期的不同, 客户端做如下处理:<br>- 如果客户端没有保存的会话状态, 但收到会话存在标志为1, 客户端<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-4]. 如果希望重新开始一个新的会话, 客户端<strong>可以</strong>使用<code>新开始(Clean Start)</code>为1并重新连接服务端.<br>- 如果客户端保存了<code>会话状态</code>, 但收到的<code>会话存在标志</code>为0, 客户端若要继续此网络连接, 它<strong>必须</strong>丢弃其保存的<code>会话状态</code> [MQTT-3.2.2-5].</p><p>如果服务端发送的<code>CONNACK</code>报文中原因码非0, 它<strong>必须</strong>把会话存在标志设置为0 [MQTT-3.2.2-6].</p><h5 id="3-2-2-2-连接原因码"><a href="#3-2-2-2-连接原因码" class="headerlink" title="3.2.2.2 连接原因码"></a>3.2.2.2 连接原因码</h5><p>可变报头中第2个字节是连接<code>原因码(Reason Code)</code>.</p><p>连接<code>原因码(Reason Code)</code>的值如下所示. 如果服务端收到一个格式正确的<code>CONNECT</code>报文, 但服务端无法完成连接的创建, 服务端<strong>可以</strong>发送一个包含适当的连接原因码的<code>CONNACK</code>报文. 如果服务端发送了一个包含原因码大于等于128的<code>CONNACK</code>报文, 它随后<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-7].</p><ul><li>表 3-1 连接原因码</li></ul><table><thead><tr><th align="left">值</th><th align="left">16进制</th><th align="left">原因码名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00</td><td align="left">成功</td><td align="left">连接被接受.</td></tr><tr><td align="left">128</td><td align="left">0x80</td><td align="left">未指明的错误</td><td align="left">服务端不愿透露的错误, 或者没有适用的原因码.</td></tr><tr><td align="left">129</td><td align="left">0x81</td><td align="left">无效报文</td><td align="left">CONNECT报文内容不能被正确的解析.</td></tr><tr><td align="left">130</td><td align="left">0x82</td><td align="left">协议错误</td><td align="left">CONNECT报文内容不符合本规范.</td></tr><tr><td align="left">131</td><td align="left">0x83</td><td align="left">实现特定错误</td><td align="left">CONNECT有效, 但不被服务端所接受.</td></tr><tr><td align="left">132</td><td align="left">0x84</td><td align="left">协议版本不支持</td><td align="left">服务端不支持客户端所请求的MQTT协议版本.</td></tr><tr><td align="left">133</td><td align="left">0x85</td><td align="left">客户标识符无效</td><td align="left">客户标识符有效, 但未被服务端所接受.</td></tr><tr><td align="left">134</td><td align="left">0x86</td><td align="left">用户名密码错误</td><td align="left">客户端指定的用户名密码未被服务端所接受.</td></tr><tr><td align="left">135</td><td align="left">0x87</td><td align="left">未授权</td><td align="left">客户端未被授权连接.</td></tr><tr><td align="left">136</td><td align="left">0x88</td><td align="left">服务端不可用</td><td align="left">MQTT服务端不可用.</td></tr><tr><td align="left">137</td><td align="left">0x89</td><td align="left">服务端正忙</td><td align="left">服务端正忙, 请重试.</td></tr><tr><td align="left">138</td><td align="left">0x8A</td><td align="left">禁止</td><td align="left">客户端被禁止, 请联系服务端管理员.</td></tr><tr><td align="left">140</td><td align="left">0x8C</td><td align="left">无效的认证方法</td><td align="left">认证方法未被支持, 或者不匹配当前使用的认证方法.</td></tr><tr><td align="left">144</td><td align="left">0x90</td><td align="left">主题名无效</td><td align="left">遗嘱主题格式正确, 但未被服务端所接受.</td></tr><tr><td align="left">149</td><td align="left">0x95</td><td align="left">报文过长</td><td align="left">CONNECT报文超过最大允许长度.</td></tr><tr><td align="left">151</td><td align="left">0x97</td><td align="left">超出配额</td><td align="left">已超出实现限制或管理限制.</td></tr><tr><td align="left">153</td><td align="left">0x99</td><td align="left">载荷格式无效</td><td align="left">遗嘱载荷数据与载荷格式指示符不匹配.</td></tr><tr><td align="left">154</td><td align="left">0x9A</td><td align="left">不支持保留</td><td align="left">遗嘱保留标志被设置为1, 但服务端不支持保留消息.</td></tr><tr><td align="left">155</td><td align="left">0x9B</td><td align="left">不支持的QoS等级</td><td align="left">服务端不支持遗嘱中设置的QoS等级.</td></tr><tr><td align="left">156</td><td align="left">0x9C</td><td align="left">临时)使用其他服务端</td><td align="left">客户端应该临时使用其他服务端.</td></tr><tr><td align="left">157</td><td align="left">0x9D</td><td align="left">服务端已(永久)移动</td><td align="left">客户端应该永久使用其他服务端</td></tr><tr><td align="left">159</td><td align="left">0x9F</td><td align="left">超出连接速率限制</td><td align="left">超出了所能接受的连接速率限制.</td></tr></tbody></table><p>服务端发送的<code>CONNACK</code>报文<strong>必须</strong>设置一种原因码 [MQTT-3.2.2-8].</p><pre><code>非规范评注原因码0x80(未指明的错误)可以被用作:服务器知道失败的原因但是并不希望透露给客户端, 或者没有其他适用的原因码.出于安全考虑, 发现`CONNECT`出错时服务端可以选择不发送`CONNACK`报文而关闭网络连接.例如, 在公网中向未被授权的网络连接告知自身MQTT服务端身份并不明智.</code></pre><h5 id="3-2-2-3-CONNACK属性"><a href="#3-2-2-3-CONNACK属性" class="headerlink" title="3.2.2.3 CONNACK属性"></a>3.2.2.3 CONNACK属性</h5><h6 id="3-2-2-3-1-属性长度"><a href="#3-2-2-3-1-属性长度" class="headerlink" title="3.2.2.3.1 属性长度"></a>3.2.2.3.1 属性长度</h6><p><code>CONNACK</code>报文可变报头中的<code>属性长度</code>, 编码为<code>变长字节整数</code>.</p><h6 id="3-2-2-3-2-会话过期间隔"><a href="#3-2-2-3-2-会话过期间隔" class="headerlink" title="3.2.2.3.2 会话过期间隔"></a>3.2.2.3.2 会话过期间隔</h6><p>17 (0x11), <code>会话过期间隔(Session Expiry Interval)</code>标识符.<br>跟随其后的是用四字节整数表示的以秒为单位的<code>会话过期间隔(Session Expiry Interval)</code>. 包含多个<code>会话过期间隔(Session Expiry Interval)</code>将造成协议错误(Protocol Error).</p><p>如果<code>会话过期间隔(Session Expiry Interval)</code>值未指定, 则使用<code>CONNECT</code>报文中指定的会话过期时间间隔. 服务端使用此属性通知客户端它使用的会话过期时间间隔与客户端在<code>CONNECT</code>中发送的值不同. 更详细的关于会话过期时间的描述, 请参考 <a href="https://www.zybuluo.com/khan-lau/note/1325300#312112-会话过期间隔" target="_blank" rel="noopener">3.1.2.11.2节</a> .</p><h6 id="3-2-2-3-3-接收最大值"><a href="#3-2-2-3-3-接收最大值" class="headerlink" title="3.2.2.3.3 接收最大值"></a>3.2.2.3.3 接收最大值</h6><p>33 (0x21), <code>接收最大值(Receive Maximum)</code>描述符.<br>跟随其后的是由双字节整数表示的最大接收值. 包含多个接收最大值或接收最大值为0将造成协议错误(Protocol Error).</p><p>服务端使用此值限制服务端愿意为该客户端同时处理的QoS为1和QoS为2的发布消息最大数量. 没有机制可以限制客户端试图发送的QoS为0的发布消息.</p><p>如果没有设置最大接收值, 将使用默认值65535.</p><p>关于接收最大值的详细使用, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">4.9节</a> 流控部分.</p><h6 id="3-2-2-3-4-最大服务质量"><a href="#3-2-2-3-4-最大服务质量" class="headerlink" title="3.2.2.3.4 最大服务质量"></a>3.2.2.3.4 最大服务质量</h6><p>36 (0x24), <code>最大服务质量(Maximum QoS)</code>标识符.<br>跟随其后的是用一个字节表示的0或1. 包含多个<code>最大服务质量(Maximum QoS)</code>或最大服务质量既不为0也不为1将造成协议错误. 如果没有设置最大服务质量, 客户端可使用最大QoS为2.</p><p>如果服务端不支持Qos为1或2的<code>PUBLISH</code>报文, 服务端<strong>必须</strong>在<code>CONNACK</code>报文中发送最大服务质量以指定其支持的最大QoS值 [MQTT-3.2.2-9].即使不支持QoS为1或2的<code>PUBLISH</code>报文, 服务端也<strong>必须</strong>接受请求QoS为0、1或2的<code>SUBSCRIBE</code>报文 [MQTT-3.2.2-10].</p><p>如果从服务端接收到了<code>最大QoS</code>等级, 则客户端不能发送超过<code>最大QoS</code>等级所指定的QoS等级的<code>PUBLISH</code>报文 [MQTT-3.2.2-11]. 服务端接收到超过其指定的最大服务质量的<code>PUBLISH</code>报文将造成协议错误(Protocol Error). 这种情况下应使用包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>DISCONNECT</code>报文进行处理, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><p>如果服务端收到包含遗嘱的QoS超过服务端处理能力的<code>CONNECT</code>报文, 服务端<strong>必须</strong>拒绝此连接. 服务端<strong>应该</strong>使用包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>CONNACK</code>报文进行错误处理, 随后<strong>必须</strong>关闭网络连接. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述 [MQTT-3.2.2-12].</p><pre><code>非规范评注客户端不必支持QoS为1和2的PUBLISH报文.客户端只需将其发送的任何SUBSCRIBE报文中的QoS字段限制在其支持的最大服务质量以内即可.</code></pre><h6 id="3-2-2-3-5-保留可用"><a href="#3-2-2-3-5-保留可用" class="headerlink" title="3.2.2.3.5 保留可用"></a>3.2.2.3.5 保留可用</h6><p>37 (0x25), <code>保留可用(Retain Available)</code>标识符.<br>跟随其后的是一个单字节字段, 用来声明服务端是否支持<code>保留消息</code>. 值为0表示不支持<code>保留消息</code>, 为1表示支持<code>保留消息</code>. 如果没有设置保留可用字段, 表示支持<code>保留消息</code>. 包含多个保留可用字段或保留可用字段值不为0也不为1将造成协议错误(Protocol Error).</p><p>如果服务端收到一个包含保留标志位1的遗嘱消息的<code>CONNECT</code>报文且服务端不支持<code>保留消息</code>, 服务端<strong>必须</strong>拒绝此连接请求, 且<strong>应该</strong>发送包含原因码为<code>0x9A(不支持保留)</code>的<code>CONNACK</code>报文, 随后<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-13].</p><p>从服务端接收到的保留可用标志为0时, 客户端不能发送<code>保留标志</code>设置为1的<code>PUBLISH</code>报文 [MQTT-3.2.2-14]. 如果服务端收到这种<code>PUBLISH</code>报文, 将造成协议错误(Protocol Error), 此时服务端<strong>应该</strong>发送包含原因码为<code>0x9A(不支持保留)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><h6 id="3-2-2-3-6-最大报文长度"><a href="#3-2-2-3-6-最大报文长度" class="headerlink" title="3.2.2.3.6 最大报文长度"></a>3.2.2.3.6 最大报文长度</h6><p>39 (0x27), <code>最大报文长度(Maximum Packet Size)</code>标识符.<br>跟随其后的是由四字节整数表示的服务端愿意接收的<code>最大报文长度(Maximum Packet Size)</code>. 如果没有设置<code>最大报文长度</code>, 则按照协议由固定报头中的剩余长度可编码最大值和协议报头对数据包的大小做限制.</p><p>包含多个<code>最大报文长度(Maximum Packet Size)</code>, 或<code>最大报文长度</code>为0将造成协议错误(Protocol Error).</p><p>如<a href="https://www.zybuluo.com/khan-lau/note/1325300#214-剩余长度" target="_blank" rel="noopener">2.1.4节</a> 所述, 最大报文长度是MQTT控制报文的总长度. 服务端使用最大报文长度通知客户端其所能处理的单个报文长度限制.</p><p>客户端不能发送超过最大报文长度(Maximum Packet Size)的报文给服务端 [MQTT-3.2.2-15]. 收到长度超过限制的报文将导致协议错误, 此时服务端<strong>应该</strong>发送包含原因码<code>0x95(报文过长)</code>的DISCONNECT报文给客户端, 详见<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p><h6 id="3-2-2-3-7-分配客户标识符"><a href="#3-2-2-3-7-分配客户标识符" class="headerlink" title="3.2.2.3.7 分配客户标识符"></a>3.2.2.3.7 分配客户标识符</h6><p>18 (0x12), <code>分配客户标识符(Assigned Client Identifier)</code>标识符.<br>跟随其后的是UTF-8编码的<code>分配客户标识符(Assigned Client Identifier)</code>字符串. 包含多个分配客户标识符将造成协议错误(Protocol Error).</p><p>服务端分配客户标识符的原因是<code>CONNECT</code>报文中的客户标识符长度为0.</p><p>如果客户端使用长度为0的<code>客户标识符(ClientID)</code>, 服务端<strong>必须</strong>回复包<code>含分配客户标识符(Assigned Client Identifier)</code>的<code>CONNACK</code>报文. 分配客户标识符<strong>必须</strong>是没有被服务端的其他会话所使用的新<code>客户标识符</code> [MQTT-3.2.2-16].</p><h6 id="3-2-2-3-8-主题别名最大值"><a href="#3-2-2-3-8-主题别名最大值" class="headerlink" title="3.2.2.3.8 主题别名最大值"></a>3.2.2.3.8 主题别名最大值</h6><p>34 (0x22), <code>主题别名最大值(Topic Alias Maximum)</code>标识符.<br>跟随其后的是用双字节整数表示的<code>主题别名最大值(Topic Alias Maximum)</code>. 包含多个<code>主题别名最大值(Topic Alias Maximum)</code>将造成协议错误(Protocol Error). 没有设置主题别名最大值属性的情况下, 主题别名最大值默认为零.</p><p>此值指示了服务端能够接收的来自客户端的主题别名(Topic Alias)最大值.服务端使用此值来限制本次连接可以拥有的主题别名的值. 客户端在一个<code>PUBLISH</code>报文中发送的主题别名值不能超过服务端设置的<code>主题别名最大值(Topic Alias Maximum)</code> [MQTT-3.2.2-17]. 值为0表示本次连接服务端不接受任何<code>主题别名(Topic Alias)</code>. 如果<code>主题别名最大值(Topic Alias Maximum)</code>没有设置, 或者设置为0, 则客户端不能向此服务端发送任何<code>主题别名(Topic Alias)</code> [MQTT-3.2.2-18].</p><h6 id="3-2-2-3-9-原因字符串"><a href="#3-2-2-3-9-原因字符串" class="headerlink" title="3.2.2.3.9 原因字符串"></a>3.2.2.3.9 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不应该被客户端所解析.</p><p>服务端使用此值向客户端提供附加信息. 如果加上原因字符串之后的<code>CONNACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端不能发送此原因字符串 [MQTT-3.2.2-19]. 包含多个原因字符串将造成协议错误(Protocol Error).</p><pre><code>非规范评注客户端对原因字符串的恰当使用包括:抛出异常时使用此字符串, 或者将此字符串写入日志.</code></pre><h6 id="3-2-2-3-10-用户属性"><a href="#3-2-2-3-10-用户属性" class="headerlink" title="3.2.2.3.10 用户属性"></a>3.2.2.3.10 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上用户属性之后的<code>CONNACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端不能发送此属性 [MQTT-3.2.2-20]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p><p>用户属性的内容和意义本规范不做定义. <code>CONNACK</code>报文的接收端可以选择忽略此属性.</p><h6 id="3-2-2-3-11-通配符订阅可用"><a href="#3-2-2-3-11-通配符订阅可用" class="headerlink" title="3.2.2.3.11 通配符订阅可用"></a>3.2.2.3.11 通配符订阅可用</h6><p>40 (0x28), <code>通配符订阅可用(Wildcard Subscription Available)</code>标识符.<br>跟随其后的是一个单字节字段, 用来声明服务器是否支持<code>通配符订阅(Wildcard Subscriptions)</code>. 值为0表示不支持<code>通配符订阅</code>, 值为1表示支持通配符订阅. 如果没有设置此值, 则表示支持<code>通配符订阅</code>. 包含多个<code>通配符订阅可用</code>属性, 或<code>通配符订阅可用</code>属性值不为0也不为1将造成协议错误(Protocol Error).</p><p>如果服务端在不<code>支持通配符订阅</code>(Wildcard Subscription)的情况下收到了包含<code>通配符订阅</code>的<code>SUBSCRIBE</code>报文, 将造成协议错误(Protocol Error). 此时服务端将发送包含原因码为<code>0xA2(通配符订阅不支持)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><p>服务端在支持<code>通配符订阅</code>的情况下仍然可以拒绝特定的包含<code>通配符订阅</code>的订阅请求. 这种情况下, 服务端可以发送一个包含原因码为<code>0xA2(通配符订阅不支持)</code>的<code>SUBACK</code>报文.</p><h6 id="3-2-2-3-12-订阅标识符可用"><a href="#3-2-2-3-12-订阅标识符可用" class="headerlink" title="3.2.2.3.12 订阅标识符可用"></a>3.2.2.3.12 订阅标识符可用</h6><p>41 (0x29), <code>订阅标识符可用(Subscription Identifier Available)</code>标识符.<br>跟随其后的是一个单字节字段, 用来声明服务端是否支持<code>订阅标识符(Subscription Identifiers)</code>. 值为0表示不支持<code>订阅标识符</code>, 值为1表示支持<code>订阅标识符</code>. 如果没有设置此值, 则表示支持<code>订阅标识符</code>. 包含多个<code>订阅标识符可用</code>属性, 或<code>订阅标识符可用</code>属性值不为0也不为1将造成协议错误(Protocol Error).</p><p>如果服务端在不支持<code>订阅标识符(Subscription Identifier)</code>的情况下收到了包含<code>订阅标识符</code>的<code>SUBSCRIBE</code>报文, 将造成协议错误(Protocol Error). 此时服务端将发送包含原因码为<code>0xA1(订阅标识符不支持)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><h6 id="3-2-2-3-13-共享订阅可用"><a href="#3-2-2-3-13-共享订阅可用" class="headerlink" title="3.2.2.3.13 共享订阅可用"></a>3.2.2.3.13 共享订阅可用</h6><p>42 (0x2A), <code>共享订阅可用(Shared Subscription Available)</code>标识符.<br>跟随其后的是一个单字节字段, 用来声明服务端是否支持<code>共享订阅(Shared Subscription)</code>. 值为0表示不支持<code>共享订阅</code>, 值为1表示支持<code>共享订阅</code>. 如果没有设置此值, 则表示支持<code>共享订阅</code>. 包含多个<code>共享订阅可用(Shared Subscription Available)</code>, 或<code>共享订阅可用</code>属性值不为0也不为1将造成协议错误(Protocol Error).</p><p>如果服务端在不支持<code>共享订阅(Shared Subscription)</code>的情况下收到了包含<code>共享订阅</code>的<code>SUBSCRIBE</code>报文, 将造成协议错误(Protocol Error). 此时服务端将发送包含原因码为<code>0x9E(共享订阅不支持)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><h6 id="3-2-2-3-14-服务端保持连接"><a href="#3-2-2-3-14-服务端保持连接" class="headerlink" title="3.2.2.3.14 服务端保持连接"></a>3.2.2.3.14 服务端保持连接</h6><p>19 (0x13), <code>服务端保持连接(Server Keep Alive)</code>标识符.<br>跟随其后的是由服务端分配的双字节整数表示的<code>保持连接(Keep Alive)</code>时间. 如果服务端发送了<code>服务端保持连接(Server Keep Alive)</code>属性, 客户端<strong>必须</strong>使用此值代替其在<code>CONNECT</code>报文中发送的<code>保持连接</code>时间值 [MQTT-3.2.2-21]. 如果服务端没有发送<code>服务端保持连接</code>属性, 服务端<strong>必须</strong>使用客户端在<code>CONNECT</code>报文中设置的<code>保持连接</code>时间值 [MQTT-3.2.2-22]. 包含多个<code>服务端保持连接</code>属性将造成协议错误(Protocol Error).</p><pre><code>非规范评注服务端保持连接属性的主要作用是通知客户端它将会比客户端指定的保持连接更快的断开非活动的客户端.</code></pre><h6 id="3-2-2-3-15-响应信息"><a href="#3-2-2-3-15-响应信息" class="headerlink" title="3.2.2.3.15 响应信息"></a>3.2.2.3.15 响应信息</h6><p>26 (0x1A), <code>响应信息(Response Information)</code>标识符.<br>跟随其后的是一个以UTF-8编码的字符串, 作为<code>创建响应主题(Response Topic)</code>的基本信息. 关于客户端如何根据<code>响应信息(Response Information)</code>创建响应主题不在本规范的定义范围内. 包含多个响应信息将造成协议错误(Protocol Error).</p><p>如果客户端发送的<code>请求响应信息(Request Response Information)</code>值为1, 则服务端在<code>CONNACK</code>报文中发送<code>响应信息(Response Information)</code>为可选项.</p><pre><code>非规范评注响应信息通常被用来传递主题订阅树的一个全局唯一分支, 此分支至少在该客户端的会话生命周期内为该客户端所保留. 请求客户端和响应客户端的授权需要使用它, 所以它通常不能仅仅是一个随机字符串. 一般把此分支作为特定客户端的订阅树根节点. 通常此信息需要正确配置, 以使得服务器能返回信息. 使用此机制时, 具体的信息一般由服务端来进行统一配置, 而非由各个客户端自己配置.</code></pre><p>更多关于请求/响应的信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a> .</p><h6 id="3-2-2-3-16-服务端参考"><a href="#3-2-2-3-16-服务端参考" class="headerlink" title="3.2.2.3.16 服务端参考"></a>3.2.2.3.16 服务端参考</h6><p>28 (0x1C), <code>服务端参考(Server Reference)</code>标识符.<br>跟随其后的是一个以UTF-8编码的字符串, 可以被客户端用来标识其他可用的服务端. 包含多个<code>服务端参考(Server Reference)</code>将造成协议错误(Protocol Error).</p><p>服务端在包含了原因码为<code>0x9C((临时)使用其他服务端)</code>或<code>0x9D(服务端已(永久)移动)</code>的<code>CONNACK</code>报文或<code>DISCONNECT</code>报文中设置服务端参考, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><p>关于如何使用服务端参考, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#411-服务端重定向" target="_blank" rel="noopener">4.11节</a> 服务端重定向信息.</p><h6 id="3-2-2-3-17-认证方法"><a href="#3-2-2-3-17-认证方法" class="headerlink" title="3.2.2.3.17 认证方法"></a>3.2.2.3.17 认证方法</h6><p>21 (0x15), <code>认证方法(Authentication Method)</code>标识符.<br>跟随其后的是一个以UTF-8编码的字符串, 包含了<code>认证方法(Authentication Method)</code>名. 包含多个认证方法将造成协议错误(Protocol Error). 更多关于扩展认证的信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a> .</p><h6 id="3-2-2-3-18-认证数据"><a href="#3-2-2-3-18-认证数据" class="headerlink" title="3.2.2.3.18 认证数据"></a>3.2.2.3.18 认证数据</h6><p>22 (0x16), <code>认证数据(Authentication Data)</code>标识符.<br>跟随其后的是包含<code>认证数据(Authentication Data)</code>的二进制数据. 此数据的内容由认证方法和已交换的<code>认证数据</code>状态定义. 包含多个<code>认证数据</code>将造成协议错误(Protocol Error). 更多关于扩展认证的信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p><h4 id="3-2-3-CONNACK载荷"><a href="#3-2-3-CONNACK载荷" class="headerlink" title="3.2.3 CONNACK载荷"></a>3.2.3 CONNACK载荷</h4><p><code>CONNACK</code>报文没有有效载荷.</p><h3 id="3-3-PUBLISH-–-发布消息"><a href="#3-3-PUBLISH-–-发布消息" class="headerlink" title="3.3 PUBLISH – 发布消息"></a>3.3 PUBLISH – 发布消息</h3><p><code>PUBLISH</code>报文是指从客户端向服务端或者服务端向客户端传输一个应用消息.</p><h4 id="3-3-1-PUBLISH固定报头"><a href="#3-3-1-PUBLISH固定报头" class="headerlink" title="3.3.1 PUBLISH固定报头"></a>3.3.1 PUBLISH固定报头</h4><ul><li>图 3-8 PUBLISH报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (3)</td><td align="left">DUP</td><td align="left">QoS等级</td><td align="left">RETAIN</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td></tr><tr><td align="left">byte 2 …</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h5 id="3-3-1-1-重发标志"><a href="#3-3-1-1-重发标志" class="headerlink" title="3.3.1.1 重发标志"></a>3.3.1.1 重发标志</h5><p>位置:第1个字节, 第3位.<br>如果<code>DUP标志</code>被设置为0, 表示这是客户端或服务端第一次请求发送这个<code>PUBLISH</code>报文. 如果<code>DUP标志</code>被设置为1, 表示这可能是一个早前报文请求的重发.</p><p>客户端或服务端请求重发一个<code>PUBLISH</code>报文时, <strong>必须</strong>将<code>DUP标志</code>设置为1 [MQTT-3.3.1-1]. 对于QoS为0的消息, <code>DUP标志</code> <strong>必须</strong>设置为0 [MQTT-3.3.1-2].</p><p>服务端发送<code>PUBLISH</code>报文给订阅者时, 收到(入站)的<code>PUBLISH</code>报文的<code>DUP标志</code>的值不会被传播. 发送(出站)的<code>PUBLISH</code>报文与收到(入站)的<code>PUBLISH</code>报文中的<code>DUP标志</code>是独立设置的, 它的值<strong>必须</strong>单独的根据发送(出站)的<code>PUBLISH</code>报文是否是一个重发来确定 [MQTT-3.3.1-3].</p><pre><code>非规范评注接收者收到一个DUP标志位1的MQTT控制报文时, 不能假设它看到了一个这个报文之前的一个副本. 非规范评注需要特别指出的是, DUP标志关注的是MQTT控制报文本身, 与它包含的应用消息无关.当使用QoS 1时, 客户端可能会收到一个DUP标志为0的PUBLISH 报文, 这个报文包含一个它之前收到过的应用消息的副本, 但是用的是不同的报文标识符. 2.2.1节 提供了有关报文标识符的更多信息.</code></pre><h5 id="3-3-1-2-服务质量等级"><a href="#3-3-1-2-服务质量等级" class="headerlink" title="3.3.1.2 服务质量等级"></a>3.3.1.2 服务质量等级</h5><p>位置:第1个字节, 第2-1位.<br>这个字段表示应用消息分发的<code>服务质量(QoS)</code>等级保证. 服务质量等级在下表中列出.</p><ul><li>表 3-2 QoS定义</li></ul><table><thead><tr><th align="left">QoS值</th><th align="left">Bit 2</th><th align="left">Bit 1</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">最多分发一次</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">至少分发一次</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">0</td><td align="left">仅分发一次</td></tr><tr><td align="left">-</td><td align="left">1</td><td align="left">1</td><td align="left">保留 – 不能使用</td></tr></tbody></table><p>如果服务端在对客户端响应的<code>CONNACK</code>报文中包含了<code>最大服务质量(Maximum QoS)</code>且服务端收到的<code>PUBLISH</code>报文的QoS大于此最大服务质量, 服务端发送包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><p><code>PUBLISH</code>报文的2个QoS比特位<strong>不能</strong>同时设置为1 [MQTT-3.3.1-4]. 如果服务端或客户端收到QoS 2个比特位都为1的无效<code>PUBLISH</code>报文, 使用包含原因码为<code>0x81(无效报文)</code>的<code>DISCONNECT</code>报文关闭网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><h5 id="3-3-1-3-保留标志"><a href="#3-3-1-3-保留标志" class="headerlink" title="3.3.1.3 保留标志"></a>3.3.1.3 保留标志</h5><p>位置:第1个字节, 第0位.</p><p>如果客户端发给服务端的<code>PUBLISH</code>报文的<code>保留(Retain)</code>标志被设置为1, 服务端<strong>必须</strong>存储此应用消息, 并用其替换此话题下任何已存在的消息 [MQTT-3.3.1-5], 以便它<strong>可以</strong>被分发给未来的匹配此<code>主题名(Topic Name)</code>的订阅者. 如果载荷为空, 消息可以正常被服务端所处理, 但是此话题下的任何<code>保留消息</code><strong>必须</strong>被丢弃, 并且此话题未来的订阅者将不会收到保留消息 [MQTT-3.3.1-6]. 载荷为空的保留消息将<strong>不能</strong>被存储在服务端 [MQTT-3.3.1-7].</p><p>如果客户端发给服务端的<code>PUBLISH</code>报文的保留标志位为0, 服务器<strong>不能</strong>把此消息存储为保留消息, 也<strong>不能</strong>丢弃或替换任何已存在的保留消息 [MQTT-3.3.1-8].</p><p>如果服务端发送给客户端的<code>CONNACK</code>报文中包含保留可用属性, 且属性值为0, 但收到的<code>PUBLISH</code>报文中保留标志位为1, 服务端使用包含原因码为<code>0x9A(保留不支持)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><ul><li><p>当一个新的</p><pre><code>非共享订阅(Non-shared Subscription)</code></pre><p>被创建时, 每个匹配的话题下的最新保留消息如果存在, 将根据保留消息</p><pre><code>订阅选项(Retain Handling Subscription Option)</code></pre><p>发送给客户端. 这些消息在发送时保留标志被设置为1. 保留消息的发送由保留消息处理订阅选项控制, 收到订阅时:</p><ul><li>如果保留消息处理属性被设置为0, 服务端<strong>必须</strong>发送主题与客户端订阅的<code>主题过滤器(Topic Filter)</code>相匹配的所有保留消息 [MQTT-3.3.1-9].</li><li>如果保留消息处理属性被设置为1, 如果尚不存在匹配的订阅, 服务端<strong>必须</strong>发送主题与客户端订阅的<code>主题过滤器</code>相匹配的所有保留消息.如果已存在相匹配的订阅, 服务器<strong>不能</strong>发送这些保留消息 [MQTT-3.3.1-10].</li><li>如果保留消息处理属性被设置为2, 服务器<strong>不能</strong>发送这些保留消息 [MQTT-3.3.1-11].</li></ul></li></ul><p><code>订阅选项(Subscription Options)</code>的定义, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3831-订阅选项" target="_blank" rel="noopener">3.8.3.1节</a> .</p><p>如果服务端收到<code>保留标志</code>设置为1且QoS设置为0的<code>PUBLISH</code>报文, 服务端<strong>应该</strong>把此QoS为0的消息存储为其主题下最新的<code>保留消息</code>, 但服务端<strong>可以</strong>选择在任何时间丢弃此消息. 如果发生丢弃, 该主题下将不存在任何<code>保留消息</code>.</p><p>如果某个主题当前的<code>保留消息</code>过期, 该主题下将不存在任何<code>保留消息</code>.</p><ul><li>服务端转发应用消息时, <code>保留标志</code>位的设置由发布保留(Retain As Published)<code>订阅选项</code>决定. <code>订阅选项</code>的定义, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3831-订阅选项" target="_blank" rel="noopener">3.8.3.1节</a> .<ul><li>如果发布保留(Retain As Published)订阅选项被设置为0, 服务端在转发应用消息时必须将保留标志设置为0, 而不管收到的<code>PUBLISH</code>报文中保留标志位如何设置的 [MQTT-3.3.1-12].</li><li>如果发布保留(Retain As Published)订阅选项被设置为1, 服务端在转发应用消息时必须将保留标志设置为与收到的<code>PUBLISH</code>消息中的保留标志位相同 [MQTT-3.3.1-13].</li></ul></li></ul><pre><code>非规范评注对于发布者不定期发送状态消息这个场景, 保留消息很有用. 新的非共享订阅者将会收到最近的状态.</code></pre><h5 id="3-3-1-4-剩余长度"><a href="#3-3-1-4-剩余长度" class="headerlink" title="3.3.1.4 剩余长度"></a>3.3.1.4 剩余长度</h5><p>等于可变报头的长度加上有效载荷的长度, 被编码为<code>变长字节整数</code>.</p><h4 id="3-3-2-PUBLISH可变报头"><a href="#3-3-2-PUBLISH可变报头" class="headerlink" title="3.3.2 PUBLISH可变报头"></a>3.3.2 PUBLISH可变报头</h4><p><code>PUBLISH</code>报文可变报头按顺序包含:<code>主题名(Topic Name)</code>, <code>报文标识符(Packet Identifier)</code>, <code>属性(Properties)</code>. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p><h5 id="3-3-2-1-主题名"><a href="#3-3-2-1-主题名" class="headerlink" title="3.3.2.1 主题名"></a>3.3.2.1 主题名</h5><p><code>主题名(Topic Name)</code>用于识别有效载荷数据应该被发布到哪一个信息通道.</p><p>主题名<strong>必须</strong>是<code>PUBLISH</code>报文可变报头的第一个字段. 它必须是 <a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 定义的UTF-8编码的字符串 [MQTT-3.3.2-1].</p><p><code>PUBLISH</code>报文中的主题名<strong>不能</strong>包含通配符 [MQTT-3.3.2-2].</p><p>服务端发送给订阅客户端的<code>PUBLISH</code>报文中的主题名必须<strong>匹配</strong>该订阅的主题过滤器(Topic Filter), 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> 所定义的匹配过程 [MQTT-3.3.2-3]. 然而, 由于服务端允许将主题名映射为其他名字, 主题名可能与原始<code>PUBLISH</code>报文中的主题名不同.</p><p>发送端可以使用<code>主题别名(Topic Alias)</code>以便减少PUBLISH报文的长度. 主题别名如<a href="https://www.zybuluo.com/khan-lau/note/1325300#33234-主题别名" target="_blank" rel="noopener">3.3.2.3.4节</a> 所述. 主题名长度为0且没有主题别名, 将造成协议错误(Protocol Error).</p><h5 id="3-3-2-2-报文标识符"><a href="#3-3-2-2-报文标识符" class="headerlink" title="3.3.2.2 报文标识符"></a>3.3.2.2 报文标识符</h5><p>只有当QoS等级是1或2时, <code>报文标识符(Packet Identifier)</code>字段才能出现在PUBLISH报文中. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了有关报文标识符的更多信息.</p><h5 id="3-3-2-3-PUBLISH属性"><a href="#3-3-2-3-PUBLISH属性" class="headerlink" title="3.3.2.3 PUBLISH属性"></a>3.3.2.3 PUBLISH属性</h5><h6 id="3-3-2-3-1-属性长度"><a href="#3-3-2-3-1-属性长度" class="headerlink" title="3.3.2.3.1 属性长度"></a>3.3.2.3.1 属性长度</h6><p><code>PUBLISH</code>报文可变报头中的属性长度被编码为变长字节整数.</p><h6 id="3-3-2-3-2-载荷格式指示"><a href="#3-3-2-3-2-载荷格式指示" class="headerlink" title="3.3.2.3.2 载荷格式指示"></a>3.3.2.3.2 载荷格式指示</h6><p>1 (0x01), <code>载荷格式指示(Payload Format Indicator)</code>标识符.<br>跟随其后的是单字节的载荷格式指示值, 可以是:</p><ul><li>0 (0x00), 说明载荷是未指定格式的字节, 相当于没有发送载荷格式指示.</li><li>1 (0x01), 说明载荷是UTF-8编码的字符数据. 载荷中的UTF-8数据必须是按照Unicode [Unicode] 的规范和RFC 3629 [RFC3629] 的重申进行编码.</li></ul><p>服务端<strong>必须</strong>把接收到的应用消息中的载荷格式指示原封不动的发给所有的订阅者 [MQTT-3.3.2-4]. 接收者<strong>可以</strong>验证载荷数据与所指示的格式一致, 如果不一致, 发送包含原因码为0x99(载荷格式无效)的<code>PUBACK</code>, <code>PUBREC</code>或<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><h6 id="3-3-2-3-3-消息过期间隔"><a href="#3-3-2-3-3-消息过期间隔" class="headerlink" title="3.3.2.3.3 消息过期间隔"></a>3.3.2.3.3 消息过期间隔</h6><p>2 (0x02), <code>消息过期间隔(Message Expiry Interval)</code>标识符.<br>跟随其后的是四字节整数表示的<code>消息过期间隔(Message Expiry Interval)</code>.</p><p>如果消息过期间隔存在, 四字节整数表示以秒为单位的应用消息(Application Message)生命周期. 如果<code>消息过期间隔(Message Expiry Interval)</code>已过期, 服务端还没开始向匹配的订阅者交付该消息, 则服务端<strong>必须</strong>删除该订阅者的消息副本 [MQTT-3.3.2-5].</p><p>如果<code>消息过期间隔</code>不存在, 应用消息不会过期.</p><p>服务端发送给客户端的<code>PUBLISH</code>报文中<strong>必须</strong>包含<code>消息过期间隔</code>, 值为接收时间减去消息在服务端的等待时间 [MQTT-3.3.2-6]. 关于状态存储的细节和限制, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a>.</p><h6 id="3-3-2-3-4-主题别名"><a href="#3-3-2-3-4-主题别名" class="headerlink" title="3.3.2.3.4 主题别名"></a>3.3.2.3.4 主题别名</h6><p>35 (0x23), <code>主题别名(Topic Alias)</code>标识符.<br>跟随其后的是表示<code>主题别名(Topic Alias)</code>值的双字节整数. 包含多个<code>主题别名</code>值将造成协议错误(Protocol Error).</p><p><code>主题别名</code>是一个整数, 用来代替主题名对主题进行识别. <code>主题别名</code>可以减小<code>PUBLISH</code>报文的长度, 这对某个网络连接中发送的很长且反复使用的主题名来说很有用.</p><p>发送端决定是否使用<code>主题别名</code>及别名值如何选取. 发送端通过在<code>PUBLISH</code>报文中包含的非0长度主题名和<code>主题别名</code>来设置<code>主题别名</code>映射. 接收端正常处理该<code>PUBLISH</code>报文, 但同样将指定的<code>主题别名</code>映射到主题名.</p><p>如果接收端已经设置了某个<code>主题别名</code>映射, 发送端可以发送包含<code>主题别</code>名和长度为0的主题名的<code>PUBLISH</code>报文. 接收端把此<code>PUBLISH</code>报文的主题名当做其包含的<code>主题别名</code>所映射的主题名.</p><p>发送端可以通过在同一个网络连接中发送另一个包含同样 <code>主题别名</code> 和不同非0长度主题名的 <code>PUBLISH</code> 报文来修改 <code>主题别名</code> 映射关系.</p><p><code>主题别名</code>映射仅作用于某个网络连接及其生命周期内. 接收端<strong>不能</strong>将任何<code>主题别名</code>映射从一个网络连接转发到另一个网络连接 [MQTT-3.3.2-7].</p><p><code>主题别名</code>不允许为0. 发送端<strong>不能</strong>发送包含<code>主题别名</code>值为0的 <code>PUBLISH</code> 报文 [MQTT-3.3.2-8].</p><p>客户端<strong>不能</strong>发送 <code>主题别名</code> 值大于服务端的 <code>CONNACK</code> 报文中指定的<code>主题别名</code>最大值(Topic Alias Maximum)的PUBLISH报文 [MQTT-3.3.2-9]. 客户端<strong>必须</strong>接受所有值大于0且小于等于其发送的 <code>CONNECT</code> 报文中的<code>主题别名</code>最大值的<code>主题别名</code> [MQTT-3.3.2-10].</p><p>服务端<strong>不能</strong>发送包含<code>主题别名</code>值大于客户端在<code>CONNECT</code>报文中指定的<code>主题别名最大值(Topic Alias Maximum)</code>的<code>PUBLISH</code>报文 [MQTT-3.3.2-11]. 服务端<strong>必须</strong>接受所有值大于0且小于等于其发送的 <code>CONNACK</code> 报文中的<code>主题别名</code>最大值的<code>主题别名</code> [MQTT-3.3.2-12].</p><p>客户端和服务端使用的<code>主题别名</code>映射相互独立. 因此一般来说, 客户端发送给服务端的<code>主题别名</code>值为1的<code>PUBLISH</code>报文和服务端发送给客户端的<code>主题别名</code>值为1的<code>PUBLISH</code>报文, 将被映射到不同的主题.</p><h6 id="3-3-2-3-5-响应主题"><a href="#3-3-2-3-5-响应主题" class="headerlink" title="3.3.2.3.5 响应主题"></a>3.3.2.3.5 响应主题</h6><p>8 (0x08), <code>响应主题(Response Topic)</code>标识符.<br>跟随其后的是一个UTF-8编码的字符串, 用作响应消息的主题名. <code>响应主题</code>必须是按照<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 所定义的UTF-8编码的字符串 [MQTT-3.3.2-13]. <code>响应主题</code>不能包含通配符 [MQTT-3.3.2-14]. 包含多个<code>响应主题</code>将造成协议错误(Protocol Error). <code>响应主题</code>的存在将消息标识为请求报文.</p><p>更多关于请求/响应的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p><p>服务端在收到应用消息时必须将响应主题原封不动的发送给所有的订阅者 [MQTT-3.3.2-15].</p><pre><code>非规范评注包含响应主题的应用消息接收端使用响应主题作为主题名, 发送作为响应消息的PUBLISH报文. 如果请求消息中包含对比数据, 接收端应当在发送作为对此请求消息进行响应的PUBLISH报文中包含此对比数据.</code></pre><h6 id="3-3-2-3-6-对比数据"><a href="#3-3-2-3-6-对比数据" class="headerlink" title="3.3.2.3.6 对比数据"></a>3.3.2.3.6 对比数据</h6><p>9 (0x09), <code>对比数据(Correlation Data)</code>标识符.<br>跟随其后的是二进制数据. <code>对比数据</code>被请求消息发送端在收到响应消息时用来标识相应的请求. 包含多个<code>对比数据</code>将造成协议错误(Protocol Error). 如果没有设置<code>对比数据</code>, 则请求方(Requester)不需要任何<code>对比数据</code>.</p><p>服务端在收到应用消息时<strong>必须</strong>原封不动的把 <code>对比数据</code> 发送给所有的订阅者 [MQTT-3.3.2-16]. <code>对比数据</code> 只对 <code>请求消息(Request Message)</code> 的发送端和 <code>响应消息(Response Message)</code> 的接收端有意义.</p><pre><code>非规范评注接收端收到包含响应主题和对比数据的应用消息时, 发送以响应主题为主题名的PUBLISH报文作为响应消息.  客户端在响应消息中应将对比数据作为PUBLISH报文的一部分原封不动的发送出去.非规范评注如果对客户端响应消息中的对比数据所做的任何更改会造成应用程序错误, 则应当对对比数据进行加密/哈希, 以便接收端能检测到对比数据是否被更改.</code></pre><p>更多关于请求/响应的信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p><h6 id="3-3-2-3-7-用户属性"><a href="#3-3-2-3-7-用户属性" class="headerlink" title="3.3.2.3.7 用户属性"></a>3.3.2.3.7 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>.<br>跟随其后的是UTF-8字符串对. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p><p>服务端在转发应用消息到客户端时必须原封不动的把所有的<code>用户属性</code>放在<code>PUBLISH</code>报文中 [MQTT-3.3.2-17]. 服务端在转发应用消息时必须保持所有<code>用户属性</code>的先后顺序 [MQTT-3.3.2-18].</p><pre><code>非规范评注此属性旨在提供一种传递应用层名称-值标签的方法, 其含义和解释仅由负责发送和接收它们的应用程序所有.</code></pre><h6 id="3-3-2-3-8-订阅标识符"><a href="#3-3-2-3-8-订阅标识符" class="headerlink" title="3.3.2.3.8 订阅标识符"></a>3.3.2.3.8 订阅标识符</h6><p>11 (0x0B), <code>订阅标识符(Subscription Identifier)</code>标识符.<br>跟随其后的是一个变长字节整数表示的<code>订阅标识符</code>.</p><p><code>订阅标识符</code>取值范围从1到268,435,455. <code>订阅标识符</code>的值为0将造成协议错误. 如果某条发布消息匹配了多个订阅, 则将包含多个<code>订阅标识符</code>. 这种情况下他们的顺序并不重要.</p><h6 id="3-3-2-3-9-内容类型"><a href="#3-3-2-3-9-内容类型" class="headerlink" title="3.3.2.3.9 内容类型"></a>3.3.2.3.9 内容类型</h6><p>3 (0x03), <code>内容类型(Content Type)</code>标识符.<br>跟随其后的是一个以UTF-8格式编码的字符串, 用来描述应用消息的内容. <code>内容类型</code> 必须是UTF-8编码的字符串, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 所定义 [MQTT-3.3.2-19].<br>包含多个<code>内容类型</code>将造成协议错误(Protocol Error). <code>内容类型</code>的值由发送应用程序和接收应用程序确定.</p><p>服务端必须把收到的应用消息中的<code>内容类型</code>原封不动的发送给所有的订阅者 [MQTT-3.3.2-20].</p><pre><code>非规范评注UTF-8编码字符串可以使用一个MIME`内容类型`字符串来描述应用消息的内容. 由于发送程序和接收程序负责内容类型字符串的定义和解释, 因此MQTT服务端只确保`内容类型`是有效的UTF-8编码的字符串, 不会做其他方面的验证.非规范评注图 3-9 是一个PUBLISH示例报文, 其中主题名为a/b, 报文标识符为10, 没有属性.</code></pre><ul><li>图 3-9 PUBLISH报文可变报头非规范示例</li></ul><table><thead><tr><th align="left"></th><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">主题名</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">长度Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">长度Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left"><code>a</code>(0x61)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 4</td><td align="left"><code>/</code>(0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 5</td><td align="left"><code>b</code>(0x62)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">报文标识符</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 6</td><td align="left">报文标识符MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 7</td><td align="left">报文标识符LSB (10)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">属性长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 15</td><td align="left">无属性</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h4 id="3-3-3-PUBLISH载荷"><a href="#3-3-3-PUBLISH载荷" class="headerlink" title="3.3.3 PUBLISH载荷"></a>3.3.3 PUBLISH载荷</h4><p>载荷包含将被发布的应用消息. 载荷的内容和格式由应用程序指定. 有效载荷的长度这样计算:用固定报头中的剩余长度字段的值减去可变报头的长度. 包含零长度有效载荷的<code>PUBLISH</code>报文是合法的.</p><h4 id="3-3-4-PUBLISH行为"><a href="#3-3-4-PUBLISH行为" class="headerlink" title="3.3.4 PUBLISH行为"></a>3.3.4 PUBLISH行为</h4><p><code>PUBLISH</code>报文的接收端<strong>必须</strong>按照<code>PUBLISH</code>报文中的<code>QoS等级</code>发送响应报文 [MQTT-3.3.4-1].</p><p>表 3-3 PUBLISH报文的预期响应</p><table><thead><tr><th align="left">服务质量等级</th><th align="left">预期响应</th></tr></thead><tbody><tr><td align="left">QoS 0</td><td align="left">无响应</td></tr><tr><td align="left">QoS 1</td><td align="left">PUBACK报文</td></tr><tr><td align="left">QoS 2</td><td align="left">PUBREC报文</td></tr></tbody></table><p>客户端使用<code>PUBLISH</code>报文发送应用消息给服务端, 目的是分发到其他订阅匹配的客户端.</p><p>服务端使用<code>PUBLISH</code>报文发送应用消息给每一个订阅匹配的客户端. <code>PUBLISH</code>报文包含<code>SUBSCRIBE</code>报文中承载的订阅标识符–如果存在的话.</p><p>客户端使用带通配符的主题过滤器请求订阅时, 客户端的订阅可能会重叠, 因此发布的消息可能会匹配多个主题过滤器. 这种情况下, 服务端<strong>必须</strong>按照所有匹配的订阅中最大的QoS等级把消息发送给客户端 [MQTT-3.3.4-2]. 此外, 服务端<strong>可以</strong>为每一个匹配的订阅按照订阅时的QoS等级, 把消息副本分发给客户端.</p><p>如果客户端收到一个未经请求的应用消息(没有匹配任何订阅), 且<code>QoS</code>大于客户端指定的<code>最大服务质量(Maximum QoS)</code>, 客户端使用包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>DISCONNECT</code>报文断开连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><p>如果客户端在这些重叠的订阅中指定了订阅标识符, 服务端在发布这些订阅相匹配的消息时<strong>必须</strong>包含这些订阅标识符 [MQTT-3.3.4-3]. 如果服务端对这些重叠的订阅只发送一条相匹配的消息, 服务端<strong>必须</strong>在<code>PUBLISH</code>报文中包含所有的相匹配的订阅标识符(如果存在), 但没有顺序要求 [MQTT-3.3.4-4]. 如果服务端对这些重叠的订阅<strong>必须</strong>分别发送相匹配的消息, 则每个<code>PUBLISH</code>报文中含与订阅相匹配的订阅标识符(如果存在) [MQTT-3.3.4-5].</p><p>可能存在客户端对同一个发布消息做了多次订阅, 并且这些订阅中有多个订阅使用了相同的订阅标识符, 这种情况下<code>PUBLISH</code>报文将携带多个相同的订阅标识符.</p><p><code>PUBLISH</code>报文中若包含服务端收到的 <code>SUBSCRIBE</code> 报文以外的订阅标识符, 将造成协议错误(Protocol Error). 从客户端发送给服务端的 <code>PUBLISH</code> 报文<strong>不能</strong>包含订阅标识符 [MQTT-3.3.4-6].</p><p>对于共享订阅, 发送给某个客户端的 <code>PUBLISH</code> 报文中将只包含该客户端的 <code>SUBSCRIBE</code> 报文中发送的订阅标识符.</p><p>收到<code>PUBLISH</code>报文时, 接收端的行为取决于报文的QoS等级, 如 <a href="https://www.zybuluo.com/khan-lau/note/1325300#43-服务质量等级和协议流程" target="_blank" rel="noopener">4.3节</a> 所述.</p><p>如果<code>PUBLISH</code>报文包含<code>主题别名</code>, 接收端按照以下方式进行处理:<br>- 1 <code>主题别名</code>为0或大于<code>最大主题别名(Maximum Topic Alias)</code>, 将造成协议错误(Protocol Error), 接收端使用包含原因码为<code>0x94(主题别名无效)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><ul><li>2 如果接收端已创建此<code>主题别名</code>的映射,<ul><li>a 如果报文包含的主题名长度为0, 接收端使用<code>主题别名</code>对应的主题名处理此报文</li><li>b 如果报文包含的主题名长度不为0, 接收端使用此主题名处理此报文, 并更新此<code>主题别名</code>映射到此主题名</li></ul></li><li>3 如果接收端还没有创建此<code>主题别名</code>的映射,<ul><li>a 如果报文包含的主题名长度为0, 将造成协议错误, 接收端使用包含原因码为<code>0x82(协议错误)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</li><li>b 如果报文包含的主题名长度不为0, 接收端使用此主题名处理此报文, 并为此报文中的<code>主题别名</code>和主题名创建映射关系</li></ul></li></ul><pre><code>    非规范评注    如果服务端向客户端分发应用消息时使用了不同的协议级别(比如MQTT v3.1.1)-- 不支持属性或本规范提供的其他功能, 应用消息中的某些信息将丢失, 依赖于这些信息的应用程序可能无法正常工作.</code></pre><p>客户端在收到服务端的<code>PUBACK</code>, <code>PUBCOMP</code>或包含原因码大于等于128的<code>PUBREC</code>报文之前, <strong>不能</strong>发送数量超过服务端的<code>接收最大值(Receive Maximum)</code>的QoS为1和2的<code>PUBLISH</code>报文 [MQTT-3.3.4-7]. 服务端在发送<code>PUBACK</code>或<code>PUBCOMP</code>响应之前, 如果收到数量超过客户端的接收最大值的QoS为1和2的<code>PUBLISH</code>报文, 服务端使用包含原因码为<code>0x93(超出接收最大值)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 更多关于流量控制的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">4.9节</a>.</p><p>客户端不能延迟发送任何报文, 除了<code>PUBLISH</code>报文–如果已发送且没有收到确认的<code>PUBLISH</code>报文数量已达到服务端的接收最大值(Receive Maximum) [MQTT-3.3.4-8].接收最大值只应用于当前网络连接.</p><pre><code>非规范评注客户端可以选择发送少于服务端接收最大值的未经确认的PUBLISH报文, 尽管它可以发送更多数量的报文.非规范评注客户端可以选择暂停发送QoS为0的报文, 当其暂停发送了QoS为1和2的PUBLISH报文.非规范评注如果客户端在收到CONNACK之前发送QoS为1或QoS为2的PUBLISH报文, 客户端有可能被服务器断开连接, 因为它发送了超过服务端接收最大值数量的发布报文.</code></pre><p>服务端在接收到客户端的<code>PUBACK</code>, <code>PUBCOMP</code>或包含原因码大于等于128的<code>PUBREC</code>报文之前, 不能发送数量超过客户端的<code>接收最大值(Receive Maximum)</code>的QoS为1和2的<code>PUBLISH</code>报文 [MQTT-3.3.4-9]. 客户端在发送<code>PUBACK</code>或<code>PUBCOMP</code>响应之前, 如果收到数量超过服务端的接收最大值的QoS为1和2的<code>PUBLISH</code>报文, 客户端使用包含原因码为<code>0x93(超出接收最大值)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 更多关于流量控制的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">4.9节</a> .</p><p>服务端不能延迟发送任何报文, 除了<code>PUBLISH</code>报文–如果已发送且没有收到确认的<code>PUBLISH</code>报文数量已到达客户端的<code>接收最大值(Receive Maximum)</code> [MQTT-3.3.4-10].</p><pre><code>非规范评注服务端可以选择发送少于客户端接收最大值的未经确认的PUBLISH报文, 尽管它可以发送更多数量的报文.非规范评注服务端可以选择暂停发送QoS为0的报文, 当其暂停发送了QoS为1和2的PUBLISH报文.</code></pre><h3 id="3-4-PUBACK-–-发布确认"><a href="#3-4-PUBACK-–-发布确认" class="headerlink" title="3.4 PUBACK – 发布确认"></a>3.4 PUBACK – 发布确认</h3><p><code>PUBACK</code>报文是对<code>QoS 1</code>等级的<code>PUBLISH</code>报文的响应.</p><h4 id="3-4-1-PUBACK固定报头"><a href="#3-4-1-PUBACK固定报头" class="headerlink" title="3.4.1 PUBACK固定报头"></a>3.4.1 PUBACK固定报头</h4><ul><li>图 3-10 PUBACK报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (4)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>剩余长度字段<br>表示可变报头的长度, 用<code>变长字节整数</code>编码.</p><h4 id="3-4-2-PUBACK可变报头"><a href="#3-4-2-PUBACK可变报头" class="headerlink" title="3.4.2 PUBACK可变报头"></a>3.4.2 PUBACK可变报头</h4><p>PUBACK可变报头按顺序包含以下字段:所确认的<code>PUBLISH</code>报文标识符, <code>PUBACK</code>原因码, 属性长度, 属性(Properties). 属性编码规则如2.22节 所述.</p><p>图 3 11 – PUBACK报文可变报头</p><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">报文标识符MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 3</td><td align="left">PUBACK原因码</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 4</td><td align="left">属性长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h5 id="3-4-2-1-PUBACK原因码"><a href="#3-4-2-1-PUBACK原因码" class="headerlink" title="3.4.2.1 PUBACK原因码"></a>3.4.2.1 PUBACK原因码</h5><p>PUBACK可变报头第3字节是<code>原因码(Reason Code)</code>.剩余长度为2, 则表示使用原因码<code>0x00(成功)</code>.</p><ul><li>表 3-4 PUBACK原因码</li></ul><table><thead><tr><th align="left">值</th><th align="left">16进制</th><th align="left">原因码名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00</td><td align="left">成功</td><td align="left">消息被接收.QoS为1的消息已发布.</td></tr><tr><td align="left">16</td><td align="left">0x10</td><td align="left">无匹配的订阅者</td><td align="left">消息被接收, 但没有订阅者.只有服务端会发送此原因码.如果服务端得知没有匹 配的订阅者, 服务端可以使用此原因码代替<code>0x00(成功)</code>.</td></tr><tr><td align="left">128</td><td align="left">0x80</td><td align="left">未指明的错误</td><td align="left">接收端不接受此消息, 且不愿意透露错误原因或没有适用的原因码.</td></tr><tr><td align="left">131</td><td align="left">0x83</td><td align="left">实现特定错误</td><td align="left"><code>PUBLISH</code>报文有效, 但不被接收端所接受.</td></tr><tr><td align="left">135</td><td align="left">0x87</td><td align="left">未授权</td><td align="left"><code>PUBLISH</code>报文未授权.</td></tr><tr><td align="left">144</td><td align="left">0x90</td><td align="left">主题名无效</td><td align="left">主题名格式正确, 但未被客户端或服务端所接受.</td></tr><tr><td align="left">145</td><td align="left">0x91</td><td align="left">报文标识符被占用</td><td align="left">报文标识符正被占用.可能表明客户端和服务端之间的会话状态不匹配.</td></tr><tr><td align="left">151</td><td align="left">0x97</td><td align="left">超出配额</td><td align="left">已超出实现限制或管理限制.</td></tr><tr><td align="left">153</td><td align="left">0x99</td><td align="left">载荷格式无效</td><td align="left">载荷格式与载荷格式指示符不匹配.</td></tr></tbody></table><p>服务端或客户端发送<code>PUBACK</code>报文时必须设置其中一种<code>PUBACK</code>原因码 [MQTT-3.4.2-1]. 当原因码为<code>0x00(成功)</code>且没有<code>属性(Properties)</code>时, 原因码和属性长度可以被省略. 在这种情况下, <code>PUBACK</code>剩余长度为2.</p><h5 id="3-4-2-2-PUBACK属性"><a href="#3-4-2-2-PUBACK属性" class="headerlink" title="3.4.2.2 PUBACK属性"></a>3.4.2.2 PUBACK属性</h5><h6 id="3-4-2-2-1-属性长度"><a href="#3-4-2-2-1-属性长度" class="headerlink" title="3.4.2.2.1 属性长度"></a>3.4.2.2.1 属性长度</h6><p><code>PUBACK</code>可变报头中属性长度被编码为<code>变长字节整数</code>. 如果剩余长度小于4字节, 则没有属性长度.</p><h6 id="3-4-2-2-2-原因字符串"><a href="#3-4-2-2-2-原因字符串" class="headerlink" title="3.4.2.2.2 原因字符串"></a>3.4.2.2.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不能被接收端所解析.</p><p>发送端使用此值向接收端提供附加信息. 如果加上<code>原因字符串</code>之后的<code>PUBACK</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端<strong>不能</strong>发送此<code>原因字符串</code> [MQTT-3.4.2-2]. 包含多个<code>原因字符串</code>将造成协议错误(Protocol Error).</p><h6 id="3-4-2-2-3-用户属性"><a href="#3-4-2-2-3-用户属性" class="headerlink" title="3.4.2.2.3 用户属性"></a>3.4.2.2.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于提供包括诊断信息在内的附加信息. 如果加上用户属性之后的PUBACK报文长度超出了接收端指定的最大报文长度(Maximum Packet Size), 则发送端<strong>不能</strong>发送此属性 [MQTT-3.4.2-3]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字<strong>可以</strong>多次出现.</p><h4 id="3-4-3-PUBACK载荷"><a href="#3-4-3-PUBACK载荷" class="headerlink" title="3.4.3 PUBACK载荷"></a>3.4.3 PUBACK载荷</h4><p><code>PUBACK</code>报文没有有效载荷.</p><h4 id="3-4-4-PUBACK行为"><a href="#3-4-4-PUBACK行为" class="headerlink" title="3.4.4 PUBACK行为"></a>3.4.4 PUBACK行为</h4><p>描述见4.3.2节.</p><h3 id="3-5-PUBREC-–-发布已接收-QoS-2-第一步"><a href="#3-5-PUBREC-–-发布已接收-QoS-2-第一步" class="headerlink" title="3.5 PUBREC – 发布已接收(QoS 2, 第一步)"></a>3.5 PUBREC – 发布已接收(QoS 2, 第一步)</h3><p><code>PUBREC</code>报文是对<code>QoS 2</code>等级的<code>PUBLISH</code>报文的响应. 它是<code>QoS 2</code>等级协议交换的第二个报文.</p><h4 id="3-5-1-PUBREC固定报头"><a href="#3-5-1-PUBREC固定报头" class="headerlink" title="3.5.1 PUBREC固定报头"></a>3.5.1 PUBREC固定报头</h4><p>图 3-12 PUBREC报文固定报头</p><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (5)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>剩余长度字段<br>表示可变报头的长度, 用变长字节整数编码.</p><h4 id="3-5-2-PUBREC可变报头"><a href="#3-5-2-PUBREC可变报头" class="headerlink" title="3.5.2 PUBREC可变报头"></a>3.5.2 PUBREC可变报头</h4><p>PUBREC可变报头按顺序包含以下字段:所确认的<code>PUBLISH</code> <code>报文标识符(Packet Identifier)</code>, <code>PUBREC</code> <code>原因码(Reason Code)</code>, <code>属性(Properties)</code>. 属性的编码规则, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p><ul><li>图 3-13 PUBREC报文可变报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">报文标识符MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 3</td><td align="left">PUBREC原因码</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 4</td><td align="left">属性长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h5 id="3-5-2-1-PUBREC原因码"><a href="#3-5-2-1-PUBREC原因码" class="headerlink" title="3.5.2.1 PUBREC原因码"></a>3.5.2.1 PUBREC原因码</h5><p>PUBREC可变报头第3字节是<code>原因码(Reason Code)</code>. 如果剩余长度为2, 则表示使用原因码<code>0x00(成功)</code>.</p><ul><li>表 3-5 PUBREC原因码</li></ul><table><thead><tr><th align="left">值</th><th align="left">16进制</th><th align="left">原因码名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00</td><td align="left">成功</td><td align="left">消息被接收.QoS为2的消息已发布.</td></tr><tr><td align="left">16</td><td align="left">0x10</td><td align="left">无匹配的订阅者</td><td align="left">消息被接收, 但没有订阅者.只有服务端会发送此原因码.如果服务端得知没有匹配的订阅者, 服务端可以使用此原因码代替<code>0x00(成功)</code>.</td></tr><tr><td align="left">128</td><td align="left">0x80</td><td align="left">未指明的错误</td><td align="left">接收端不接受此消息, 且不愿意透露错误原因或没有适用的原因码.</td></tr><tr><td align="left">135</td><td align="left">0x87</td><td align="left">未授权</td><td align="left"><code>PUBLISH</code>报文未授权.</td></tr><tr><td align="left">144</td><td align="left">0x90</td><td align="left">主题名无效</td><td align="left">主题名格式正确, 但未被客户端或服务端所接受.</td></tr><tr><td align="left">145</td><td align="left">0x91</td><td align="left">报文标识符被占用</td><td align="left">报文标识符正被占用.可能表明客户端和服务端之间的会话状态不匹配.</td></tr><tr><td align="left">151</td><td align="left">0x97</td><td align="left">超出配额</td><td align="left">已超出实现限制或管理限制.</td></tr><tr><td align="left">153</td><td align="left">0x99</td><td align="left">载荷格式无效</td><td align="left">载荷格式与载荷格式指示符不匹配.</td></tr></tbody></table><p>服务端或客户端发送<code>PUBREC</code>报文时<strong>必须</strong>设置其中一种原因码 [MQTT-3.5.2-1]. 当原因码为<code>0x00(成功)</code>且没有<code>属性(Properties)</code>时, 原因码和属性长度<strong>可以</strong>被省略. 在这种情况下, <code>PUBREC</code>剩余长度为2.</p><h5 id="3-5-2-2-PUBREC属性"><a href="#3-5-2-2-PUBREC属性" class="headerlink" title="3.5.2.2 PUBREC属性"></a>3.5.2.2 PUBREC属性</h5><h6 id="3-5-2-2-1-属性长度"><a href="#3-5-2-2-1-属性长度" class="headerlink" title="3.5.2.2.1 属性长度"></a>3.5.2.2.1 属性长度</h6><p>PUBREC可变报头的属性长度被编码为<code>变长字节整数</code>. 如果剩余长度小于4, 则表示没有属性长度字段.</p><h6 id="3-5-2-2-2-原因字符串"><a href="#3-5-2-2-2-原因字符串" class="headerlink" title="3.5.2.2.2 原因字符串"></a>3.5.2.2.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不应该被接收端所解析.</p><p>发送端使用此值向接收端提供附加信息. 如果加上原因字符串之后的<code>PUBREC</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端不能发送此属性 [MQTT-3.5.2-2]. 包含多个原因字符串将造成协议错误(Protocol Error).</p><h6 id="3-5-2-2-3-用户属性"><a href="#3-5-2-2-3-用户属性" class="headerlink" title="3.5.2.2.3 用户属性"></a>3.5.2.2.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于提供包括诊断信息在内的附加信息. 如果加上用户属性之后的<code>PUBREC</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端<strong>不能</strong>发送此属性 [MQTT-3.5.2-3].<code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字<strong>可以</strong>多次出现.</p><h4 id="3-5-3-PUBREC载荷"><a href="#3-5-3-PUBREC载荷" class="headerlink" title="3.5.3 PUBREC载荷"></a>3.5.3 PUBREC载荷</h4><p>PUBREC报文没有有效载荷.</p><h4 id="3-5-4-PUBREC行为"><a href="#3-5-4-PUBREC行为" class="headerlink" title="3.5.4 PUBREC行为"></a>3.5.4 PUBREC行为</h4><p>描述见4.3.3节.</p><h3 id="3-6-PUBREL-–-发布释放-QoS-2-第二步"><a href="#3-6-PUBREL-–-发布释放-QoS-2-第二步" class="headerlink" title="3.6 PUBREL – 发布释放(QoS 2, 第二步)"></a>3.6 PUBREL – 发布释放(QoS 2, 第二步)</h3><p>PUBREL报文是对<code>PUBREC</code>报文的响应. 它是 <code>QoS 2</code> 等级协议交换的第三个报文.</p><h4 id="3-6-1-PUBREL固定报头"><a href="#3-6-1-PUBREL固定报头" class="headerlink" title="3.6.1 PUBREL固定报头"></a>3.6.1 PUBREL固定报头</h4><ul><li>图 3-14 PUBREL报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (6)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>PUBREL固定报头的第3, 2, 1, 0位是保留位, 必须被设置为0, 0, 1, 0. 服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接 [MQTT-3.6.1-1].</p><p>剩余长度字段<br>表示可变报头的长度, 被编码为<code>变长字节整数</code>.</p><h4 id="3-6-2-PUBREL可变报头"><a href="#3-6-2-PUBREL可变报头" class="headerlink" title="3.6.2 PUBREL可变报头"></a>3.6.2 PUBREL可变报头</h4><p>PUBREL报文的可变报头按顺序包含以下字段:所确认的<code>PUBREC</code>报文标识符, <code>PUBREL</code>原因码, <code>属性(Properties)</code>. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p><ul><li>图 3-15 PUBREL报文可变报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">报文标识符MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 3</td><td align="left">PUBREL原因码</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 4</td><td align="left">属性长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h5 id="3-6-2-1-PUBREL原因码"><a href="#3-6-2-1-PUBREL原因码" class="headerlink" title="3.6.2.1 PUBREL原因码"></a>3.6.2.1 PUBREL原因码</h5><p>可变报头第3字节是PUBREL原因码. 如果剩余长度为2, 则表示使用原因码0x00 (成功).</p><p>表 3-6 PUBREL原因码</p><table><thead><tr><th align="left">值</th><th align="left">16进制</th><th align="left">原因码名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00</td><td align="left">成功</td><td align="left">消息已释放.</td></tr><tr><td align="left">146</td><td align="left">0x92</td><td align="left">报文标识符未发现</td><td align="left">未知的报文标识符. 会话恢复阶段这并非错误, 但其他时间这表明服务端和客户端的会话状态不匹配.</td></tr></tbody></table><p>客户端或服务端发送<code>PUBREL</code>报文时必须设置其中一种<code>PUBREL</code>原因码 [MQTT-3.6.2-1]. 当原因码为<code>0x00(成功)</code>且没有<code>属性(Properties)</code>时, 原因码和属性长度可以被省略. 在这种情况下, <code>PUBREL</code>剩余长度为2.</p><h5 id="3-6-2-2-PUBREL属性"><a href="#3-6-2-2-PUBREL属性" class="headerlink" title="3.6.2.2 PUBREL属性"></a>3.6.2.2 PUBREL属性</h5><h6 id="3-6-2-2-1-属性长度"><a href="#3-6-2-2-1-属性长度" class="headerlink" title="3.6.2.2.1 属性长度"></a>3.6.2.2.1 属性长度</h6><p>PUBREL报文可变报头中的属性长度被编码为<code>变长字节整数</code>. 如果剩余长度小于4, 则表示没有属性长度字段.</p><h6 id="3-6-2-2-2-原因字符串"><a href="#3-6-2-2-2-原因字符串" class="headerlink" title="3.6.2.2.2 原因字符串"></a>3.6.2.2.2 原因字符串</h6><p>31 (0x1F),<code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不应该被接收端所解析.</p><p>发送端使用此值向接收端提供附加信息. 如果加上原因字符串之后的<code>PUBREL</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端不能发送此原因字符串 [MQTT-3.6.2-2]. 包含多个原因字符串将造成协议错误(Protocol Error).</p><h6 id="3-6-2-2-3-用户属性"><a href="#3-6-2-2-3-用户属性" class="headerlink" title="3.6.2.2.3 用户属性"></a>3.6.2.2.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于提供包括诊断信息或关于PUBREL的信息. 如果加上用户属性之后的PUBREL报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端不能发送此属性 [MQTT-3.6.2-3]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p><h4 id="3-6-3-PUBREL载荷"><a href="#3-6-3-PUBREL载荷" class="headerlink" title="3.6.3 PUBREL载荷"></a>3.6.3 PUBREL载荷</h4><p>PUBREL报文没有有效载荷.</p><h4 id="3-6-4-PUBREL行为"><a href="#3-6-4-PUBREL行为" class="headerlink" title="3.6.4 PUBREL行为"></a>3.6.4 PUBREL行为</h4><p>描述见4.3.3节 .</p><h3 id="3-7-PUBCOMP-–-发布完成-QoS-2-第三步"><a href="#3-7-PUBCOMP-–-发布完成-QoS-2-第三步" class="headerlink" title="3.7 PUBCOMP – 发布完成(QoS 2, 第三步)"></a>3.7 PUBCOMP – 发布完成(QoS 2, 第三步)</h3><p>PUBCOMP报文是对<code>PUBREL</code>报文的响应. 它是<code>QoS 2</code>等级协议交换的第四个也是最后一个报文.</p><h4 id="3-7-1-PUBCOMP固定报头"><a href="#3-7-1-PUBCOMP固定报头" class="headerlink" title="3.7.1 PUBCOMP固定报头"></a>3.7.1 PUBCOMP固定报头</h4><ul><li>图 3-16 PUBCOMP报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (7)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>剩余长度字段<br>表示可变报头的长度, 编码为<code>变长字节整数</code>.</p><h4 id="3-7-2-PUBCOMP可变报头"><a href="#3-7-2-PUBCOMP可变报头" class="headerlink" title="3.7.2 PUBCOMP可变报头"></a>3.7.2 PUBCOMP可变报头</h4><p>PUBCOMP报文可变报头按顺序包含以下字段:所确认的<code>PUBREL</code>报文标识符, <code>PUBCOMP</code>原因码, <code>属性</code>. <code>属性(Properties)</code>编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p><ul><li>图 3-17 PUBCOMP报文可变报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">报文标识符MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 3</td><td align="left">PUBCOMP原因码</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 4</td><td align="left">属性长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h5 id="3-7-2-1-PUBCOMP原因码"><a href="#3-7-2-1-PUBCOMP原因码" class="headerlink" title="3.7.2.1 PUBCOMP原因码"></a>3.7.2.1 PUBCOMP原因码</h5><p>可变报头第3字节是PUBCOMP原因码. 如果剩余长度为2, 则表示使用原因码<code>0x00(成功)</code>.</p><ul><li>表 3 7 – PUBCOMP原因码</li></ul><table><thead><tr><th align="left">值</th><th align="left">16进制</th><th align="left">原因码名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00</td><td align="left">成功</td><td align="left">报文标识符已释放.<code>QoS 2</code>消息已完成发布.</td></tr><tr><td align="left">146</td><td align="left">0x92</td><td align="left">报文标识符未发现</td><td align="left">未知的报文标识符. 会话恢复阶段这并非错误, 但其他时间这表明服务端和客户端的会话状态不匹配.</td></tr></tbody></table><p>服务端或客户端发送<code>PUBCOMP</code>报文时必须设置一种<code>PUBCOMP</code>原因码 [MQTT-3.7.2-1]. 当原因码为0x00(成功)且没有<code>属性(Properties)</code>时, 原因码和属性长度可以被省略. 在这种情况下, <code>PUBCOMP</code>剩余长度为2.</p><h5 id="3-7-2-2-PUBCOMP属性"><a href="#3-7-2-2-PUBCOMP属性" class="headerlink" title="3.7.2.2 PUBCOMP属性"></a>3.7.2.2 PUBCOMP属性</h5><h6 id="3-7-2-2-1-属性长度"><a href="#3-7-2-2-1-属性长度" class="headerlink" title="3.7.2.2.1 属性长度"></a>3.7.2.2.1 属性长度</h6><p>PUBCOMP报文可变报头中的属性长度被编码为<code>变长字节整数</code>. 如果剩余长度小于4, 则表示没有属性长度字段.</p><h6 id="3-7-2-2-2-原因字符串"><a href="#3-7-2-2-2-原因字符串" class="headerlink" title="3.7.2.2.2 原因字符串"></a>3.7.2.2.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不应该被接收端所解析.</p><p>发送端使用此值向接收端提供附加信息. 如果加上原因字符串之后的<code>PUBCOMP</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端<strong>不能</strong>发送此原因字符串 [MQTT-3.7.2-2]. 包含多个原因字符串将造成协议错误(Protocol Error).</p><h6 id="3-7-2-2-3-用户属性"><a href="#3-7-2-2-3-用户属性" class="headerlink" title="3.7.2.2.3 用户属性"></a>3.7.2.2.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于提供诊断信息或关于其他信息. 如果加上用户属性之后的<code>PUBCOMP</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端<strong>不能</strong>发送此属性 [MQTT-3.7.2-3]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字<strong>可以</strong>多次出现.</p><h4 id="3-7-3-PUBCOMP载荷"><a href="#3-7-3-PUBCOMP载荷" class="headerlink" title="3.7.3 PUBCOMP载荷"></a>3.7.3 PUBCOMP载荷</h4><p>PUBCOMP报文没有有效载荷.</p><h4 id="3-7-4-PUBCOMP行为"><a href="#3-7-4-PUBCOMP行为" class="headerlink" title="3.7.4 PUBCOMP行为"></a>3.7.4 PUBCOMP行为</h4><p>描述见4.3.3节.</p><h3 id="3-8-SUBSCRIBE-订阅请求"><a href="#3-8-SUBSCRIBE-订阅请求" class="headerlink" title="3.8 SUBSCRIBE - 订阅请求"></a>3.8 SUBSCRIBE - 订阅请求</h3><p>客户端向服务端发送<code>SUBSCRIBE</code>报文用于创建一个或多个订阅. 每个订阅(Subscription)注册客户端所感兴趣的一个或多个主题. 服务端向客户端发送<code>PUBLISH</code>报文以转发被发布到符合这些订阅主题的应用消息. <code>SUBSCRIBE</code>报文同样(为每个订阅)指定了服务端可以向其发送的应用消息<code>最大QoS等级</code>.</p><h4 id="3-8-1-SUBSCRIBE固定报头"><a href="#3-8-1-SUBSCRIBE固定报头" class="headerlink" title="3.8.1 SUBSCRIBE固定报头"></a>3.8.1 SUBSCRIBE固定报头</h4><ul><li>图 3-18 SUBSCRIBE报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (8)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p><code>SUBSCRIBE</code>报文固定报头第3, 2, 1, 0比特位是保留位, <strong>必须</strong>被设置为0, 0, 1, 0. 服务端<strong>必须</strong>将其他的任何值都当做是不合法的并关闭网络连接 [MQTT-3.8.1-1].</p><p>剩余长度字段<br>表示可变报头的长度加上有效载荷的长度, 被编码为<code>变长字节整数</code>.</p><h4 id="3-8-2-SUBSCRIBE可变报头"><a href="#3-8-2-SUBSCRIBE可变报头" class="headerlink" title="3.8.2 SUBSCRIBE可变报头"></a>3.8.2 SUBSCRIBE可变报头</h4><p>SUBSCRIBE报文可变报头按顺序包含以下字段:<code>报文标识符(Packet Identifier)</code>, <code>属性(Properties)</code>. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了更多关于报文标识符的信息. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p><pre><code>非规范示例图 3-19 展示了一个包含报文标识符为10, 且没有属性的SUBSCRIBE可变报头.</code></pre><ul><li>图 3-19 SUBSCRIBE可变报头示例</li></ul><table><thead><tr><th align="left"></th><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">报文标识符MSB(0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符LSB(10)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 3</td><td align="left">属性长度(0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h5 id="3-8-2-1-SUBSCRIBE属性"><a href="#3-8-2-1-SUBSCRIBE属性" class="headerlink" title="3.8.2.1 SUBSCRIBE属性"></a>3.8.2.1 SUBSCRIBE属性</h5><h6 id="3-8-2-1-1-属性长度"><a href="#3-8-2-1-1-属性长度" class="headerlink" title="3.8.2.1.1 属性长度"></a>3.8.2.1.1 属性长度</h6><p>SUBSCRIBE报文可变报头中的属性长度被编码为<code>变长字节整数</code>.</p><h6 id="3-8-2-1-2-订阅标识符"><a href="#3-8-2-1-2-订阅标识符" class="headerlink" title="3.8.2.1.2 订阅标识符"></a>3.8.2.1.2 订阅标识符</h6><p>11 (0x0B), <code>订阅标识符(Subscription Identifier)</code>标识符.<br>跟随其后的是一个变长字节整数表示<code>订阅标识符</code>. <code>订阅标识符</code>取值范围从1到268,435,455. <code>订阅标识符</code>的值为0或包含多个<code>订阅标识符</code>将造成协议错误(Protocol Error).</p><p><code>订阅标识符</code>与<code>SUBSCRIBE</code>报文所创建或修改的订阅(Subscription)相关联. 如果包含<code>订阅标识符</code>, 它将与订阅一起被存储. 如果未指定此属性, 则订阅被存储时将不包含<code>订阅标识符</code>.</p><p>更多关于<code>订阅标识符</code>的处理信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3831-订阅选项" target="_blank" rel="noopener">3.8.3.1节</a> .</p><h6 id="3-8-2-1-3-用户属性"><a href="#3-8-2-1-3-用户属性" class="headerlink" title="3.8.2.1.3 用户属性"></a>3.8.2.1.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对.</p><p><code>用户属性</code>允许出现多次, 以表示多个名字/值对. 同样的名字允许出现多次.</p><pre><code>非规范评注SUBSCRIBE报文的用户属性可以被客户端用来向服务端发送订阅相关的属性.本规范不定义这些属性的意义.</code></pre><h4 id="3-8-3-SUBSCRIBE载荷"><a href="#3-8-3-SUBSCRIBE载荷" class="headerlink" title="3.8.3 SUBSCRIBE载荷"></a>3.8.3 SUBSCRIBE载荷</h4><p><code>SUBSCRIBE</code>报文的载荷包含一列主题过滤器, 指明客户端希望订阅的主题. 主题过滤器必须为UTF-8 编码的字符串 [MQTT-3.8.3-1]. 每个主题过滤器之后跟着一个<code>订阅选项(Subscription Options)</code>字节.</p><p>载荷必须包含至少一个主题过滤器/订阅选项对 [MQTT-3.8.3-2]. 不包含载荷的<code>SUBSCRIBE</code>报文将造成协议错误(Protocol Error). 错误处理信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p><h5 id="3-8-3-1-订阅选项"><a href="#3-8-3-1-订阅选项" class="headerlink" title="3.8.3.1 订阅选项"></a>3.8.3.1 订阅选项</h5><p>订阅选项的第0和1比特代表<code>最大服务质量</code>字段. 此字段给出服务端可以向此客户端发送的应用消息的<code>最大QoS等级</code>. 最大服务质量字段为3将造成协议错误(Protocol Error).</p><p>订阅选项的第2比特表示非本地(No Local)选项. 值为1, 表示应用消息不能被转发给发布此消息的客户标识符 [MQTT-3.8.3-3]. 共享订阅时把非本地选项设为1将造成协议错误(Protocol Error) [MQTT-3.8.3-4].</p><p>订阅选项的第3比特表示<code>发布保留(Retain As Published)</code>选项. 值为1, 表示向此订阅转发应用消息时保持消息被发布时设置的<code>保留(RETAIN)</code>标志. 值为0, 表示向此订阅转发应用消息时把保留标志设置为0. 当订阅建立之后, 发送保留消息时保留标志设置为1.</p><p>订阅选项的第4和5比特表示保留操作(Retain Handling)选项. 此选项指示当订阅建立时, 是否发送保留消息. 此选项不影响之后的任何保留消息的发送. 如果没有匹配主题过滤器的保留消息, 则此选项所有值的行为都一样. 值可以设置为:</p><ul><li>0 = 订阅建立时发送保留消息</li><li>1 = 订阅建立时, 若该订阅当前不存在则发送保留消息</li><li>2 = 订阅建立时不要发送保留消息<br>保留操作的值设置为3将造成协议错误(Protocol Error).</li></ul><p>订阅选项的第6和7比特为将来所保留. 服务端必须把此保留位非0的<code>SUBSCRIBE</code>报文当做无效报文 [MQTT-3.8.3-5].</p><pre><code>非规范评注非本地(No Local)和发布保留(Retain As Published)订阅选项在客户端把消息发送给其他服务端的情况下, 可以被用来实现桥接.非规范评注已存在订阅的情况下不发送保留消息是很有用的, 比如重连完成时客户端不确定订阅是否在之前的会话连接中被创建.非规范评注不发送保存的保留消息给新创建的订阅是很有用的, 比如客户端希望接收变更通知且不需要知道最初的状态.非规范评注对于某个指示其不支持保留消息的服务端, 发布保留和保留处理选项的所有有效值都将得到同样的结果:订阅时不发送任何保留消息, 且所有消息的保留标志都会被设置为0.</code></pre><ul><li>图 3 20 – SUBSCRIBE报文载荷格式</li></ul><table><thead><tr><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">主题过滤器</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">长度Length MSB (0)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">长度Length LSB (3)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 3..N</td><td align="left">主题过滤器</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">订阅选项</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">保留位</td><td align="left">保留处理</td><td align="left">RAP</td><td align="left">NL</td><td align="left">QOS</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte N+1</td><td align="left">0</td><td align="left">0</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td><td align="left">X</td></tr></tbody></table><p><code>RAP</code>指发布保留(Retain as Published).<br><code>NL</code>指非本地(No Local).</p><pre><code>非规范示例图 3-21 展示了SUBSCRIBE载荷示例, 包含2个主题过滤器:第一个为“a/b” , QoS为1；第二个为“c/d” QoS为2.</code></pre><ul><li>图 3-21 载荷字节格式非规范示例</li></ul><table><thead><tr><th align="left"></th><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">主题过滤器</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">长度Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">长度Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left"><code>a</code>(0x61)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 4</td><td align="left"><code>/</code>(0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 5</td><td align="left"><code>b</code>(0x62)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">订阅选项</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 6</td><td align="left">订阅选项 (1)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">主题过滤器</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 7</td><td align="left">长度Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 8</td><td align="left">长度Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 9</td><td align="left"><code>a</code>(0x61)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 10</td><td align="left"><code>/</code>(0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 11</td><td align="left"><code>b</code>(0x62)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">订阅选项</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 12</td><td align="left">订阅选项 (2)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr></tbody></table><h4 id="3-8-4-SUBSCRIBE行为"><a href="#3-8-4-SUBSCRIBE行为" class="headerlink" title="3.8.4 SUBSCRIBE行为"></a>3.8.4 SUBSCRIBE行为</h4><p>当服务端收到来自客户端的<code>SUBSCRIBE</code>报文时, <strong>必须</strong>使用<code>SUBACK</code>报文作为相应 [MQTT-3.8.4-1]. <code>SUBACK</code>报文<strong>必须</strong>和待确认的<code>SUBSCRIBE</code>报文有相同的报文标识符 [MQTT-3.8.4-2].</p><p>允许服务端在发送<code>SUBACK</code>报文之前就开始发送与订阅相匹配的<code>PUBLISH</code>报文.</p><p>如果服务端收到的<code>SUBSCRIBE</code>报文中的一个主题过滤器与当前会话的一个<code>非共享订阅(Non-shared Subscription)</code>相同, 那么<strong>必须</strong>使用新的订阅替换现存的订阅 [MQTT-3.8.4-3]. 新订阅的主题过滤器与之前的订阅相同, 但其订阅选项可能不同. 如果保留处理选项为0, 任何匹配该主题过滤器的保留消息<strong>必须</strong>被重发, 但替换订阅<strong>不能</strong>造成应用消息的丢失 [MQTT-3.8.4-4].</p><p>如果服务端收到的<code>非共享主题过滤器(Non-shared Topic Filter)</code>不同于当前会话的任何主题过滤器, 一个新的非共享订阅将被创建. 如果保留处理选项不为2, 所有相匹配的保留消息将发送给客户端.</p><p>如果服务端收到的主题过滤器与服务端已存在的某个<code>共享订阅(Shared Subscription)</code>主题过滤器相同, 则将此会话添加到该<code>共享订阅</code>中. 不发送任何保留消息.</p><p>如果服务端收到的<code>共享订阅主题过滤器(Shared Subscription Topic Filter)</code>与任何已存在的<code>共享订阅主题过滤器</code>都不同, 一个新的共享订阅将被创建. 将此会话作为订阅者添加到该共享订阅. 不发送任何保留消息.</p><p>更多关于共享订阅的细节, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#48-订阅" target="_blank" rel="noopener">4.8节</a>.</p><p>如果服务端收到的<code>SUBSCRIBE</code>报文包含多个主题过滤器, 服务端<strong>必须</strong>当做收到一系列多个<code>SUBSCRIBE</code>报文来处理–除了将它们的响应组合为单个<code>SUBACK</code>响应 [MQTT-3.8.4-5].</p><p>服务端发送给客户端的SUBACK报文<strong>必须</strong>为每一个主题过滤器/订阅选项对包含一个原因码 [MQTT-3.8.4-6]. 此原因码<strong>必须</strong>说明为该订阅授予的<code>最大QoS等级</code>, 或指示订阅失败 [MQTT-3.8.4-7]. 服务端可能授予了低于订阅者所请求的<code>最大QoS等级</code>. 响应该订阅的应用消息<code>QoS等级</code><strong>必须</strong>为该消息发布时的<code>QoS等级</code>和服务端授予的<code>最大QoS等级</code>二者最小值 [MQTT-3.8.4-8]. 在原始消息发布的<code>QoS等级</code>为1, 且授予的<code>最大QoS等级</code>为0的情况下, 服务端允许发送重复的消息副本给订阅者(？).</p><pre><code>非规范评注如果订阅客户端的某个主题过滤器已被授予的最大QoS等级为1, 那么匹配此过滤器的QoS等级为0的应用消息按照QoS等级为0分发给此客户端.这意味着客户端最多只能收到该消息的一个副本.另一方面, 发布到相同主题的QoS等级为2的消息, 其QoS等级被服务端降级为1以便分发给该客户端. 因此该客户端可能收到此消息的多个副本. 非规范评注如果订阅客户端被授予的最大QoS等级为0, 那么按照QoS等级为2发布的应用消息在繁忙时可能会丢失, 但服务端不应该发送重复的消息副本. 发布到相同主题的QoS等级为1的消息, 分发给该客户端时可能会丢失或重复.非规范评注使用QoS等级2订阅某个主题过滤器, 等于是说:我想要按照消息被发布时的QoS等级接收匹配此过滤器的消息. 这意味着发布者负责决定消息可以被发布的最大QoS等级, 但订阅端可以要求服务端降低该消息的QoS到更适合它的等级.</code></pre><p>订阅标识符是服务端的会话状态的一部分, 并将在收到<code>PUBLISH</code>报文时返回给客户端. 当服务端收到客户端的<code>UNSUBSCRIBE</code>报文时, 服务端将此会话标识符从服务端的会话状态中移除:当服务端收到客户端的<code>UNSUBSCRIBE</code>报文, 当服务端收到客户端对同样主题过滤器的<code>SUBSCRIBE</code>报文但订阅标识符不同或没有订阅标识符, 或者当服务端在<code>CONNACK</code>报文中将会话存在标志设置为0.</p><p>订阅标识符不构成客户端的会话状态的一部分. 在一个有用的实现中, 客户端将订阅标识符与其他客户端状态相关联, 此客户端状态将被移除:当客户端取消订阅, 当客户端以不同的订阅标识符或没有订阅标识符订阅同样的主题过滤器, 或者当客户端收到的<code>CONNACK</code>报文中会话存在标志被设置为0.</p><p>服务端在重传的<code>PUBLISH</code>报文中无需使用同一组订阅标识符. 客户端可以通过发送包含与当前会话已存在的主题过滤器的<code>SUBSCRIBE</code>报文进行重新订阅. 如果客户端在<code>PUBLISH</code>报文初传之后重新订阅并使用了不同的订阅标识符, 允许服务端在任何重传中使用初传所包含的订阅标识符, 或者在重传中使用此新的订阅标识符. 不允许服务端在发送了包含新的订阅标识符的<code>PUBLISH</code>报文之后再次使用旧的订阅标识符.</p><pre><code>非规范评注使用场景, 用以阐述订阅标识符:• 客户端实现指示某条发布消息匹配多个订阅的编程接口, 客户端实现每次订阅时生成新的订阅标识符. 如果返回的发布消息包含多个订阅标识符, 则该发布消息匹配多个订阅.• 客户端实现允许订阅者将消息定向到其相关联的订阅的回调, 客户端实现生成映射到唯一回调的订阅标识符. 收到某条发布消息时, 使用订阅标识符决定触发哪一个回调.• 客户端实现在发布消息时返回程序用于订阅的主题字符串, 为此客户端生成一个唯一标识了该主题过滤器的标识符. 收到某条发布消息时, 客户端实现使用此标识符查找原始主题过滤器, 并将主题过滤器返回给其应用程序.• 网关(Gateway)将从服务端收到的发布消息转发给向该网关做了订阅的客户端, 网关实现维护其收到的每个唯一的订阅过滤器到其收到的一组客户标识符--订阅标识符对的映射, 网关对它转发给服务端的每个主题过滤器生成一个唯一的标识符. 收到某条发布消息时, 网关使用从服务端收到的订阅标识符查找对应的客户标识符--订阅标识符对, 并把它们加入发送给客户端的PUBLISH报文中. 如果上游服务端因为消息匹配了多个订阅而发送了多个PUBLISH报文, 则此行为将反映到客户端.</code></pre><p>3.9 SUBACK – 订阅确认<br>服务端发送SUBACK报文给客户端, 用于确认它已收到并且正在处理<code>SUBSCRIBE</code>报文.</p><p><code>SUBACK</code>报文包含一个原因码列表, 用于指定授予的<code>最大QoS等级</code>或<code>SUBSCRIBE</code>报文所请求的每个订阅发生的错误.</p><h4 id="3-9-1-SUBACK固定报头"><a href="#3-9-1-SUBACK固定报头" class="headerlink" title="3.9.1 SUBACK固定报头"></a>3.9.1 SUBACK固定报头</h4><ul><li>图 3-22 SUBACK报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (9)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>剩余长度字段<br>可变报头长度加上有效载荷长度, 编码为<code>变长字节整数</code>.</p><h4 id="3-9-2-SUBACK可变报头"><a href="#3-9-2-SUBACK可变报头" class="headerlink" title="3.9.2 SUBACK可变报头"></a>3.9.2 SUBACK可变报头</h4><p>SUBACK报文可变报头按顺序包含以下字段: 所确认的<code>SUBSCRIBE</code>报文标识符, <code>属性(Properties)</code>.</p><h5 id="3-9-2-1-SUBACK属性"><a href="#3-9-2-1-SUBACK属性" class="headerlink" title="3.9.2.1 SUBACK属性"></a>3.9.2.1 SUBACK属性</h5><h6 id="3-9-2-1-1-属性长度"><a href="#3-9-2-1-1-属性长度" class="headerlink" title="3.9.2.1.1 属性长度"></a>3.9.2.1.1 属性长度</h6><p>SUBACK可变报头中的属性长度被编码为<code>变长字节整数</code>.</p><h6 id="3-9-2-1-2-原因字符串"><a href="#3-9-2-1-2-原因字符串" class="headerlink" title="3.9.2.1.2 原因字符串"></a>3.9.2.1.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, <strong>不应该</strong>被客户端所解析.</p><p>服务端使用此值向客户端提供附加信息. 如果加上原因字符串之后的<code>SUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此原因字符串 [MQTT-3.9.2-1]. 包含多个原因字符串将造成协议错误(Protocol Error).</p><h6 id="3-9-2-1-3-用户属性"><a href="#3-9-2-1-3-用户属性" class="headerlink" title="3.9.2.1.3 用户属性"></a>3.9.2.1.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对.此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上用户属性之后的SUBACK报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此属性 [MQTT-3.9.2-2]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p><ul><li>图 3-23 SUBACK报文可变报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">报文标识符MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h4 id="3-9-3-SUBACK载荷"><a href="#3-9-3-SUBACK载荷" class="headerlink" title="3.9.3 SUBACK载荷"></a>3.9.3 SUBACK载荷</h4><p>有效载荷包含一个原因码列表. 每个原因码对应SUBSCRIBE报文中的一个被确认的主题过滤器. SUBACK报文中的原因码顺序必须与SUBSCRIBE报文中的主题过滤器顺序相匹配 [MQTT-3.9.3-1].</p><ul><li>表 3-8 订阅原因码</li></ul><table><thead><tr><th align="left">值</th><th align="left">16进制</th><th align="left">原因码名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00</td><td align="left">授予QoS等级0</td><td align="left">订阅被接受且最大QoS等级为0.可能低于所请求的QoS等级.</td></tr><tr><td align="left">1</td><td align="left">0x01</td><td align="left">授予QoS等级1</td><td align="left">订阅被接受且最大QoS等级为1.可能低于所请求的QoS等级.</td></tr><tr><td align="left">2</td><td align="left">0x02</td><td align="left">授予QoS等级2</td><td align="left">订阅被接受且任何QoS等级都将被发送给此订阅.</td></tr><tr><td align="left">128</td><td align="left">0x80</td><td align="left">未指明错误</td><td align="left">订阅未被接受, 且服务端不愿意透露原因或没有适用的原因码.</td></tr><tr><td align="left">131</td><td align="left">0x83</td><td align="left">实现特定错误</td><td align="left">SUBSCRIBE有效但不被服务端所接受.</td></tr><tr><td align="left">135</td><td align="left">0x87</td><td align="left">未授权</td><td align="left">客户端未被授权做此订阅.</td></tr><tr><td align="left">143</td><td align="left">0x8F</td><td align="left">主题过滤器无效</td><td align="left">主题过滤器格式正确, 但不被允许.</td></tr><tr><td align="left">145</td><td align="left">0x91</td><td align="left">报文标识符已占用</td><td align="left">指定的报文标识符正在被使用中.</td></tr><tr><td align="left">151</td><td align="left">0x97</td><td align="left">超出配额</td><td align="left">已超出实现限制或管理限制.</td></tr><tr><td align="left">158</td><td align="left">0x9E</td><td align="left">共享订阅不支持</td><td align="left">服务端不支持此客户端进行共享订阅.</td></tr><tr><td align="left">161</td><td align="left">0xA1</td><td align="left">订阅标识符不支持</td><td align="left">服务端不支持订阅标识符；订阅标识符不被接受.</td></tr><tr><td align="left">162</td><td align="left">0xA2</td><td align="left">通配符订阅不支持</td><td align="left">服务端不支持通配符订阅；订阅未被接受.</td></tr></tbody></table><p>服务端发送SUBACK报文时必须对收到的每一个主题过滤器设置一种原因码 [MQTT-3.9.3-2].</p><pre><code>非规范评注对于SUBSCRIBE报文中的每个主题过滤器, 总有一个对应的原因码. 如果原因码不是针对某个特定的主题过滤器(比如0x91(报文标识符已占用)), 则对每个主题过滤器都使用此原因码.</code></pre><h3 id="3-10-UNSUBSCRIBE-–-取消订阅请求"><a href="#3-10-UNSUBSCRIBE-–-取消订阅请求" class="headerlink" title="3.10 UNSUBSCRIBE – 取消订阅请求"></a>3.10 UNSUBSCRIBE – 取消订阅请求</h3><p>客户端发送UNSUBSCRIBE报文给服务端, 用于取消订阅主题.</p><h4 id="3-10-1-UNSUBSCRIBE固定报头"><a href="#3-10-1-UNSUBSCRIBE固定报头" class="headerlink" title="3.10.1 UNSUBSCRIBE固定报头"></a>3.10.1 UNSUBSCRIBE固定报头</h4><p>图 3-28 – UNSUBSCRIBE报文固定报头</p><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (10)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>UNSUBSCRIBE固定报头的第3, 2, 1, 0位是保留位且<strong>必须</strong>分别设置为0, 0, 1, 0. 服务端<strong>必须</strong>认为任何其它的值都是不合法的并关闭网络连接 [MQTT-3.10.1-1].</p><p>剩余长度字段<br>等于可变报头长度(2字节)加上有效载荷长度, 编码为<code>变长字节整数</code>.</p><h4 id="3-10-2-UNSUBSCRIBE可变报头"><a href="#3-10-2-UNSUBSCRIBE可变报头" class="headerlink" title="3.10.2 UNSUBSCRIBE可变报头"></a>3.10.2 UNSUBSCRIBE可变报头</h4><p>UNSUBSCRIBE报文可变报头按顺序包含以下字段:<code>报文标识符</code>和<code>属性(Properties)</code>. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了有关报文标识符的更多信息. 属性的编码规则, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p><h4 id="3-10-2-1-UNSUBSCRIBE属性"><a href="#3-10-2-1-UNSUBSCRIBE属性" class="headerlink" title="3.10.2.1 UNSUBSCRIBE属性"></a>3.10.2.1 UNSUBSCRIBE属性</h4><h6 id="3-10-2-1-1-属性长度"><a href="#3-10-2-1-1-属性长度" class="headerlink" title="3.10.2.1.1 属性长度"></a>3.10.2.1.1 属性长度</h6><p>SUBSCRIBE可变报头中属性的长度被编码为<code>变长字节整数</code>.</p><h6 id="3-10-2-1-2-用户属性"><a href="#3-10-2-1-2-用户属性" class="headerlink" title="3.10.2.1.2 用户属性"></a>3.10.2.1.2 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是一个UTF-8字符串对.</p><p>用户属性允许出现多次, 以表示多个名字/值对. 相同的名字可以出现多次.</p><pre><code>非规范评注UNSUBSCRIBE报文中的用户属性可以被客户端用来向服务端发送订阅相关的属性. 本规范不定义这些属性的意义.</code></pre><h4 id="3-10-3-UNSUBSCRIBE载荷"><a href="#3-10-3-UNSUBSCRIBE载荷" class="headerlink" title="3.10.3 UNSUBSCRIBE载荷"></a>3.10.3 UNSUBSCRIBE载荷</h4><p>UNSUBSCRIBE报文有效载荷包含一列客户端希望取消订阅的主题过滤器. <code>UNSUBSCRIBE</code>报文中的<code>主题过滤器</code><strong>必须</strong>为<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 所述的UTF-8编码字符串 [MQTT-3.10.3-1], 且连续填充.</p><p><code>UNSUBSCRIBE</code>报文有效载荷<strong>必须</strong>包含至少一个<code>主题过滤器</code> [MQTT-3.10.3-2]. 不包含有效载荷的<code>UNSUBSCRIBE</code>报文将造成协议错误(Protocol Error). 错误处理信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p><pre><code>非规范示例图 3-30 展示了UNSUBSCRIBE报文的载荷示例, 包括两个主题过滤器 “a/b”和“c/d”.</code></pre><p>图 3-30 - 载荷字节格式非规范示例</p><table><thead><tr><th align="left"></th><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">主题过滤器</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left">长度Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">长度Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left"><code>a</code>(0x61)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 4</td><td align="left"><code>/</code>(0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 5</td><td align="left"><code>b</code>(0x62)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">主题过滤器</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 6</td><td align="left">长度Length MSB (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 7</td><td align="left">长度Length LSB (3)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 8</td><td align="left"><code>c</code>(0x61)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 9</td><td align="left"><code>/</code>(0x2F)</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">byte 10</td><td align="left"><code>d</code>(0x62)</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h4 id="3-10-4-UNSUBSCRIBE行为"><a href="#3-10-4-UNSUBSCRIBE行为" class="headerlink" title="3.10.4 UNSUBSCRIBE行为"></a>3.10.4 UNSUBSCRIBE行为</h4><p>服务端<strong>必须</strong>对客户端的<code>UNSUBSCRIBE</code>报文中提供的主题过滤器(不管是否包含通配符)逐个字符与当前持有的主题过滤器集进行比较. 如果任何过滤器完全匹配, 则<strong>必须</strong>删除其拥有的订阅 [MQTT-3.10.4-1], 否则不会进行额外的处理.</p><p>当服务端收到<code>UNSUBSCRIBE</code>报文:</p><ul><li></li><li><p>它<strong>必须</strong>停止添加为了交付给客户端的与主题过滤器相匹配的任何新消息 [MQTT-3.10.4-2].</p></li><li><p>它必须完成任何已经开始发送给客户端的、与主题过滤器相匹配的、QoS等级为1或2的消息 [MQTT-3.10.4-3].</p></li><li><p>它<strong>可以</strong>继续交付任何为交付给客户端而缓存的消息.</p></li></ul><p>服务端必须发送<code>UNSUBACK</code>报文以响应客户端的<code>UNSUBSCRIBE</code>请求 [MQTT-3.10.4-4]. <code>UNSUBACK</code>报文<strong>必须</strong>包含和<code>UNSUBSCRIBE</code>报文相同的报文标识符. 即使没有删除任何主题订阅, 服务端也<strong>必须</strong>发送一个<code>UNSUBACK</code>响应 [MQTT-3.10.4-5].</p><p>如果服务端收到的<code>UNSUBSCRIBE</code>报文包含多个主题过滤器, 服务端<strong>必须</strong>当做收到一系列多个<code>UNSUBSCRIBE</code>报文来处理–除了将它们的响应组合为单个<code>SUBACK</code>响应 [MQTT-3.10.4-6].</p><p>如果某个主题过滤器代表一个共享订阅, 此会话将被从该共享订阅中删除. 如果此会话是该共享订阅所关联的唯一会话, 该共享订阅被删除. 共享订阅的处理, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">4.8.2节</a>.</p><h3 id="3-11-UNSUBACK-–-取消订阅确认"><a href="#3-11-UNSUBACK-–-取消订阅确认" class="headerlink" title="3.11 UNSUBACK – 取消订阅确认"></a>3.11 UNSUBACK – 取消订阅确认</h3><p>服务端发送UNSUBACK报文给客户端用于确认收到<code>UNSUBSCRIBE</code>报文.</p><h4 id="3-11-1-UNSUBACK固定报头"><a href="#3-11-1-UNSUBACK固定报头" class="headerlink" title="3.11.1 UNSUBACK固定报头"></a>3.11.1 UNSUBACK固定报头</h4><ul><li>图 3-31 UNSUBACK报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (11)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>剩余长度字段<br>等于可变报头的长度加上有效载荷的长度, 编码为<code>变长字节整数</code>.</p><h4 id="3-11-2-UNSUBACK可变报头"><a href="#3-11-2-UNSUBACK可变报头" class="headerlink" title="3.11.2 UNSUBACK可变报头"></a>3.11.2 UNSUBACK可变报头</h4><p>UNSUBACK报文可变报头按顺序包含以下字段:所确认的<code>UNSUBSCRIBE</code>报文标识符和属性( Properties). 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p><ul><li>图 3-32 UNSUBACK报文可变报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">报文标识符MSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">报文标识符LSB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h5 id="3-11-2-1-UNSUBACK属性"><a href="#3-11-2-1-UNSUBACK属性" class="headerlink" title="3.11.2.1 UNSUBACK属性"></a>3.11.2.1 UNSUBACK属性</h5><h6 id="3-11-2-1-1-属性长度"><a href="#3-11-2-1-1-属性长度" class="headerlink" title="3.11.2.1.1 属性长度"></a>3.11.2.1.1 属性长度</h6><p>UNSUBACK报文可变报头中的属性的长度被编码为<code>变长字节整数</code>.</p><h6 id="3-11-2-1-2-原因字符串"><a href="#3-11-2-1-2-原因字符串" class="headerlink" title="3.11.2.1.2 原因字符串"></a>3.11.2.1.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, <strong>不应该</strong>被客户端所解析.</p><p>服务端使用此值向客户端提供附加信息. 如果加上原因字符串之后的<code>UNSUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此原因字符串 [MQTT-3.11.2-1]. 包含多个原因字符串将造成协议错误(Protocol Error).</p><h6 id="3-11-2-1-3-用户属性"><a href="#3-11-2-1-3-用户属性" class="headerlink" title="3.11.2.1.3 用户属性"></a>3.11.2.1.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上用户属性之后的<code>UNSUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此属性 [MQTT-3.11.2-2]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p><h4 id="3-11-3-UNSUBACK载荷"><a href="#3-11-3-UNSUBACK载荷" class="headerlink" title="3.11.3 UNSUBACK载荷"></a>3.11.3 UNSUBACK载荷</h4><p>有效载荷包含一个原因码列表. 每个原因码对应<code>UNSUBSCRIBE</code>报文中的一个被确认的主题过滤器. <code>UNSUBACK</code>报文中的原因码顺序<strong>必须</strong>与<code>UNSUBSCRIBE</code>报文中的主题过滤器顺序相匹配 [MQTT-3.11.3-1].</p><p>单字节无符号取消订阅原因码的值如下所示. 服务端发送<code>UNSUBACK</code>报文时对于每个收到的主题过滤器, <strong>必须</strong>使用一个取消订阅原因码 [MQTT-3.11.3-2].</p><ul><li>表 3-9 取消订阅原因码</li></ul><table><thead><tr><th align="left">值</th><th align="left">16进制</th><th align="left">原因码名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00</td><td align="left">成功</td><td align="left">订阅已被删除.</td></tr><tr><td align="left">17</td><td align="left">0x11</td><td align="left">订阅未发现</td><td align="left">没有该客户端匹配的主题过滤器被使用.</td></tr><tr><td align="left">128</td><td align="left">0x80</td><td align="left">未指定错误</td><td align="left">取消订阅不能被完成且服务端不愿意透露原因或没有其他适用的原因码.</td></tr><tr><td align="left">131</td><td align="left">0x83</td><td align="left">实现指定错误</td><td align="left">UNSUBSCRIBE报文有效, 但服务端不接受.</td></tr><tr><td align="left">135</td><td align="left">0x87</td><td align="left">未授权</td><td align="left">客户端未被授权进行取消订阅.</td></tr><tr><td align="left">143</td><td align="left">0x8F</td><td align="left">主题过滤器无效</td><td align="left">主题过滤器格式正确, 但不被允许.</td></tr><tr><td align="left">145</td><td align="left">0x91</td><td align="left">报文标识符已占用</td><td align="left">指定的报文标识符正在被使用中.</td></tr></tbody></table><pre><code>非规范评注对于UNSUBSCRIBE报文中的每个主题过滤器, 总有一个对应的原因码. 如果原因码不是针对某个特定的主题过滤器(比如0x91(报文标识符已占用)), 则对每个主题过滤器都使用此原因码.</code></pre><h3 id="3-12-PINGREQ-–-PING请求"><a href="#3-12-PINGREQ-–-PING请求" class="headerlink" title="3.12 PINGREQ – PING请求"></a>3.12 PINGREQ – PING请求</h3><p>客户端发送<code>PINGREQ</code>报文给服务端, 可被用于:</p><ul><li>在没有任何其他MQTT控制报文从客户端发给服务端时, 告知服务端客户端还活着.</li><li>请求服务端发送响应以确认服务端还活着.</li><li>使用网络已确认网络连接没有断开.</li></ul><p>此报文被用在<code>保持连接(Keep Alive)</code>的处理中. 详细信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#31210-保持连接" target="_blank" rel="noopener">3.1.2.10节</a>.</p><h4 id="3-12-1-PINGREQ固定报头"><a href="#3-12-1-PINGREQ固定报头" class="headerlink" title="3.12.1 PINGREQ固定报头"></a>3.12.1 PINGREQ固定报头</h4><ul><li>图 3-33 PINGREQ报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (12)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h4 id="3-12-2-PINGREQ可变报头"><a href="#3-12-2-PINGREQ可变报头" class="headerlink" title="3.12.2 PINGREQ可变报头"></a>3.12.2 PINGREQ可变报头</h4><p>PINGREQ报文没有可变报头.</p><h4 id="3-12-3-PINGREQ载荷"><a href="#3-12-3-PINGREQ载荷" class="headerlink" title="3.12.3 PINGREQ载荷"></a>3.12.3 PINGREQ载荷</h4><p>PINGREQ报文没有有效载荷</p><h4 id="3-12-4-PINGREQ行为"><a href="#3-12-4-PINGREQ行为" class="headerlink" title="3.12.4 PINGREQ行为"></a>3.12.4 PINGREQ行为</h4><p>服务端<strong>必须</strong>发送<code>PINGRESP</code>报文响应客户端的<code>PINGREQ</code>报文 [MQTT-3.12.4-1].</p><h3 id="3-13-PINGRESP-–-PING响应"><a href="#3-13-PINGRESP-–-PING响应" class="headerlink" title="3.13 PINGRESP – PING响应"></a>3.13 PINGRESP – PING响应</h3><p>服务端发送PINGRESP报文响应客户端的<code>PINGREQ</code>报文.表示服务端还活着.</p><p>此报文被用在<code>保持连接(Keep Alive)</code>的处理中.详细信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#31210-保持连接" target="_blank" rel="noopener">3.1.2.10节</a>.</p><h4 id="3-13-1-PINGRESP固定报头"><a href="#3-13-1-PINGRESP固定报头" class="headerlink" title="3.13.1 PINGRESP固定报头"></a>3.13.1 PINGRESP固定报头</h4><ul><li>图 3-34 – PINGRESP报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (13)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h4 id="3-13-2-PINGRESP可变报头"><a href="#3-13-2-PINGRESP可变报头" class="headerlink" title="3.13.2 PINGRESP可变报头"></a>3.13.2 PINGRESP可变报头</h4><p>PINGRESP报文没有可变报头.</p><h4 id="3-13-3-PINGRESP载荷"><a href="#3-13-3-PINGRESP载荷" class="headerlink" title="3.13.3 PINGRESP载荷"></a>3.13.3 PINGRESP载荷</h4><p>PINGRESP报文没有有效载荷.</p><h4 id="3-13-4-PINGRESP行为"><a href="#3-13-4-PINGRESP行为" class="headerlink" title="3.13.4 PINGRESP行为"></a>3.13.4 PINGRESP行为</h4><p>客户端收到此报文时不做任何处理.</p><h3 id="3-14-DISCONNECT-–-断开通知"><a href="#3-14-DISCONNECT-–-断开通知" class="headerlink" title="3.14 DISCONNECT – 断开通知"></a>3.14 DISCONNECT – 断开通知</h3><p><code>DISCONNECT</code>报文是客户端发给服务端的最后一个MQTT控制报文. 表示客户端为什么断开网络连接的原因. 客户端和服务端在关闭网络连接之前可以发送一个<code>DISCONNECT</code>报文. 如果在客户端没有首先发送包含原因码为<code>0x00(正常断开)</code> <code>DISCONNECT</code>报文并且连接包含遗嘱消息的情况下, 遗嘱消息会被发布. 更多细节, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a>.</p><p>服务端不能发送<code>DISCONNECT</code>报文, 直到它发送了包含原因码小于0x80的<code>CONNACK</code>报文之后 [MQTT-3.14.0-1].</p><h4 id="3-14-1-DISCONNECT固定报头"><a href="#3-14-1-DISCONNECT固定报头" class="headerlink" title="3.14.1 DISCONNECT固定报头"></a>3.14.1 DISCONNECT固定报头</h4><ul><li>图 3-35 DISCONNECT报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (14)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>服务端或客户端<strong>必须</strong>验证所有的保留位都被设置为0, 如果他们不为0, 发送包含原因码为<code>0x81(无效报文)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述 [MQTT-3.14.1-1].</p><p>剩余长度字段<br>等于可变报头的长度, 编码为<code>变长字节整数</code>.</p><h4 id="3-14-2-DISCONNECT可变报头"><a href="#3-14-2-DISCONNECT可变报头" class="headerlink" title="3.14.2 DISCONNECT可变报头"></a>3.14.2 DISCONNECT可变报头</h4><p>DISCONNECT报文的可变报头按顺序包含以下字段:<code>断开原因码</code>, <code>属性(Properties)</code>. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p><h4 id="3-14-2-1-断开原因码"><a href="#3-14-2-1-断开原因码" class="headerlink" title="3.14.2.1 断开原因码"></a>3.14.2.1 断开原因码</h4><p>可变报头的第1个字节是断开原因码. 如果剩余长度小于1, 则表示使用原因码<code>0x00(正常断开)</code>.</p><p>单字节无符号断开原因码字段如下所示.</p><ul><li>表 3-10 断开原因值</li></ul><table><thead><tr><th align="left">值</th><th align="left">16进制</th><th align="left">原因码名称</th><th align="left">发送端</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00</td><td align="left">正常断开</td><td align="left">客户端或服务端</td><td align="left">正常关闭连接.不发送遗嘱.</td></tr><tr><td align="left">4</td><td align="left">0x04</td><td align="left">包含遗嘱消息的断开</td><td align="left">客户端</td><td align="left">客户端希望断开但也需要服务端发布它的遗嘱消息.</td></tr><tr><td align="left">128</td><td align="left">0x80</td><td align="left">未指定错误</td><td align="left">客户端或服务端</td><td align="left">连接被关闭, 但发送端不愿意透露原因, 或者没有其他适用的原因码.</td></tr><tr><td align="left">129</td><td align="left">0x81</td><td align="left">无效的报文</td><td align="left">客户端或服务端</td><td align="left">收到的报文不符合本规范.</td></tr><tr><td align="left">130</td><td align="left">0x82</td><td align="left">协议错误</td><td align="left">客户端或服务端</td><td align="left">收到意外的或无序的报文.</td></tr><tr><td align="left">131</td><td align="left">0x83</td><td align="left">实现指定错误</td><td align="left">客户端或服务端</td><td align="left">收到的报文有效, 但根据实现无法进行处理.</td></tr><tr><td align="left">135</td><td align="left">0x87</td><td align="left">未授权</td><td align="left">服务端</td><td align="left">请求没有被授权</td></tr><tr><td align="left">137</td><td align="left">0x89</td><td align="left">服务端正忙</td><td align="left">服务端</td><td align="left">服务端正忙且不能继续处理此客户端的请求.</td></tr><tr><td align="left">139</td><td align="left">0x8B</td><td align="left">服务正关闭</td><td align="left">服务端</td><td align="left">服务正在关闭.</td></tr><tr><td align="left">141</td><td align="left">0x8D</td><td align="left">保持连接超时</td><td align="left">服务端</td><td align="left">连接因为在超过1.5倍的保持连接时间内没有收到任何报文而关闭.</td></tr><tr><td align="left">142</td><td align="left">0x8E</td><td align="left">会话被接管</td><td align="left">服务端</td><td align="left">另一个使用了相同的客户标识符的连接已建立, 导致此连接关闭.</td></tr><tr><td align="left">143</td><td align="left">0x8F</td><td align="left">主题过滤器无效</td><td align="left">服务端</td><td align="left">主题过滤器格式正确, 但不被服务端所接受.</td></tr><tr><td align="left">144</td><td align="left">0x90</td><td align="left">主题名无效</td><td align="left">客户端或服务端</td><td align="left">主题名格式正确, 但不被客户端或服务端所接受.</td></tr><tr><td align="left">147</td><td align="left">0x93</td><td align="left">超出接收最大值</td><td align="left">客户端或服务端</td><td align="left">客户端或服务端收到了数量超过接收最大值的未发送PUBACK或PUBCOMP的发布消息.</td></tr><tr><td align="left">148</td><td align="left">0x94</td><td align="left">主题别名无效</td><td align="left">客户端或服务端</td><td align="left">客户端或服务端收到的PUBLISH报文包含的主题别名大于其在CONNECT或CONNACK中发送的主题别名最大值.</td></tr><tr><td align="left">149</td><td align="left">0x95</td><td align="left">报文过大</td><td align="left">客户端或服务端</td><td align="left">报文长度大于此客户端或服务端的最大报文长度.</td></tr><tr><td align="left">150</td><td align="left">0x96</td><td align="left">消息速率过高</td><td align="left">客户端或服务端</td><td align="left">收到的数据速率太高.</td></tr><tr><td align="left">151</td><td align="left">0x97</td><td align="left">超出配额</td><td align="left">客户端或服务端</td><td align="left">已超出实现限制或管理限制.</td></tr><tr><td align="left">152</td><td align="left">0x98</td><td align="left">管理操作</td><td align="left">客户端或服务端</td><td align="left">连接因为管理操作被关闭.</td></tr><tr><td align="left">153</td><td align="left">0x99</td><td align="left">载荷格式无效</td><td align="left">客户端或服务端</td><td align="left">载荷格式与指定的载荷格式指示符不匹配.</td></tr><tr><td align="left">154</td><td align="left">0x9A</td><td align="left">不支持保留</td><td align="left">服务端</td><td align="left">服务端不支持保留消息.</td></tr><tr><td align="left">155</td><td align="left">0x9B</td><td align="left">不支持的QoS等级</td><td align="left">服务端</td><td align="left">客户端指定的QoS等级大于CONNACK报文中指定的最大QoS等级.</td></tr><tr><td align="left">156</td><td align="left">0x9C</td><td align="left">(临时)使用其他服务端</td><td align="left">服务端</td><td align="left">客户端应该临时使用其他服务端.</td></tr><tr><td align="left">157</td><td align="left">0x9D</td><td align="left">服务端已(永久)移动</td><td align="left">服务端</td><td align="left">服务端已移动且客户端应该永久使用其他服务端.</td></tr><tr><td align="left">158</td><td align="left">0x9E</td><td align="left">不支持共享订阅</td><td align="left">服务端</td><td align="left">服务端不支持共享订阅.</td></tr><tr><td align="left">159</td><td align="left">0x9F</td><td align="left">超出连接速率限制</td><td align="left">服务端</td><td align="left">此连接因为连接速率过高而被关闭.</td></tr><tr><td align="left">160</td><td align="left">0xA0</td><td align="left">最大连接时间</td><td align="left">服务端</td><td align="left">超出为此连接授予的最大连接时间.</td></tr><tr><td align="left">161</td><td align="left">0xA1</td><td align="left">不支持订阅标识符</td><td align="left">服务端</td><td align="left">服务端不支持订阅标识符；订阅未被接受.</td></tr><tr><td align="left">162</td><td align="left">0xA2</td><td align="left">不支持通配符订阅</td><td align="left">服务端</td><td align="left">服务端不支持通配符订阅；订阅未被接受.</td></tr></tbody></table><p>客户端或服务端发送<code>DISCONNECT</code>报文时必须使用一种<code>DISCONNECT</code>原因码 [MQTT-3.14.2-1]. 如果原因码为<code>0x00(正常断开)</code>且没有属性, 原因码和属性长度可以被省略. 这种情况下<code>DISCONNECT</code>报文剩余长度为0.</p><pre><code>非规范评注DISCONNECT报文用于指示断开的原因, 例如没有确认报文(比如QoS等级0的发布消息)或当客户端或服务端不能继续处理连接.非规范评注客户端可以使用这些信息来决定是否重新连接, 以及在重新尝试之前应该等待多长时间.</code></pre><h5 id="3-14-2-2-DISCONNECT属性"><a href="#3-14-2-2-DISCONNECT属性" class="headerlink" title="3.14.2.2 DISCONNECT属性"></a>3.14.2.2 DISCONNECT属性</h5><h6 id="3-14-2-2-1-属性长度"><a href="#3-14-2-2-1-属性长度" class="headerlink" title="3.14.2.2.1 属性长度"></a>3.14.2.2.1 属性长度</h6><p>DISCONNECT报文可变报头中的<code>属性(Properties)</code>的长度被编码为<code>变长字节整数</code>. 如果剩余长度小于2, 属性长度使用0.</p><h6 id="3-14-2-2-2-会话过期间隔"><a href="#3-14-2-2-2-会话过期间隔" class="headerlink" title="3.14.2.2.2 会话过期间隔"></a>3.14.2.2.2 会话过期间隔</h6><p>17 (0x11), <code>会话过期间隔(Session Expiry Interval)</code>标识符.<br>跟随其后的是用四字节整数表示的以秒为单位的<code>会话过期间隔(Session Expiry Interval)</code>. 包含多个<code>会话过期间隔</code>将造成协议错误(Protocol Error).</p><p>如果没有设置<code>会话过期间隔</code>, 则使用<code>CONNECT</code>报文中的<code>会话过期间隔</code>.</p><p><code>会话过期间隔</code><strong>不能</strong>由服务端的<code>DISCONNECT</code>报文发送 [MQTT-3.14.2-2].</p><p>如果<code>CONNECT</code>报文中的会话过期间隔为0, 则客户端在<code>DISCONNECT</code>报文中设置非0<code>会话过期间</code>隔将造成协议错误(Protocol Error). 如果服务端收到这种非0<code>会话过期间隔</code>, 则不会将其视为有效的<code>DISCONNECT</code>报文. 服务端使用包含原因码为<code>0x82(协议错误)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><h6 id="3-14-2-2-3-原因字符串"><a href="#3-14-2-2-3-原因字符串" class="headerlink" title="3.14.2.2.3 原因字符串"></a>3.14.2.2.3 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码字符串表示断开原因. 此原因字符串是为诊断而设计的可读字符串, <strong>不应该</strong>被接收端所解析.</p><p>如果此属性使得<code>DISCONNECT</code>报文的长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性 [MQTT-3.14.2-3]. 包含多个原因字符串将造成协议错误(Protocol Error).</p><h6 id="3-14-2-2-4-用户属性"><a href="#3-14-2-2-4-用户属性" class="headerlink" title="3.14.2.2.4 用户属性"></a>3.14.2.2.4 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)标识符</code>.<br>跟随其后的是UTF-8字符串对. 此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上<code>用户属性</code>之后的<code>DISCONNECT</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性 [MQTT-3.14.2-4]. <code>用户属性</code>允许出现多次, 以表示多个名字/值对, 且相同的名字<strong>可以</strong>多次出现.</p><h6 id="3-14-2-2-5-服务端参考"><a href="#3-14-2-2-5-服务端参考" class="headerlink" title="3.14.2.2.5 服务端参考"></a>3.14.2.2.5 服务端参考</h6><p>28 (0x1C), <code>服务端参考(Server Reference)</code>标识符.<br>跟随其后的是一个UTF-8编码字符串, 客户端可以使用它来识别其他要使用的服务端. 包含多个服务端参考将造成协议错误(Protocol Error).</p><p>服务端发送包含一个服务端参考和原因码 <code>0x9C((临时)使用其他服务端)</code> 或 <code>0x9D(服务端已(永久)移动)</code> 的 <code>DISCONNECT</code> 报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p><p>关于如何使用服务端参考, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#411-服务端重定向" target="_blank" rel="noopener">4.11节</a> 服务端重定向.</p><ul><li>图 3-24 DISCONNECT报文可变报头非规范示例</li></ul><table><thead><tr><th align="left"></th><th align="left">说明</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">断开原因码</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 1</td><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">属性</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte 2</td><td align="left">长度Length(5)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 3</td><td align="left">会话过期间隔标识符 (17)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">byte 4</td><td align="left">会话过期间隔 (0)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 5</td><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 6</td><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 7</td><td align="left"></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h4 id="3-14-3-DISCONNECT载荷"><a href="#3-14-3-DISCONNECT载荷" class="headerlink" title="3.14.3 DISCONNECT载荷"></a>3.14.3 DISCONNECT载荷</h4><p>DISCONNECT报文没有有效载荷.</p><h4 id="3-14-4-DISCONNECT行为"><a href="#3-14-4-DISCONNECT行为" class="headerlink" title="3.14.4 DISCONNECT行为"></a>3.14.4 DISCONNECT行为</h4><p>发送端发送完DISCONNECT报文之后:</p><ul><li></li><li><p><strong>不能</strong>再在此网络连接上发送任何MQTT控制报文 [MQTT-3.14.4-1].</p></li><li><p><strong>必须</strong>关闭网络连接 [MQTT-3.14.4-2].</p></li></ul><p>接收到包含原因码为0x00(成功)的DISCONNECT时, 服务端:</p><ul><li></li><li><p><strong>必须</strong>丢弃任何与当前连接相关的遗嘱消息, 而不发布它 [MQTT-3.14.4-3], 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a> 所述.</p></li></ul><p>接收到DISCONNECT报文时, 接收端:<br>- <strong>应该</strong>关闭网络连接</p><h3 id="3-15-AUTH-–-认证交换"><a href="#3-15-AUTH-–-认证交换" class="headerlink" title="3.15 AUTH – 认证交换"></a>3.15 AUTH – 认证交换</h3><p><code>AUTH</code>报文被从客户端发送给服务端, 或从服务端发送给客户端, 作为扩展认证交换的一部分, 比如质询/响应认证. 如果<code>CONNECT</code>报文不包含相同的认证方法, 则客户端或服务端发送<code>AUTH</code>报文将造成协议错误(Protocol Error).</p><h4 id="3-15-1-AUTH固定报头"><a href="#3-15-1-AUTH固定报头" class="headerlink" title="3.15.1 AUTH固定报头"></a>3.15.1 AUTH固定报头</h4><ul><li>图 3-35 AUTH报文固定报头</li></ul><table><thead><tr><th align="left">Bit</th><th align="left">7</th><th align="left">6</th><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th><th align="left">0</th></tr></thead><tbody><tr><td align="left">byte 1</td><td align="left">MQTT控制报文类型 (15)</td><td align="left">保留位</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">byte 2</td><td align="left">剩余长度</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>AUTH报文固定报头第3, 2, 1, 0位是保留位, <strong>必须</strong>全设置为0. 客户端或服务端<strong>必须</strong>把其他值当做无效值并关闭网络连接 [MQTT-3.15.1-1].</p><p>剩余长度字段<br>等于可变报头的长度, 编码为<code>变长字节整数</code>.</p><h4 id="3-15-2-AUTH可变报头"><a href="#3-15-2-AUTH可变报头" class="headerlink" title="3.15.2 AUTH可变报头"></a>3.15.2 AUTH可变报头</h4><p>AUTH报文可变报头按顺序包含以下字段:认证原因码(Authentication Reason Code), 属性(Properties). 属性的编码规则, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p><h5 id="3-15-2-1-认证原因码"><a href="#3-15-2-1-认证原因码" class="headerlink" title="3.15.2.1 认证原因码"></a>3.15.2.1 认证原因码</h5><p>可变报头第0字节是<code>认证原因码(Authenticate Reason Code)</code>. 单字节无符号认证原因码字段的值如下所示. <code>AUTH</code> 报文的发送端<strong>必须</strong>使用一种认证原因码 [MQTT-3.15.2-1].</p><ul><li>表 3-11 认证原因码</li></ul><table><thead><tr><th align="left">值</th><th align="left">16进制</th><th align="left">原因码名称</th><th align="left">发送端</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x00</td><td align="left">成功</td><td align="left">服务端</td><td align="left">认证成功.</td></tr><tr><td align="left">24</td><td align="left">0x18</td><td align="left">继续认证</td><td align="left">服务端或客户端</td><td align="left">继续下一步认证.</td></tr><tr><td align="left">25</td><td align="left">0x19</td><td align="left">重新认证</td><td align="left">客户端</td><td align="left">开始重新认证.</td></tr></tbody></table><p>如果原因码为<code>0x00(成功)</code>并且没有属性字段, 则可以省略原因码和属性长度. 这种情况下, <code>AUTH</code>报文剩余长度为0.</p><h5 id="3-15-2-2-AUTH属性"><a href="#3-15-2-2-AUTH属性" class="headerlink" title="3.15.2.2 AUTH属性"></a>3.15.2.2 AUTH属性</h5><h6 id="3-15-2-2-1-属性长度"><a href="#3-15-2-2-1-属性长度" class="headerlink" title="3.15.2.2.1 属性长度"></a>3.15.2.2.1 属性长度</h6><p>AUTH报文可变报头中的属性的长度被编码为<code>变长字节整数</code>.</p><h6 id="3-15-2-2-2-认证方法"><a href="#3-15-2-2-2-认证方法" class="headerlink" title="3.15.2.2.2 认证方法"></a>3.15.2.2.2 认证方法</h6><p>21 (0x15), <code>认证方法(Authentication Method)</code>标识符.<br>跟随其后的是一个UTF-8编码字符串, 包含<code>认证方法名称</code>. 省略<code>认证方法</code>或者包含多个<code>认证方法</code>都将造成协议错误(Protocol Error). 更多关于扩展认证的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p><h6 id="3-15-2-2-3-认证数据"><a href="#3-15-2-2-3-认证数据" class="headerlink" title="3.15.2.2.3 认证数据"></a>3.15.2.2.3 认证数据</h6><p>22 (0x16), <code>认证数据(Authentication Data)</code>标识符.<br>跟随其后的是二进制数据, 包含<code>认证数据</code>. 包含多个<code>认证数据</code>将造成协议错误(Protocol Error). 此数据的内容由认证方法定义. 更多关于扩展认证的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p><h6 id="3-15-2-2-4-原因字符串"><a href="#3-15-2-2-4-原因字符串" class="headerlink" title="3.15.2.2.4 原因字符串"></a>3.15.2.2.4 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码字符串, 表示断开原因. 此<code>原因字符串</code>是为诊断而设计的可读字符串, 不应该被接收端所解析.</p><p>如果加上原因字符串之后的<code>AUTH</code>报文长度超出了接收端所指定的最大报文长度, 则发送端不能发送此属性 [MQTT-3.15.2-2]. 包含多个<code>原因字符串</code>将造成协议错误(Protocol Error).</p><h6 id="3-15-2-2-5-用户属性"><a href="#3-15-2-2-5-用户属性" class="headerlink" title="3.15.2.2.5 用户属性"></a>3.15.2.2.5 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上用户属性之后的<code>AUTH</code>报文长度超出了接收端指定的最大报文长度, 则服务端不能发送此属性 [MQTT-3.15.2-3]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p><h4 id="3-15-3-AUTH载荷"><a href="#3-15-3-AUTH载荷" class="headerlink" title="3.15.3 AUTH载荷"></a>3.15.3 AUTH载荷</h4><p>AUTH报文没有有效载荷.</p><h4 id="3-15-4-AUTH行为"><a href="#3-15-4-AUTH行为" class="headerlink" title="3.15.4 AUTH行为"></a>3.15.4 AUTH行为</h4><p>更多关于扩展认证的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p><h2 id="4-操作行为"><a href="#4-操作行为" class="headerlink" title="4 操作行为"></a>4 操作行为</h2><h3 id="4-1-会话状态"><a href="#4-1-会话状态" class="headerlink" title="4.1 会话状态"></a>4.1 会话状态</h3><p>为实现<code>QoS等级1</code>和<code>QoS等级2</code>协议流, 客户端和服务端需要将状态与客户标识符相关联, 这被称为会话状态. 服务端还将订阅信息存储为会话状态的一部分.</p><p>会话可以跨越一系列的网络连接. 它持续到最新的<code>网络连接(Network Connections)</code>加上<code>会话过期间隔(Session Expiry Interval)</code>.</p><p>客户端的会话状态包括:</p><ul><li>已发送给服务端, 但是还没有完成确认的<code>QoS等级1</code>和<code>QoS等级2</code>的消息.</li><li>从服务端收到的, 但是还没有完成确认的<code>QoS等级2</code>消息.</li></ul><p>服务端的会话状态包括:</p><ul><li>会话是否存在, 即使会话状态其余部分为空.</li><li>客户端订阅信息, 包括任何订阅标识符.</li><li>已发送给客户端, 但是还没有完成确认的<code>QoS等级1</code>和<code>QoS等级2</code>的消息.</li><li>等待传输给客户端的<code>QoS等级0</code>(可选), <code>QoS等级1</code>和<code>QoS等级2</code>的消息.</li><li>从客户端收到的, 但是还没有完成确认的<code>QoS等级2</code>消息. 遗嘱小子和遗嘱延时间隔.</li><li>如果会话当前未连接, 会话结束时间和会话状态将被丢弃.</li></ul><p>保留消息不是会话状态的一部分, 会话结束时不被删除.</p><h4 id="4-1-1-存储会话状态"><a href="#4-1-1-存储会话状态" class="headerlink" title="4.1.1 存储会话状态"></a>4.1.1 存储会话状态</h4><p>当网络连接打开时, 客户端和服务端不能丢弃会话状态 [MQTT-4.1.0-1]. 当网络连接被关闭并且会话过期间隔已过时, 服务端必须丢弃会话状态 [MQTT-4.1.0-2].</p><pre><code>非规范评注客户端和服务端实现的存储容量必然是有限的, 还可能要受管理策略的限制. 已存储的会话状态可能因为管理操作(比如某个预定义条件的自动响应)而被丢弃.它造成的后果就是会话终止. 这些操作可能是因为资源受限或其他操作原因引发的. 硬件或软件故障可能导致客户端或服务端存储的会话状态丢失或损坏. 需要谨慎的评估客户端和服务端的存储能力, 以确保存储空间充足.</code></pre><h4 id="4-1-2-会话状态非规范示例"><a href="#4-1-2-会话状态非规范示例" class="headerlink" title="4.1.2 会话状态非规范示例"></a>4.1.2 会话状态非规范示例</h4><p>例如, 想要收集电表读数的用户可能会决定使用<code>QoS等级1</code>的消息, 因为他们不能接受数据在网络传输途中丢失, 但是, 他们可能认为客户端和服务端的数据可以存储在内存(易失性存储器)中, 因为(他们觉得)电力供应是非常可靠的, 不会有太大的数据丢失风险.</p><p>与之相反, 停车计费支付应用的提供商可能决定任何情况下都不能让数据支付消息丢失, 因此他们要求在通过网络传输之前将所有的数据写入到非易失性存储器中(如硬盘).</p><h3 id="4-2-网络连接"><a href="#4-2-网络连接" class="headerlink" title="4.2 网络连接"></a>4.2 网络连接</h3><p>MQTT协议要求基础传输层能够提供有序的、可靠的、双向传输(从客户端到服务端和从服务端到客户端)字节流. 此规范不要求任何指定的传输协议. 客户端或服务端可以支持这里列出的任何传输协议, 或者满足 本节 要求的任何其他传输协议.</p><p>客户端或服务端必须支持使用一个或多个提供有序的、可靠的、双向传输(从客户端到服务端和从服务端到客户端)字节流传输的底层传输协议 [MQTT-4.2-1].</p><pre><code>非规范评注MQTT v5.0使用的传输层协议是 [RFC0793] 定义的TCP/IP协议.下面的协议也支持:• TLS [RFC5246]• WebSocket [RFC6455] 非规范评注TCP端口8883和1883已在IANA注册, 分别用于MQTT的TLS和非TLS通信.非规范评注无连接的网络传输, 如用户数据包协议 (UDP) 本身不适合, 因为它们可能丢失或重新排列数据. </code></pre><h3 id="4-3-服务质量等级和协议流程"><a href="#4-3-服务质量等级和协议流程" class="headerlink" title="4.3 服务质量等级和协议流程"></a>4.3 服务质量等级和协议流程</h3><p>MQTT按照后面章节定义的<code>服务质量(QoS)等级</code>分发应用消息. 分发协议是对称的, 在下面的描述中, 客户端和服务端既可以是发送端也可以是接收端. 分发协议关注的是从单个发送者到单个接收者的应用消息. 服务端分发应用消息给多个客户端时, 每个客户端独立处理. 分发给客户端的出站应用消息和入站应用消息的QoS等级可能是不同的.</p><h4 id="4-3-1-QoS-0-最多分发一次"><a href="#4-3-1-QoS-0-最多分发一次" class="headerlink" title="4.3.1 QoS 0:最多分发一次"></a>4.3.1 QoS 0:最多分发一次</h4><p>消息的分发依赖于底层网络的能力. 接收端不会发送响应, 发送端也不会重试. 消息可能送达一次也可能根本没送达.</p><p>对于<code>QoS等级0</code>的分发协议, 发送端<br>- 必须发送QoS等于0, DUP等于0的<code>PUBLISH</code>报文 [MQTT-4.3.1-1].</p><p>对于QoS等级0的分发协议, 接收端<br>- 接受<code>PUBLISH</code>报文时同时接受消息的所有权.</p><ul><li>图 4-1 QoS等级0协议流程图, 非规范示例</li></ul><table><thead><tr><th align="left">发送端动作</th><th align="left">控制报文</th><th align="left">接收端动作</th></tr></thead><tbody><tr><td align="left">PUBLISH报文QoS 0, DUP=0</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">———-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">分发应用消息给适当的后续接收者(们)</td></tr></tbody></table><h4 id="4-3-2-QoS-1-至少分发一次"><a href="#4-3-2-QoS-1-至少分发一次" class="headerlink" title="4.3.2 QoS 1:至少分发一次"></a>4.3.2 QoS 1:至少分发一次</h4><p>服务质量等级1确保消息至少送达一次. <code>QoS等级1</code>的<code>PUBLISH</code>报文的可变报头中包含一个报文标识符, 需要PUBACK 报文确认. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了有关报文标识符的更多信息.</p><p>对于<code>QoS等级1</code>的分发协议, 发送端</p><ul><li></li><li><p>每次发送新的应用消息都必须分配一个未使用的报文标识符 [MQTT-4.3.2-1].</p></li><li><p>发送的<code>PUBLISH</code>报文必须包含报文标识符且QoS等于1, DUP等于0 [MQTT-4.3.2-2].</p></li><li><p>必须将这个<code>PUBLISH</code>报文看作是未确认的 , 直到从接收端那收到对应的<code>PUBACK</code>报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#44-消息分发重试" target="_blank" rel="noopener">4.4节</a> 有一个关于未确认消息的讨论 [MQTT-4.3.2-3].</p></li></ul><p>一旦发送端收到<code>PUBACK</code>报文, 这个报文标识符就可以重用.</p><p>注意:允许发送端在等待确认时使用不同的报文标识符发送后续的<code>PUBLISH</code>报文.</p><p>对于QoS等级1的分发协议, 接收端</p><ul><li></li><li><p>响应的<code>PUBACK</code>报文必须包含一个报文标识符, 这个标识符来自接收到的、已经接受所有权的<code>PUBLISH</code>报文 [MQTT-4.3.2-4].</p></li><li><p>发送了<code>PUBACK</code>报文之后, 接收端必须将任何包含相同报文标识符的入站<code>PUBLISH</code>报文当做一个新的消息, 并忽略它的DUP标志的值 [MQTT-4.3.2-5].</p></li><li><p>图 4-2 QoS等级1协议流程图, 非规范示例</p></li></ul><table><thead><tr><th align="left">发送端动作</th><th align="left">控制报文</th><th align="left">接收端动作</th></tr></thead><tbody><tr><td align="left">存储消息</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">发送PUBLISH报文QoS=1, DUP=0, 带报文标识符</td><td align="left">———-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">开始应用消息的后续分发1</td></tr><tr><td align="left"></td><td align="left">&lt;———-</td><td align="left">发送<code>PUBACK</code>报文, 带报文标识符</td></tr><tr><td align="left">丢弃消息</td><td align="left"></td><td align="left"></td></tr></tbody></table><p>不要求接收端在发送 <code>PUBACK</code> 之前完整分发应用消息. 原来的发送端收到 <code>PUBACK</code> 报文之后, 应用消息的所有权就会转移给这个接收端.</p><h4 id="4-3-3-QoS-2-仅分发一次"><a href="#4-3-3-QoS-2-仅分发一次" class="headerlink" title="4.3.3 QoS 2:仅分发一次"></a>4.3.3 QoS 2:仅分发一次</h4><p>这是最高等级的服务质量, 消息丢失和重复都是不可接受的. 使用这个服务质量等级会有额外的开销.</p><p>QoS等2消息可变报头中有报文标识符. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了有关报文标识符的更多信息. <code>QoS等级2</code>的<code>PUBLISH</code>报文的接收端使用一个两部确认过程来确认收到.</p><p>对于QoS等级2的分发协议, 发送端</p><ul><li><strong>必须</strong>给要发送的新应用消息分配一个未使用的报文标识符 [MQTT-4.3.3-1].</li><li>发送端<code>PUBLISH</code>报文<strong>必须</strong>包含报文标识符且报文的QoS等于2, DUP等于0 [MQTT-4.3.3-2].</li><li><strong>必须</strong>将这个<code>PUBLISH</code>报文看作是未确认的 , 直到从接收端那收到对应的<code>PUBREC</code>报文 [MQTT-4.3.3-3]. <a href="https://www.zybuluo.com/khan-lau/note/1325300#44-消息分发重试" target="_blank" rel="noopener">4.4节</a> 有一个关于未确认消息的讨论.</li><li>收到发送端发送的包含原因码小于0x80的<code>PUBREC</code>报文后必须发送一个<code>PUBREL</code>报文.PUBREL报文必须包含与原始<code>PUBLISH</code>报文相同的报文标识符 [MQTT-4.3.3-4].</li><li><strong>必须</strong>将这个<code>PUBREL</code>报文看作是未确认的 , 直到从接收端那收到对应的<code>PUBCOMP</code>报文 [MQTT-4.3.3-5].</li><li>一旦发送了对应的<code>PUBREL</code>报文就<strong>不能</strong>重发这个<code>PUBLISH</code>报文 [MQTT-4.3.3-6].</li><li>如果<code>PUBLISH</code>报文已发送, <strong>不能</strong>应用消息过期属性 [MQTT-4.3.3-7].</li></ul><p>一旦发送端收到包含原因码大于0x80的<code>PUBCOMP</code>报文, 这个报文标识符就可以重用.</p><p>注意:允许发送端在等待确认时使用不同的报文标识符发送后续的<code>PUBLISH</code>报文, 受制于4.9节 描述的流量控制.</p><p>对于<code>QoS等级2</code>的分发协议, 接收端</p><ul><li>响应的<code>PUBREC</code>报文<strong>必须</strong>包含报文标识符, 这个标识符来自接收到的、已经接受所有权的<code>PUBLISH</code>报文 [MQTT-4.3.3-8].</li><li>如果接收端发送了包含原因码大于等于0x80的<code>PUBREC</code>报文, 它<strong>必须</strong>将后续包含相同报文标识符的<code>PUBLISH</code>报文当做是新的应用消息 [MQTT-4.3.3-9].</li><li>在收到对应的<code>PUBREL</code>报文之前, 接收端<strong>必须</strong>发送<code>PUBREC</code>报文确认任何后续的具有相同报文标识符的<code>PUBLISH</code>报文. 在这种情况下, 它<strong>不能</strong>重复分发消息给任何后续的接收者 [MQTT-4.3.3-10].</li><li><strong>必须</strong>发送包含与<code>PUBREL</code>相同报文标识符的<code>PUBCOMP</code>报文作为对<code>PUBREL</code>报文的响应 [MQTT-4.3.3-11].</li><li>发送PUBCOMP报文之后, 接收端<strong>必须</strong>将后续包含相同报文标识符的<code>PUBLISH</code>报文当做是新的应用消息 [MQTT-4.3.3-12].</li><li><strong>必须</strong>继续<code>QoS等级2</code>确认序列, 即使它已经应用了消息过期属性 [MQTT-4.3.3-13].</li></ul><h3 id="4-4-消息分发重试"><a href="#4-4-消息分发重试" class="headerlink" title="4.4 消息分发重试"></a>4.4 消息分发重试</h3><p>客户端以<code>新开始(Clean Start)</code>标志为0且会话存在的情况下重连时, 客户端和服务端都必须使用原始报文标识符重新发送任何未被确认的 <code>PUBLISH</code> 报文(当QoS &gt; 0)和<code>PUBREL</code>报文. 这是唯一要求客户端或服务端重发消息的情况. 客户端和服务端<strong>不能</strong>在其他任何时间重发消息 [MQTT-4.4.0-1].</p><p>如果收到包含原因码大于等于0x80的<code>PUBACK</code>或<code>PUBREC</code>, 则对应的<code>PUBLISH</code>报文被看作已确认, 且<strong>不能</strong>被重传 [MQTT-4.4.0-2].</p><ul><li>图 4-3 QoS等级2协议流程图, 非规范示例</li></ul><table><thead><tr><th align="left">发送端动作</th><th align="left">控制报文</th><th align="left">接收端行为</th></tr></thead><tbody><tr><td align="left">存储消息</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">发送<code>PUBLISH</code>报文QoS=2, DUP=0, 带报文标识符</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">———-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">存储报文标识符, 然后启动应用消息的向前分发1</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">发送PUBREC报文, 带报文标识符和原因码</td></tr><tr><td align="left"></td><td align="left">&lt;———-</td><td align="left"></td></tr><tr><td align="left">丢弃消息, 存储PUBREC中的报文标识符</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">发送PUBREL报文, 带报文标识符</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">———-&gt;</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">丢弃报文标识符</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">发送PUBCOMP报文, 带报文标识符</td></tr><tr><td align="left"></td><td align="left">&lt;———-</td><td align="left"></td></tr><tr><td align="left">丢弃已保存的状态</td><td align="left"></td><td align="left"></td></tr></tbody></table><p>1 不要求接收端在发送<code>PUBREC</code>和<code>PUBCOMP</code>之前完整分发应用消息. 原始发送端收到<code>PUBREC</code>报文之后, 应用消息的所有权就会转移给这个接收端. 然而, 接收端需要在接受所有权之前执行对所有可能导致转发失败(例如超出配额、权限等)的条件的检查. 接收端在<code>PUBREC</code>中使用适当的原因码指示所有权接受成功或失败.</p><h3 id="4-5-消息收到"><a href="#4-5-消息收到" class="headerlink" title="4.5 消息收到"></a>4.5 消息收到</h3><p>当服务端接受入站应用消息的所有权时, 它<strong>必须</strong>将消息添加到订阅匹配的客户端的会话状态中 [MQTT-4.5.0-1]. 匹配规则定义见 <a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> .</p><p>正常情况下, 客户端收到的消息是对他们创建的订阅的响应. 客户端也可能收到不是与它的订阅精确匹配的消息. 如果服务端自动给客户端分配了一个订阅, 可能发生这种情况. <code>UNSUBSCRIBE</code>操作正在被处理时也可能收到消息. 客户端<strong>必须</strong>按照可用的服务质量(QoS)规则确认它收到的任何<code>PUBLISH</code>报文, 不管它是否选择处理其包含的应用消息 [MQTT-4.5.0-2].</p><h3 id="4-6-消息排序"><a href="#4-6-消息排序" class="headerlink" title="4.6 消息排序"></a>4.6 消息排序</h3><p>实现 <a href="https://www.zybuluo.com/khan-lau/note/1325300#43-服务质量等级和协议流程" target="_blank" rel="noopener">4.3节</a> 定义的协议流程时, 客户端<strong>必须</strong>遵循下列规则</p><ul><li>重发任何之前的<code>PUBLISH</code>报文时, <strong>必须</strong>按原始<code>PUBLISH</code>报文的发送顺序重发(适用于QoS等级1和QoS等级2 消息) [MQTT-4.6.0-1].</li><li><strong>必须</strong>按照对应的<code>PUBLISH</code>报文的顺序发送<code>PUBACK</code>报文(<code>QoS等级1</code>消息) [MQTT-4.6.0-2].</li><li><strong>必须</strong>按照对应的<code>PUBLISH</code>报文的顺序发送<code>PUBREC</code>报文(<code>QoS等级2</code>消息) [MQTT-4.6.0-3].</li><li><strong>必须</strong>按照对应的<code>PUBREC</code>报文的顺序发送<code>PUBREL</code>报文(<code>QoS等级2</code>消息) [MQTT-4.6.0-4].</li></ul><p>一个<code>有序主题(Ordered Topic)</code>是一个主题, 在这个主题中, 客户端<strong>可以</strong>确定从同一个客户端接收的相同QoS等级的消息的顺序与他们发布的顺序一致. 当服务端处理发布到有序主题的消息时, 它<strong>必须</strong>按照消息从任何给定客户端接收的顺序发送<code>PUBLISH</code>报文给消费端(对于同一主题和QoS等级) [MQTT-4.6.0-5]. 这是上面列出的规则的补充.</p><p>默认情况下, 服务端转发非共享订阅的消息时, <strong>必须</strong>将每个主题都视为有序主题 [MQTT-4.6.0-6]. 服务端<strong>可以</strong>提供管理或其他机制来允许一个或多个主题不被当作有序主题.</p><pre><code>非规范评注上面列出的规则确保, 使用QoS等级1发布和订阅的消息流, 订阅者按照消息发布时的顺序收到每条消息的最终副本, 但是消息可能会重复, 这可能导致在它的后继消息之后收到某个已经收到消息的重发版本. 例如, 发布者按顺序1, 2, 3, 4发送消息, 订阅者收到的顺序可能是1, 2, 3, 2, 3, 4.如果客户端和服务端能保证任何时刻最多有一条消息在 传输中(in-flight)(在某条消息被确认前不发送后面的那条消息), 那么, 不会有QoS等级1的消息会在它的任何后续消息之后收到. 例如, 订阅者收到的顺序可能是 1, 2, 3, 3, 4, 而不是 1, 2, 3, 2, 3, 4. 关于如何使用Receive Maximum的详细信息, 参考[4.9节](#49-流控) 流控.</code></pre><h3 id="4-7-主题名和主题过滤器"><a href="#4-7-主题名和主题过滤器" class="headerlink" title="4.7 主题名和主题过滤器"></a>4.7 主题名和主题过滤器</h3><h4 id="4-7-1-主题通配符"><a href="#4-7-1-主题通配符" class="headerlink" title="4.7.1 主题通配符"></a>4.7.1 主题通配符</h4><p><code>主题层级(topic level)</code>分隔符用于将结构化引入主题名. 如果存在分隔符, 它将主题名分割为多个<code>主题层级 topic level</code>.<br>订阅的主题过滤器可以包含特殊的通配符, 允许客户端一次订阅多个主题.<br>主题过滤器中<strong>可以</strong>使用通配符, 但是主题名<strong>不能</strong>使用通配符 [MQTT-4.7.0-1].</p><h5 id="4-7-1-1-主题层级分隔符"><a href="#4-7-1-1-主题层级分隔符" class="headerlink" title="4.7.1.1 主题层级分隔符"></a>4.7.1.1 主题层级分隔符</h5><p><code>斜杠(’/’ U+002F)</code>用于分割主题的每个层级, 为主题名提供一个分层结构. 当客户端订阅指定的主题过滤器包含两种通配符时, 主题层级分隔符就很有用了. 主题层级分隔符可以出现在主题过滤器或主题名字的任何位置. 相邻的主题层次分隔符表示一个零长度的主题层级.</p><h5 id="4-7-1-2-多层通配符"><a href="#4-7-1-2-多层通配符" class="headerlink" title="4.7.1.2 多层通配符"></a>4.7.1.2 多层通配符</h5><p><code>数字符号(‘#’ U+0023)</code>是用于匹配主题中任意层级的通配符. 多层通配符表示它的父级和任意数量的子层级. 多层通配符<strong>必须</strong>单独指定, 或者跟在主题层级分隔符后面. 不管哪种情况, 它都<strong>必须</strong>是主题过滤器的最后一个字符 [MQTT-4.7.1-1].</p><pre><code>非规范评注例如, 如果客户端订阅主题 “sport/tennis/player1/#”, 它会收到使用下列主题名发布的消息:• “sport/tennis/player1”• “sport/tennis/player1/ranking• “sport/tennis/player1/score/wimbledon”非规范评注• “sport/#”也匹配单独的“sport”主题名, 因为#包括它的父级.• “#”是有效的, 会收到所有的应用消息.• “sport/tennis/#”也是有效的.• “sport/tennis#”是无效的.• “sport/tennis/#/ranking”是无效的.</code></pre><h5 id="4-7-1-3-单层通配符"><a href="#4-7-1-3-单层通配符" class="headerlink" title="4.7.1.3 单层通配符"></a>4.7.1.3 单层通配符</h5><p><code>加号(‘+’ U+002B)</code>是只能用于单个主题层级匹配的通配符.</p><p>在主题过滤器的任意层级都可以使用单层通配符, 包括第一个和最后一个层级. 在使用它时, 它<strong>必须</strong>占据过滤器的整个层级 [MQTT-4.7.1-2]. <strong>可以</strong>在主题过滤器中的多个层级中使用它, 也<strong>可以</strong>和多层通配符一起使用.</p><pre><code>非规范评注例如, “sport/tennis/+”匹配“sport/tennis/player1”和“sport/tennis/player2”, 但是不匹配“sport/tennis/player1/ranking”.同时, 由于单层通配符只能匹配一个层级, “sport/+”不匹配“sport”但是却匹配“sport/”.• “+”是有效的.• “+/tennis/#”是有效的.• “sport+”是无效的.• “sport/+/player1”是有效的.• “/finance”匹配“+/+”和“/+”, 但是不匹配“+”.</code></pre><h4 id="4-7-2-以-开头的主题"><a href="#4-7-2-以-开头的主题" class="headerlink" title="4.7.2 以$开头的主题"></a>4.7.2 以$开头的主题</h4><p>服务端<strong>不能</strong>将<code>$字符</code>开头的主题名匹配通配符(#或+)开头的主题过滤器 [MQTT-4.7.2-1]. 服务端应该阻止客户端使用这种主题名与其他客户端交换消息. 服务端实现<strong>可以</strong>将<code>$开头</code>的主题名用作其他目的.</p><pre><code>非规范评注• $SYS/被广泛用作包含服务端特定信息或控制接口的主题的前缀.    • 应用不能使用$字符开头的主题.非规范评注• 订阅“#”的客户端不会收到任何发布到以$开头主题的消息.    • 订阅“+/monitor/Clients”的客户端不会收到任何发布到“$SYS/monitor/Clients”的消息.• 订阅“$SYS/#”的客户端会收到发布到以“$SYS/”开头主题的消息.• 订阅“$SYS/monitor/+”的客户端会收到发布到“$SYS/monitor/Clients”主题的消息.• 如果客户端想同时接受以“$SYS/”开头主题的消息和不以$开头主题的消息, 它需要同时订阅“#”和“$SYS/#”.</code></pre><h4 id="4-7-3-主题语义和用法"><a href="#4-7-3-主题语义和用法" class="headerlink" title="4.7.3 主题语义和用法"></a>4.7.3 主题语义和用法</h4><p>下列规则应用于主题名和主题过滤器:</p><ul><li>所有的主题名和主题过滤器<strong>必须</strong>至少包含一个字符 [MQTT-4.7.3-1].</li><li>主题名和主题过滤器是大小写敏感的.</li><li>主题名和主题过滤器可以包含空格字符.</li><li>主题名或主题过滤器以前置或后置斜杠‘/’区分.</li><li>只包含斜杠‘/’的主题名或主题过滤器是合法的.</li><li>主题名和主题过滤器<strong>不能</strong>包含空字符(Unicode U+0000) [Unicode] [MQTT-4.7.3-2].</li><li>主题名和主题过滤器是UTF-8编码字符串, 它们<strong>不能</strong>超过65,535字节 [MQTT-4.7.3-3]. 见<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> .</li></ul><p>除了<strong>不能</strong>超过UTF-8编码字符串的长度限制之外, 主题名或主题过滤器的层级数量没有其它限制.</p><p>匹配订阅时, 服务端<strong>不能</strong>对主题名或主题过滤器执行任何规范化(normalization)处理, <strong>不能</strong>修改或替换任何未识别的字符 [MQTT-4.7.3-4]. 主题过滤器中的每个非通配符层级需要逐字符匹配主题名中对应的层级才算匹配成功.</p><pre><code>非规范评注使用UTF-8编码规则意味着, 主题过滤器和主题名的比较可以通过比较编码后的UTF-8字节或解码后的Unicode字符. 非规范评注• “ACCOUNTS”和“Accounts”是不同的主题名.• “Accounts payable”是合法的主题名.• “/finance”和“finance”是不同的主题名.</code></pre><p>如果订阅的主题过滤器与消息的主题名匹配, 应用消息会被发送给每一个匹配的客户端订阅. 主题资源<strong>可以</strong>是管理员在服务端预先定义好的, 也<strong>可以</strong>是服务端收到第一个订阅或使用那个主题名的应用消息时动态添加的. 服务端也<strong>可以</strong>使用一个安全组件有选择地授权客户端使用某个主题资源.</p><h3 id="4-8-订阅"><a href="#4-8-订阅" class="headerlink" title="4.8 订阅"></a>4.8 订阅</h3><p>MQTT提供两种订阅方式, 共享和非共享.</p><pre><code>非规范评注在早期的MQTT版本中, 所有的订阅都是非共享的.</code></pre><h4 id="4-8-1-非共享订阅"><a href="#4-8-1-非共享订阅" class="headerlink" title="4.8.1 非共享订阅"></a>4.8.1 非共享订阅</h4><p><code>非共享订阅</code>只与创建它的会话相关联. 每个<code>订阅(Subscription)</code>包含一个指示用于在此会话上分发消息的主题过滤器和订阅选项. 服务端负责收集与过滤器相匹配的消息, 并在此会话的连接上发送这些消息.</p><p>一个会话<strong>不能</strong>有多个包含相同主题过滤器的<code>非共享订阅</code>, 因此主题过滤器可以用作标识此会话的订阅的关键词.</p><p>如果有多个客户端, 每个客户端都拥有对某个相同主题的<code>非共享订阅</code>, 则每个客户端都将获得在该主题上发布的应用消息的副本. 这意味着<code>非共享订阅</code><strong>不能</strong>被用于多个消费客户端的应用消息负载均衡, 因为在这种情况下, 每条消息都将被传递给每一个订阅的客户端.</p><h4 id="4-8-2-共享订阅"><a href="#4-8-2-共享订阅" class="headerlink" title="4.8.2 共享订阅"></a>4.8.2 共享订阅</h4><p><code>共享订阅</code>可以与多个订阅会话相关联. 与<code>非共享订阅</code>一样, 它包含一个主题过滤器和订阅选项. 但是, 与此主题过滤器相匹配的发布消息仅被发布到其中一个订阅会话. <code>共享订阅</code>在多个消费客户端并行共享处理发布消息时是很有用的.</p><p>使用特殊样式的主题过滤器来表示<code>共享订阅</code>. 过滤器格式如下:<br><code>$share/{ShareName}/{filter}</code></p><ul><li><code>$share</code>是字符串字面量, 用来把主题过滤器标记为共享订阅主题过滤器.</li><li><code>{ShareName}</code>是字符串, 不包含<code>&quot;/&quot;</code>, <code>&quot;+&quot;</code>或<code>&quot;#&quot;</code>.</li><li><code>{filter}</code>该字符串的剩余部分与<code>非共享订阅</code>中的主题过滤器具有相同的语法和语义.参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a>.</li></ul><p><code>共享订阅</code>主题过滤器<strong>必须</strong>以<code>$share/</code>开始, 且<strong>必须</strong>包含至少一个字符长度的共享名(ShareName) [MQTT-4.8.2-1]. 共享名不能包含字符<code>&quot;/&quot;</code>, <code>&quot;+&quot;</code>或<code>&quot;#&quot;</code>, 但<strong>必须</strong>跟在<code>&quot;/&quot;</code>字符后面.此<code>&quot;/&quot;</code>字符后面<strong>必须</strong>跟随一个主题过滤器 [MQTT-4.8.2-2] , 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> 所述.</p><pre><code>非规范评注共享订阅在MQTT服务端的范围内定义, 而不是在会话中定义. 共享订阅的主题过滤器包含共享名, 因此服务端可以有多个包含相同{过滤器}组件的共享订阅. 通常, 应用程序使用共享名表示共享同一个订阅的一组订阅会话.示例:• 共享订阅 &quot;$share/consumer1/sport/tennis/+&quot; 和 &quot;$share/consumer2/sport/tennis/+&quot; 是不同的共享订阅, 因此可以被关联到不同的会话组. 它们都与非共享订阅主题 &quot;sport/tennis/+&quot; 相匹配.如果一条消息被发布到匹配主题 &quot;sport/tennis/+&quot; , 则消息的副本仅发送给所有订阅 &quot;$share/consumer1/sport/tennis/+&quot; 的会话中的一个会话, 也仅发送给所有订阅 &quot;$share/consumer2/sport/tennis/+&quot; 的会话中的一个会话. 更多的副本将发送给所有对 &quot;sport/tennis/+&quot; 进行非共享订阅的客户端.• 共享订阅 &quot;$share/consumer1//finance&quot; 匹配非共享订阅主题 &quot;/finance&quot;.注意,  &quot;$share/consumer1//finance&quot; 和 &quot;$share/consumer1/sport/tennis/+&quot; 是不同的共享订阅, 尽管它们有相同的共享名. 它们可能在某种程度上是相关的, 但拥有相同的共享名并不意味着它们之间有某种关系.</code></pre><p>通过<code>SUBSCRIBE</code>请求中的<code>共享订阅</code>主题过滤器创建<code>共享订阅</code>. 只有一个会话订阅了某个<code>共享订阅</code>时, <code>共享订阅</code>行为如同<code>非共享订阅</code>, 除了:</p><ul><li>匹配发布消息时, 不考虑<code>&quot;$share&quot;</code>和<code>{共享名}</code>部分.</li><li>第一次订阅时, <code>保留消息</code>不发送给此会话.其他匹配的<code>发布消息</code>将发送给此会话.</li></ul><p>一旦某个<code>共享订阅</code>存在, 其他会话就有可能订阅了相同的<code>共享订阅</code>主题过滤器. 新的会话作为额外的订阅者关联到此<code>共享订阅</code>. 保留消息不发送给此新的订阅者. 后续每条与此<code>共享订阅</code>相匹配的应用消息被发送到该<code>共享订阅</code>关联的其中一个会话.</p><p>会话可以通过发送包含某<code>共享订阅</code>主题过滤器的<code>UNSUBSCRIBE</code>报文来显式的将其从<code>共享订阅</code>中分离. 会话终止时, 也将从<code>共享订阅</code>中分离.</p><p><code>共享订阅</code>持续到至少有一个与其相关的会话(即, 会话已经对此<code>共享订阅</code>主题过滤器发布了成功的<code>SUBSCRIBE</code>请求, 且尚未完成相应的<code>UNSUBSCRIBE</code>). 当初始创建此<code>共享订阅</code>的会话取消订阅时, 除非没有其他的相关会话, 否则<code>共享订阅</code>仍然存在. <code>共享订阅</code>在没有被任何会话订阅时结束, 且任何相关的未分发的消息都被删除.</p><p>共享订阅注释<br>- 如果有不止一个会话订阅了某个<code>共享订阅</code>, 服务端在消息的基础上自由的选择使用哪个会话, 以及使用什么标准来进行该选择.</p><ul><li>允许不同的订阅客户端在其<code>SUBSCRIBE</code>报文中请求不同的QoS等级. 服务端决定授予每个客户端的<code>最大QoS等级</code>, 并且允许向不同的订阅者授予不同的<code>最大QoS等级</code>. 向客户端发送应用消息时, 服务端<strong>必须</strong>考虑授予客户端的<code>QoS等级</code> [MQTT-4.8.2-3], 与向订阅者发送消息相同.</li><li>如果服务端正在向其选中的订阅客户端发送<code>QoS等级2</code>的消息, 并且在分发完成之前网络中断, 服务端<strong>必须</strong>在客户端重新连接时完成向该客户端的消息分发 [MQTT-4.8.2-4], 如4.3.3节 所述. 如果客户端的会话在客户端重连之前终止, 服务端<strong>不能</strong>把此消息发送给其他订阅的客户端 [MQTT-4.8.2-5].</li><li>如果服务端正在向其选中的订阅客户端发送<code>QoS等级1</code>的消息, 并且服务端在收到此客户端的确认报文之前网络中断, 服务端<strong>可以</strong>等客户端重新连接之后将消息重传给客户端. 如果客户端的会话在客户端重连之前终止, 服务端<strong>应该</strong>把此应用消息发送给与此<code>共享订阅</code>相关的另一个客户端. 服务端<strong>可以</strong>在第一个客户端断开连接时就尝试将消息发送给另一个客户端.</li><li>如果客户端对来自服务端的<code>PUBLISH</code>报文使用包含原因码大于等于0x80的<code>PUBACK</code>或<code>PUBREC</code>报文进行响应, 服务端<strong>必须</strong>丢弃应用消息而不尝试将其发送给任何其他订阅者 [MQTT-4.8.2-6].</li><li>允许客户端向已订阅的<code>共享订阅</code>第二次发送<code>SUBSCRIBE</code>请求. 比如, 它可以通过这样改变其订阅请求的<code>QoS等级</code>, 或者因为它不确定以前的连接关闭之前订阅是否已完成. 这不会增加<code>共享订阅</code>关联的会话个数, 因此会话将在其第一次发送<code>UNSUBSCRIBE</code>之后脱离此<code>共享订阅</code>.</li><li>每个<code>共享订阅</code>都是独立于其他<code>共享订阅</code>的. 有可能两个<code>共享订阅</code>包含了重叠的过滤器. 在这种情况下, 与两个<code>共享订阅</code>都相匹配的消息都将被它们单独处理. 如果某个客户端既有<code>共享订阅</code>也有<code>非共享订阅</code>, 且某个消息与它们都相匹配, 客户端将由于存在<code>非共享订阅</code>而接收此消息的副本, 此消息的第二个副本将分发给此<code>共享订阅</code>的某个订阅者, 因此可能导致两份副本都被发送给此客户端.</li></ul><h3 id="4-9-流控"><a href="#4-9-流控" class="headerlink" title="4.9 流控"></a>4.9 流控</h3><p>客户端和服务端使用接收最大值来控制接收未被确认的<code>PUBLISH</code>报文数量, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#312114-最大报文长度" target="_blank" rel="noopener">3.1.2.11.4节</a> 和<a href="https://www.zybuluo.com/khan-lau/note/1325300#32232-会话过期间隔" target="_blank" rel="noopener">3.2.2.3.2节</a> 所述. 接收最大值创建了一个发送配额, 用于限制可以在没收到<code>PUBACK</code>(QoS等级1)或<code>PUBCOMP</code>(QoS等级2)的情况下发送的QoS等级大于0的<code>PUBLISH</code>报文数量. <code>PUBACK</code>和<code>PUBCOMP</code>按照下述方式补充配额.</p><p>客户端或服务端<strong>必须</strong>将其初始发送配额设置为不超过接收最大值的非0值 [MQTT-4.9.0-1].</p><p>每当客户端或服务端发送了一个QoS等级大于0的<code>PUBLISH</code>报文, 它就会减少发送配额. 如果发送配额减为0, 客户端或服务端<strong>不能</strong>再发送任何QoS等级大于0的<code>PUBLISH</code>报文 [MQTT-4.9.0-2]. 它<strong>可以</strong>继续发送QoS为0的<code>PUBLISH</code>报文, 也<strong>可以</strong>选择暂停发送这些报文. 即使配额为0, 客户端和服务端也<strong>必须</strong>继续处理和响应其他MQTT控制报文 [MQTT-4.9.0-3].</p><p>发送配额增加1:</p><ul><li>每当收到一个<code>PUBACK</code>报文或<code>PUBCOMP</code>报文, 不管<code>PUBACK</code>或<code>PUBCOMP</code>报文是否包含错误码.</li><li>每次收到一个包含返回码大于等于0x80的<code>PUBREC</code>报文.</li></ul><p>如果发送配额已到达初始发送配额, 则不继续增加. 在初始发送配额之上尝试增加配额可能是由建立新的网络连接后重新发送<code>PUBREL</code>数据包引起的.</p><p>关于客户端和服务端在超出最大接收值的允许的情况下发送<code>PUBLISH</code>报文的描述, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">3.3.4节</a>.</p><p>发送配额和接收最大值的保留不跨越网络连接, 每次建立新的网络连接时按照上面的描述进行初始化. 它们不是会话状态的一部分.</p><h3 id="4-10-请求-响应"><a href="#4-10-请求-响应" class="headerlink" title="4.10 请求/响应"></a>4.10 请求/响应</h3><p>有些应用程序或标准可能希望通过MQTT协议运行请求/响应交互.此版本MQTT协议包含三个可用于此目的的属性:</p><ul><li>响应主题, 在<a href="https://www.zybuluo.com/khan-lau/note/1325300#33235-响应主题" target="_blank" rel="noopener">3.3.2.3.5节</a> 中描述</li><li>对比数据, 在<a href="https://www.zybuluo.com/khan-lau/note/1325300#33236-对比数据" target="_blank" rel="noopener">3.3.2.3.6节</a> 中描述</li><li>请求响应信息, 在<a href="https://www.zybuluo.com/khan-lau/note/1325300#312117-请求问题信息" target="_blank" rel="noopener">3.1.2.11.7节</a> 中描述</li><li>响应信息, 在<a href="https://www.zybuluo.com/khan-lau/note/1325300#322315-响应信息" target="_blank" rel="noopener">3.2.2.3.15节</a> 中描述<br>以下非规范部分描述了如何使用这些属性.</li></ul><p>客户端通过发布一个包含响应主题的应用消息来发送请求消息, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#33235-响应主题" target="_blank" rel="noopener">3.3.2.3.5节</a> 所述. 请求消息可以包含对比数据属性, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#33236-对比数据" target="_blank" rel="noopener">3.3.2.3.6节</a> 所述.</p><h4 id="4-10-1-基本请求响应-非规范"><a href="#4-10-1-基本请求响应-非规范" class="headerlink" title="4.10.1 基本请求响应(非规范)"></a>4.10.1 基本请求响应(非规范)</h4><p>请求/响应交互过程如下:</p><ol><li>MQTT客户端(请求方)向主题发布请求消息. 请求消息是具有响应主题的应用消息.</li><li>另一个MQTT客户端(响应方)订阅了与请求消息发布时使用的主题名相匹配的主题过滤器. 结果, 它收到请求消息. 可能有多个响应方订阅了此主题名, 也可能没有响应方.</li><li>响应方根据请求消息采取适当的操作, 然后往请求消息中携带的响应主题属性中的主题名发布响应消息.</li><li>典型用法, 请求放订阅了响应主题, 从而接收到响应信息.但是, 其他某些客户端可能会订阅响应主题, 因此它们也将接收和处理响应消息. 与请求消息一样, 可能有多个客户端订阅了响应消息的发送主题, 也可能没有.</li></ol><p>如果请求消息包含对比数据属性, 则响应方将此属性拷贝到响应消息中, 由响应消息的接收端用来将响应消息与原始请求相关联. 响应消息不包含响应主题属性.</p><p>MQTT服务端转发请求消息中的响应主题和对比数据属性, 和响应消息中的对比数据属性. 服务端像处理其他应用程序消息一样处理请求消息和响应消息.</p><p>请求放通常在发布请求消息之前订阅响应主题. 如果响应消息发送时没有任何订阅者订阅了响应主题, 则响应消息将不会传递给任何客户端.</p><p>请求消息和响应消息可以具有任何<code>QoS等级</code>, 并且响应方可以使用具有非0会话过期间隔的会话. 通常使用<code>QoS等级0</code>发送请求消息, 并且只有在应答者正连接时才发送请求消息. 但这不是必须的.</p><p>响应者可以使用<code>共享订阅</code>来允许响应客户端池. 注意, 使用<code>共享订阅</code>时, 不保证消息在客户端之间的分发顺序.</p><p>请求方有责任确保它具有发布消息到请求消息的主题、并订阅响应主题属性中主题名的必要权限. 响应方有责任确保它具有订阅请求主题和发布到响应主题的权限. 虽然主题授权不属于本规范, 但建议服务端实施此类授权.</p><h4 id="4-10-2-确定响应主题值-非规范"><a href="#4-10-2-确定响应主题值-非规范" class="headerlink" title="4.10.2 确定响应主题值(非规范)"></a>4.10.2 确定响应主题值(非规范)</h4><p>请求方可以通过包括本地配置在内的任何方式来确定作为他们的响应主题的主题名. 为避免不同请求方之间的冲突, 由请求方客户端使用的响应主题最好对于该客户端是唯一的. 由于请求方和响应方通常都需要对这些主题进行授权, 因此使用随机主题名称将会对授权造成挑战.</p><p>为了解决此问题, 本规范在<code>CONNACK</code>报文中定义了一个名为响应信息的属性. 服务端可以使用此属性指导客户端如何选择使用的响应主题. 此机制对于服务端和客户端都是可选的. 连接时, 客户端通过设置<code>CONNECT</code>报文中的请求响应信息属性来请求服务端发送响应信息. 这会导致服务端在<code>CONNACK</code>报文中插入响应信息属性(UTF-8编码的字符串).</p><p>本规范不定义响应信息的内容, 但它可以被用来传递主题树的全局唯一部分, 该部分至少在其会话的整个生命周期内保留给该客户端. 使用这种机制, 可以在服务端而不是每个客户端中完成该属性的配置.</p><p>有关响应信息的定义, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#312116-请求响应信息" target="_blank" rel="noopener">3.1.2.11.6节</a> .</p><h3 id="4-11-服务端重定向"><a href="#4-11-服务端重定向" class="headerlink" title="4.11 服务端重定向"></a>4.11 服务端重定向</h3><p>服务端<strong>可以</strong>通过发送包含原因码为<code>0x9C((临时)使用其他服务端)</code>或<code>0x9D(服务端已(永久)移动)</code>的<code>CONNACK</code>或<code>DISCONNECT</code>报文请求客户端使用另一台服务端, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.服务端发送这些原因码时<strong>可以</strong>包含一个服务端参考属性, 用以说明客户端<strong>应该</strong>使用的服务端位置.</p><p>原因码<code>0x9C ((临时)使用其他服务端)</code> 指定客户端<strong>应该</strong>临时切换到另一台服务端. 另一台服务端可能是客户端已知的, 也可能是由服务端参考所指定的.</p><p>原因码<code>0x9D (服务端已(永久)移动)</code>指定客户端<strong>应该</strong>永久切换到另一台服务端. 另一台服务端可能是客户端已知的, 也可能是由服务端参考所指定的.</p><p>服务端参考是一个UTF-8编码字符串, 其值是一个由空格分隔开的参考列表. 本规范不指定服务端参考的格式.</p><pre><code>非规范评注推荐每个参考包含名称及可选的端口号. 如果名称包含冒号, 则名称字符串可以由方括号括起来(“[“和“]”). 由方括号括起来的名称不能包含右方括号(“]”)字符, 用于表示使用冒号分隔符的IPv6地址.这是一个简化版的URI授权, 如 [RFC3986] 所述.非规范评注服务端参考中的名字通常代表主机名、DNS名 [RFC1035]、SRV名 [RFC2782] 或IP地址. 跟随冒号分隔符的通常是十进制端口号. 如果端口信息来自于DNS(比如包含SRV)或者使用默认端口, 则主机名后无需跟随端口号.非规范评注如果给出了多个服务端参考, 则期望客户端选择其中一个.非规范评注服务端参考示例如下:myserver.xyz.org myserver.xyz.org:888310.10.151.22:8883 [fe80::9610:3eff:fe1c]:1883</code></pre><p>允许服务端不发送服务端参考, 允许客户端忽略服务端参考. 此特性可用于负载均衡、服务端重定位和服务端预置服务端.</p><h3 id="4-12-增强认证"><a href="#4-12-增强认证" class="headerlink" title="4.12 增强认证"></a>4.12 增强认证</h3><p>MQTT <code>CONNECT</code>报文使用用户名和密码字段支持基本的网络连接认证. 这些字段虽然称为简单密码认证, 但可以被用来承载其他形式的认证, 例如把密码作为令牌(Token)传递.</p><p>增强认证包含质询/响应风格的认证, 从而扩展了基本认证.它可能涉及在<code>CONNECT</code>报文之后、<code>CONNACK</code>报文之前的客户端和服务端之间<code>AUTH</code>报文交换.</p><p>服务端通过在<code>CONNECT</code>报文中添加认证方法字段来启动增强认证. 此字段指定使用的认证方法. 如果服务端不支持客户端提供的认证方法, 它<strong>可以</strong>发送一个包含原因码<code>0x8C(无效的认证方法)</code>或<code>0x87(未授权)</code>的<code>CONNACK</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述, 并且<strong>必须</strong>关闭网络连接 [MQTT-4.12.0-1].</p><p>认证方法是客户端和服务端关于认证数据中的数据和<code>CONNECT</code>报文中其他字段的含义, 以及客户端和服务端完成认证需要交换和处理的协议.</p><pre><code>非规范评注认证方法通常为SASL(Simple Authentication and Security Layer)机制, 使用一个注册过的名称便于信息交换.然而, 认证方法不限于使用已注册的SASL机制.</code></pre><p>如果客户端选择的认证方法指定客户端先发送数据, 客户端<strong>应该</strong>在<code>CONNECT</code>报文中包含认证数据属性. 此属性可被用来提供认证方法指定的数据, 认证数据的内容由认证方法定义.</p><p>如果服务端需要额外的信息来完成认证, 它<strong>可以</strong>向客户端发送<code>AUTH</code>报文, 此报文<strong>必须</strong>包含原因码<code>0x18(继续认证)</code> [MQTT-4.12.0-2]. 如果认证方法需要服务端向客户端发送认证相关的数据, 这些数据在<code>认证数据(Authentication Data)</code>中发送.</p><p>客户端通过发送另一个<code>AUTH</code>报文响应来自服务端的 <code>AUTH</code> 报文, 此报文<strong>必须</strong>包含原因码<code>0x18(继续认证)</code> [MQTT-4.12.0-3]. 如果认证方法要求客户端向服务端发送认证相关的数据, 这些数据在<code>认证数据(Authentication Data)</code>中发送.</p><p>客户端和服务端按需交换<code>AUTH</code>报文, 直到服务端通过发送包含原因码为0的<code>CONNACK</code>报文接受认证为止. 如果接受认证需要向客户端发送数据, 这些数据在认证数据中发送.</p><p>客户端<strong>可以</strong>在处理过程中随时关闭连接. 它<strong>可以</strong>在关闭之前发送<code>DISCONNECT</code>报文. 服务端<strong>可以</strong>在处理过程中随时拒绝认证. 它<strong>可以</strong>发送包含原因码大于等于0x80的<code>CONNACK</code>报文 , 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述, 并且<strong>必须</strong>关闭网络连接 [MQTT-4.12.0-4].</p><p>如果初始<code>CONNECT</code>报文包含认证方法属性, 则所有的<code>AUTH</code>报文和成功的<code>CONNACK</code>报文必须包含与<code>CONNECT</code>报文中相同的认证方法属性. [MQTT-4.12.0-5].</p><p>增强认证的实现对于客户端和服务端来说都是可选的. 如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 则服务端不能发送AUTH报文, 且不能在<code>CONNACK</code>报文中发送认证方法 [MQTT-4.12.0-6]. 如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 则客户端不能向服务端发送<code>AUTH</code>报文 [MQTT-4.12.0-7].</p><p>如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 服务端应该使用<code>CONNECT</code>报文中的信息、TLS会话和网络连接进行认证.</p><p><code>SCRAM认证</code>非规范示例</p><ul><li>客户端到服务端:<code>CONNECT</code>认证方法=”SCRAM-SHA-1”, 认证数据=client-first-data</li><li>服务端到客户端:<code>AUTH</code>原因码=0x18, 认证方法=”SCRAM-SHA-1”, 认证数据=server-first-data</li><li>客户端到服务端:<code>AUTH</code>原因码=0x18, 认证方法=”SCRAM-SHA-1”, 认证数据=client-final-data</li><li>服务端到客户端:<code>CONNACK</code>原因码=0, 认证方法=”SCRAM-SHA-1”, 认证数据=server-final-data</li></ul><p><code>Kerberos认证</code>非规范示例</p><ul><li>客户端到服务端:<code>CONNECT</code>认证方法=”GS2-KRB5”</li><li>服务端到客户端:<code>AUTH</code>原因码=0x18, 认证方法=”GS2-KRB5”</li><li>客户端到服务端:<code>AUTH</code>原因码=0x18, 认证方法=”GS2-KRB5”, 认证数据=initial context token</li><li>服务端到客户端:<code>AUTH</code>原因码=0x18, 认证方法=”GS2-KRB5”, 认证数据=reply context token</li><li>客户端到服务端:<code>AUTH</code>原因码=0x18, 认证方法=”GS2-KRB5”</li><li>服务端到客户端:<code>CONNACK</code>原因码=0, 认证方法=”GS2-KRB5”, 认证数据=outcome of authentication</li></ul><h4 id="4-12-1-重新认证"><a href="#4-12-1-重新认证" class="headerlink" title="4.12.1 重新认证"></a>4.12.1 重新认证</h4><p>如果客户端在<code>CONNECT</code>报文中提供了认证方法, 它<strong>可以</strong>在收到<code>CONNACK</code>报文之后的任何时间通过发送包含原因码<code>0x19(重新认证)</code>的<code>AUTH</code>报文发起重新认证. 客户端<strong>必须</strong>将认证方法设置为与最初验证网络连接时的认证方法一致 [MQTT-4.12.1-1].如果认证方法需要客户端先发送数据, 则此<code>AUTH</code>报文包含第一片认证数据.</p><p>服务端通过向客户端发送<code>AUTH</code>报文来响应此重新认证请求, 包含原因码为0x00(成功)的<code>AUTH</code>报文指示重新认证完成, 包含原因码为<code>0x18(继续认证)</code>的<code>AUTH</code>报文指示需要更多的认证数据. 客户端可以通过发送包含原因码<code>0x18(继续认证)</code>的<code>AUTH</code>报文来响应附加的认证数据. 此流程与原始身份验证一样, 直到重新认证完成或重新认证失败.</p><p>如果重新认证失败, 客户端或服务端<strong>应该</strong>发送包含适当原因码的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 并且必须关闭网络连接 [MQTT-4.12.1-2].</p><p>在重新认证的过程中, 客户端和服务端的其他报文流可以继续使用之前的认证.</p><pre><code>非规范评注服务端可以通过拒绝重新认证来限制客户端在重新认证中尝试的更改范围. 例如, 如果服务端不允许更改用户名, 它可以使任何尝试更改用户名的重新认证都失败.</code></pre><h3 id="4-13-错误处理"><a href="#4-13-错误处理" class="headerlink" title="4.13 错误处理"></a>4.13 错误处理</h3><h4 id="4-13-1-无效报文和协议错误"><a href="#4-13-1-无效报文和协议错误" class="headerlink" title="4.13.1 无效报文和协议错误"></a>4.13.1 无效报文和协议错误</h4><p><code>无效报文(Malformed Packet)</code>和<code>协议错误(Protocol Error)</code>的定义见<a href="https://www.zybuluo.com/khan-lau/note/1325300#12-术语" target="_blank" rel="noopener">1.2节</a> 术语.这些错误案例的部分术语贯穿本规范. 客户端或服务端对其收到的MQTT控制报文的检查严格程度依赖:</p><ul><li>客户端或服务端实现的大小.</li><li>实现支持的性能.</li><li>接收端对发送端发送的MQTT控制报文的信任程度.</li><li>接收端对用于分发MQTT控制报文的网络的信任程度.</li><li>继续处理错误报文的的后果.</li></ul><p>如果发送端遵守此规范, 它将不会发送无效报文或导致协议错误. 然而, 如果客户端在收到<code>CONNACK</code>报文之前发送MQTT控制报文, 它可能会因为错误的估计了服务端的性能而导致协议错误. 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">3.1.4节</a> <code>CONNECT</code> 行为.</p><p>无效报文和协议错误使用的原因码包括:</p><ul><li><code>0x81</code> 无效报文</li><li><code>0x82</code> 协议错误</li><li><code>0x93</code> 超过接收最大值</li><li><code>0x95</code> 报文过大</li><li><code>0x9A</code> 不支持保留</li><li><code>0x9B</code> 不支持的QoS等级</li><li><code>0x9E</code> 不支持共享订阅</li><li><code>0xA1</code> 不支持订阅标识符</li><li><code>0xA2</code> 不支持通配符订阅</li></ul><p>当客户端检测到无效报文或协议错误, 并且本规范中给出了相应的原因码时, 它应该关闭网络连接. 在<code>AUTH</code>报文出错的情况下它可以在关闭网络连接之前发送包含原因码的<code>DISCONNECT</code>报文. 在其他报文出错的情况下它应该在关闭网络连接之前发送包含原因码的<code>DISCONNECT</code>报文. 使用原因码<code>0x81(错误报文)</code>或<code>0x82(协议错误)</code>, 除非包含<a href="https://www.zybuluo.com/khan-lau/note/1325300#31421-断开原因码" target="_blank" rel="noopener">3.14.2.1 断开原因码</a> 中定义的更具体的原因码.</p><p>当服务端检测到无效报文或协议错误, 并且本规范中给出了相应的原因码时, 它必须关闭网络连接 [MQTT-4.13.1-1]. 在<code>CONNECT</code>报文出错的情况下它可以在关闭网络连接之前发送包含原因码的<code>CONNACK</code>报文. 在其他报文出错的情况下它应该在关闭网络连接之前发送包含原因码的<code>DISCONNECT</code>报文. 使用原因码<code>0x81(无效报文)</code>或<code>0x82(协议错误)</code>, 除非包含<a href="https://www.zybuluo.com/khan-lau/note/1325300#3222-连接原因码" target="_blank" rel="noopener">3.2.2.2节 - 连接原因码</a> 或<a href="https://www.zybuluo.com/khan-lau/note/1325300#31421-断开原因码" target="_blank" rel="noopener">3.14.2.1节 – 断开原因码</a> 中定义的更具体的原因码. 对其他会话没有影响.</p><p>如果服务端或客户端省略了检查MQTT控制报文的某些特性, 它可能无法检测到某个错误, 因此可能会导致数据被损坏.</p><h4 id="4-13-2-其他错误"><a href="#4-13-2-其他错误" class="headerlink" title="4.13.2 其他错误"></a>4.13.2 其他错误</h4><p>发送端无法预料到无效报文和协议错误以外的错误, 因为它可能有某些没有告知发送端的约束. 客户端或服务端可能在接收时遇到短暂的错误, 比如内存不足, 导致无法成功的处理某个MQTT控制报文.</p><p>包含原因码大于等于0x80的确认报文<code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBACK</code>, <code>UNSUBACK</code>表明收到了某个报文标识符的报文出错. 这不会影响其他会话或此会话上的其他报文.</p><p><code>CONNACK</code>报文和<code>DISCONNECT</code>报文允许使用大于等于0x80的原因码以指示网络连接将被关闭. 如果某个大于等于0x80的原因码被指定, 无论是否发送<code>CONNACK</code>报文或<code>DISCONNECT</code>报文, 必须关闭网络连接 [MQTT-4.13.2-1]. 发送这些原因码不会影响任何其他会话.</p><p>如果控制报文包含多个错误, 接收端可以按照任意顺序对报文进行验证, 并对发现的任何错误采取适当的行为.</p><h2 id="5-安全-非规范"><a href="#5-安全-非规范" class="headerlink" title="5 安全(非规范)"></a>5 安全(非规范)</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>强烈建议提供<code>TLS [RFC5246]</code> 的服务端实现使用<code>TCP端口8883</code>(IANA服务名:secure-mqtt).</p><p>安全是一个快速变化的领域, 所以在设计安全解决方案时总是使用最新的建议.</p><p>解决方案需要考虑的风险包括:</p><ul><li>设备可能会被盗用</li><li>客户端和服务端的静态数据可能是可访问的(可能会被修改)</li><li>协议行为可能有副作用(如计时器攻击)</li><li>拒绝服务(DoS)攻击</li><li>通信可能会被拦截、修改、重定向或泄露</li><li>虚假MQTT控制报文注入</li></ul><p>MQTT方案通常部署在不安全的通信环境中.在这种情况下, 协议实现通常需要提供这些机制:</p><ul><li>用户和设备身份认证</li><li>服务端资源访问授权</li><li>MQTT控制报文和内嵌应用数据的完整性校验</li><li>MQTT控制报文和内嵌应用数据的隐私控制</li></ul><p>作为传输层协议, MQTT仅关注消息传输, 提供合适的安全功能是实现者的责任.使用<code>TLS [RFC5246]</code> 是比较普遍的选择.</p><p>除了技术上的安全问题外, 还有地区因素(例如<code>美国欧盟隐私盾框架 [USEUPRIVSH]</code>), 行业标准(例如<code>第三方支付行业数据安全标准 [PCIDSS]</code>), 监管方面的考虑(例如<code>萨斯班-奥克斯利法案[SARBANES]</code>).</p><h3 id="5-2-MQTT解决方案-安全和认证"><a href="#5-2-MQTT解决方案-安全和认证" class="headerlink" title="5.2 MQTT解决方案:安全和认证"></a>5.2 MQTT解决方案:安全和认证</h3><p>协议实现可能需要提供符合特定行业安全标准, 如<code>NIST网络安全框架 [NISTCSF]</code>, 第<code>三方支付行业数据安全标准 [PCIDSS]</code>, <code>美国联邦信息处理标准 [FIPS1402]</code> 和<code>NSA加密组合B [NSAB]</code>.</p><p>在MQTT的补充出版物(MQTT and the NIST Framework for Improving Critical Infrastructure Cybersecurity [MQTTNIST])中可以找到在<code>NIST网络安全框架 [NISTCSF]</code> 中使用MQTT的指导. 使用行业证明、独立审计和认证技术有助于满足合规要求.</p><h3 id="5-3-轻量级的加密与受限设备"><a href="#5-3-轻量级的加密与受限设备" class="headerlink" title="5.3 轻量级的加密与受限设备"></a>5.3 轻量级的加密与受限设备</h3><p>广泛采用的加密算法是<code>高级加密标准 [AES]</code>. 对AES提供了硬件支持的处理器有很多, 但通常不包含嵌入式处理器. <code>加密算法ChaCha20 [CHACHA20]</code> 软件加解密速度快很多, 但不像AES那样广泛可用.</p><p>推荐使用为资源受限的低端设备特别优化过的<code>轻量级加密国际标准ISO 29192 [ISO29192]</code>.</p><h3 id="5-4-实现注意事项"><a href="#5-4-实现注意事项" class="headerlink" title="5.4 实现注意事项"></a>5.4 实现注意事项</h3><p>实现或使用MQTT时需要考虑许多安全问题. 以下章节不应被视为核对清单 .</p><p>协议实现时可以实现下面的一部分或全部:</p><h4 id="5-4-1-客户端身份认证"><a href="#5-4-1-客户端身份认证" class="headerlink" title="5.4.1 客户端身份认证"></a>5.4.1 客户端身份认证</h4><p><code>CONNECT</code>报文包含<code>用户名</code>和<code>密码</code>字段. 实现可以决定如何使用这些字段的内容.实现者可以提供自己的身份验证机制, 或者使用外部的认证系统如<code>LDAP [RFC4511]</code> 或 <code>Auth [RFC6749]</code> , 还可以利用操作系统的认证机制.</p><p>MQTT v5.0提供了一种增强认证机制, <a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">如4.12节</a> 所述.使用此机制需要客户端和服务端双方的支持.</p><p>实现可以明文传递认证数据, 混淆数据元素, 或者不要求任何认证数据, 但应该意识到这会增加中间人攻击和重放攻击的风险. <a href="https://www.zybuluo.com/khan-lau/note/1325300#545-应用消息和mqtt控制报文的保密性" target="_blank" rel="noopener">5.4.5节</a> 介绍了确保数据私密的方法.</p><p>在客户端和服务端之间使用虚拟专用网(VPN)可以确保数据只被授权的客户端收到.</p><p>使用<code>TLS [RFC5246]</code> 时, 服务端可以使用客户端发送的TLS证书验证客户端的身份.</p><p>实现可以允许客户端通过应用消息给服务端发送用于身份验证的凭证.</p><h4 id="5-4-2-客户端授权"><a href="#5-4-2-客户端授权" class="headerlink" title="5.4.2 客户端授权"></a>5.4.2 客户端授权</h4><p>如果客户端已经成功通过身份认证, 服务端实现需要在接受连接之前执行授权检查.</p><p>授权可以基于客户端提供的信息如用户名, 客户端主机名/IP地址, 或认证机制的结果.</p><p>具体来说, 实现应该检查客户端是否被授权使用此客户标识符, 因为客户标识符提供了对MQTT会话状态的访问(如<a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a> 所述). 此授权检查是为了防止某个客户端偶然或恶意的使用了已被其他客户端所使用的客户标识符.</p><p>实现应该提供发生在<code>CONNECT</code>之后的访问控制以限制客户端发布消息到特定主体或使用特定主体过滤器进行订阅的能力. 实现需要考虑对具有广泛作用域的主题过滤器的访问限制, 如<code>&quot;#&quot;</code>主题过滤器.</p><h4 id="5-4-3-服务端身份认证"><a href="#5-4-3-服务端身份认证" class="headerlink" title="5.4.3 服务端身份认证"></a>5.4.3 服务端身份认证</h4><p>MQTT协议不是双向信任的.基本认证没有提供客户端验证服务端身份的机制.某些形式的扩展认证允许双向认证.</p><p>但是使用<code>TLS [RFC5246]</code> 时, 客户端可以使用服务端发送的TLS证书验证服务端的身份. 从单IP多域名提供MQTT服务的实现应该考虑 [RFC6066] 第3节定义的TLS的<code>SNI扩展</code>. SNI允许客户端告诉服务端它要连接的服务端主机名.</p><p>实现可以允许服务端通过应用消息给客户端发送凭证用于身份验证. MQTT v5.0提供了一种增强的认证机制, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a> 所述, 它可以被客户端用于验证服务端. 使用此机制需要客户端和服务端双方的支持.</p><p>在客户端和服务端之间使用虚拟专用网(VPN)可以确保客户端正连接的是预期的服务端.</p><h4 id="5-4-4-应用消息和MQTT控制报文的完整性"><a href="#5-4-4-应用消息和MQTT控制报文的完整性" class="headerlink" title="5.4.4 应用消息和MQTT控制报文的完整性"></a>5.4.4 应用消息和MQTT控制报文的完整性</h4><p>应用可以在应用消息中单独包含哈希值. 这样做可以为<code>PUBLISH</code>报文的网络传输和静态数据提供内容的完整性检查.</p><p><code>TLS [RFC5246]</code> 提供了对网络传输的数据做完整性校验的哈希算法.</p><p>在客户端和服务端之间使用虚拟专用网(VPN)连接可以在VPN覆盖的网络段提供数据完整性检查.</p><h4 id="5-4-5-应用消息和MQTT控制报文的保密性"><a href="#5-4-5-应用消息和MQTT控制报文的保密性" class="headerlink" title="5.4.5 应用消息和MQTT控制报文的保密性"></a>5.4.5 应用消息和MQTT控制报文的保密性</h4><p><code>TLS [RFC5246]</code> 可以对网络传输的数据加密.如果有效的 TLS 密码组合包含的加密算法为 NULL, 那么它不会加密数据. 要确保客户端和服务端的保密, 应避免使用这些密码组合.</p><p>应用可以单独加密应用消息的内容. 这可以提供应用消息传输途中和静态数据的私密性. 但不能给应用消息的其它属性如主题名加密.</p><p>客户端和服务端实现可以加密存储静态数据, 例如可以将应用消息作为会话的一部分存储.</p><p>在客户端和服务端之间使用虚拟专用网(VPN)连接可以在VPN覆盖的网络段保证数据的私密性.</p><h4 id="5-4-6-消息传输的不可否认性"><a href="#5-4-6-消息传输的不可否认性" class="headerlink" title="5.4.6 消息传输的不可否认性"></a>5.4.6 消息传输的不可否认性</h4><p>应用设计者可能需要考虑适当的策略, 以实现端到端的<code>不可否认性(non-repudiation)</code>.</p><h4 id="5-4-7-客户端和服务端盗用检测"><a href="#5-4-7-客户端和服务端盗用检测" class="headerlink" title="5.4.7 客户端和服务端盗用检测"></a>5.4.7 客户端和服务端盗用检测</h4><p>使用<code>TLS [RFC5246]</code>的客户端和服务端实现应该能够确保, 初始化TLS连接时提供的 SSL 证书是与主机名(客户端要连接的或服务端将被连接的)关联的.</p><p>使用<code>TLS [RFC5246]</code> 的客户端和服务端实现, 可以选择提供<code>检查证书吊销列表(CRLs [RFC5280])</code>和<code>在线整数状态协议(OSCP) [RFC6960]</code> 的功能, 拒绝使用被吊销的整数.</p><p>物理部署可以将防篡改硬件与应用消息的特殊数据传输结合. 例如, 一个仪表可能会内置一个GPS以确保没有在未授权的地区使用. IEEE安全设备认证 [IEEE8021AR] 就是用于实现这个机制的一个标准, 它使用加密绑定标识符验证设备身份.</p><h4 id="5-4-8-异常行为检测"><a href="#5-4-8-异常行为检测" class="headerlink" title="5.4.8 异常行为检测"></a>5.4.8 异常行为检测</h4><p>服务端实现可以监视客户端的行为, 检测潜在的安全风险.例如:</p><ul><li>重复的连接请求</li><li>重复的身份验证请求</li><li>连接的异常终止</li><li>主题扫描(请求发送或订阅大量主题)</li><li>发送无法送达的消息(没有订阅者的主题)</li><li>客户端连接但是不发送数据</li></ul><p>发现违反安全规则的行为, 服务端实现可以关闭客户端的网络连接.</p><p>服务端实现检测不受欢迎的行为, 可以基于IP地址或客户标识符实现一个动态黑名单列表.</p><p>服务部署可以使用网络层次控制(如果可用)实现基于IP地址或其它信息的速率限制或黑名单.</p><h4 id="5-4-9-其它安全注意事项"><a href="#5-4-9-其它安全注意事项" class="headerlink" title="5.4.9 其它安全注意事项"></a>5.4.9 其它安全注意事项</h4><p>如果客户端或服务端的TLS证书丢失, 或者我们考虑证书被盗用或者被吊销(利用 CRLs [RFC5280] 和 OSCP [RFC6960])的情况.</p><p>客户端或服务端验证凭证时, 如果发现用户名和密码丢失或被盗用, 应该吊销或者重新发放.</p><p>在使用长连接时:<br>- 客户端和服务端使用<code>TLS [RFC5246]</code> 时应该允许重新协商会话以确认新的加密参数(替换会话密钥, 更换密码组合, 更换认证凭证).<br>- 服务端可以关闭客户端的网络连接, 并要求他们使用新的凭证重新验证身份.<br>- 服务端可以要求客户端使用<a href="https://www.zybuluo.com/khan-lau/note/1325300#4121-重新认证" target="_blank" rel="noopener">4.12.1节</a> 中描述的机制周期性的进行重新认证.</p><p>资源受限设备或使用受限网络的客户端可以使用<code>TLS [RFC5246</code>] 会话恢复, 以降低<code>TLS [RFC5246]</code> 会话重连的成本.</p><p>连接到服务端的客户端与其它连接到服务端的客户端之间有一个信任传递关系, 它们都有权在同一个主题上发布消息.</p><h4 id="5-4-10-使用SOCK代理"><a href="#5-4-10-使用SOCK代理" class="headerlink" title="5.4.10 使用SOCK代理"></a>5.4.10 使用SOCK代理</h4><p>客户端实现应该意识到某些环境要求使用<code>SOCKSv5 [RFC1928]</code> 代理创建出站的网络连接. 某些MQTT实现可以利用安全隧道(如SSH)通过SOCKS代理. 一个实现决定支持SOCKS时, 它们应该同时支持匿名的和用户名密码验证的SOCKS代理. 对于后一种情况, 实现应该意识到SOCKS可能使用明文认证, 因此应该避免使用相同的凭证连接 MQTT 服务器.</p><h4 id="5-4-11-安全配置文件"><a href="#5-4-11-安全配置文件" class="headerlink" title="5.4.11 安全配置文件"></a>5.4.11 安全配置文件</h4><p>实现者和方案设计者可能希望将安全当作配置文件集合应用到MQTT协议中. 下面描述的是一个分层的安全等级结构.</p><h4 id="5-4-11-1-开放通信配置"><a href="#5-4-11-1-开放通信配置" class="headerlink" title="5.4.11.1 开放通信配置"></a>5.4.11.1 开放通信配置</h4><p>使用开放通信配置时, MQTT协议运行在一个没有内置额外安全通信机制的开放网络上.</p><h4 id="5-4-11-2-安全网络通信配置"><a href="#5-4-11-2-安全网络通信配置" class="headerlink" title="5.4.11.2 安全网络通信配置"></a>5.4.11.2 安全网络通信配置</h4><p>使用安全网络通信配置时, MQTT协议运行在有安全控制的物理或虚拟网络上, 如VPN或物理安全网络.</p><h4 id="5-4-11-3-安全传输配置"><a href="#5-4-11-3-安全传输配置" class="headerlink" title="5.4.11.3 安全传输配置"></a>5.4.11.3 安全传输配置</h4><p>使用安全传输配置时, MQTT协议运行在使用 <code>TLS [RFC5246]</code> 的物理或虚拟网络上, 它提供了身份认证, 完整性和保密性.</p><p>使用内置的用户名称和密码字段, <code>TLS [RFC5246]</code> 客户端身份认证可被用于(或者替代)MQTT客户端认证.</p><h4 id="5-4-11-4-工业标准的安全配置"><a href="#5-4-11-4-工业标准的安全配置" class="headerlink" title="5.4.11.4 工业标准的安全配置"></a>5.4.11.4 工业标准的安全配置</h4><p>可以预料的是, MQTT协议被设计为支持很多工业标准的应用配置, 每一种定义一个威胁模型和用于定位威胁的特殊安全机制. 特殊的安全机制推荐从下面的方案中选择:</p><p>[<code>NISTCSF</code>] NIST网络安全框架<br>[<code>NIST7628</code>] NISTIR 7628智能电网网络安全指南<br>[<code>FIPS1402</code>] (FIPS PUB 140-2)加密模块的安全要求<br>[<code>PCIDSS</code>] PCI-DSS 第三方支付行业数据安全标准<br>[<code>NSAB</code>] NSA 加密组合B</p><h2 id="6-使用WebSocket作为网络层"><a href="#6-使用WebSocket作为网络层" class="headerlink" title="6 使用WebSocket作为网络层"></a>6 使用WebSocket作为网络层</h2><p>如果MQTT在<code>WebSocket [RFC6455]</code> 连接上传输, 要满足下面的条件:</p><ul><li>MQTT控制报文<strong>必须</strong>使用WebSocket二进制数据帧发送.如果收到任何其它类型的数据帧, 接收者<strong>必须</strong>关闭网络连接 [MQTT-6.0.0-1].</li><li>单个WebSocket数据帧<strong>可以</strong>包含多个或者部分MQTT报文.接收者<strong>不能</strong>假设MQTT控制报文按WebSocket帧边界对齐 [MQTT-6.0.0-2].</li><li>客户端<strong>必须</strong>将字符串”mqtt”包含在它提供的WebSocket子协议列表里 [MQTT-6.0.0-3].</li><li>服务端选择和返回的WebSocket子协议名<strong>必须</strong>是”mqtt” [MQTT-6.0.0-4].</li><li>用于连接客户端和服务器的WebSocket URI对MQTT协议没有任何影响.</li></ul><h3 id="6-1-IANA注意事项"><a href="#6-1-IANA注意事项" class="headerlink" title="6.1 IANA注意事项"></a>6.1 IANA注意事项</h3><p>本规范请求IANA修改“WebSocket子协议名”条目下MQTT子协议注册信息为下列数据:</p><ul><li>图 6 1 IANA WebSocket标识符</li></ul><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left">子协议标识符</td></tr><tr><td align="left">子协议通用名</td></tr><tr><td align="left">子协议定义</td></tr></tbody></table><h2 id="7-一致性"><a href="#7-一致性" class="headerlink" title="7 一致性"></a>7 一致性</h2><p>MQTT规范定义了MQTT客户端实现和MQTT服务端实现的一致性要求. MQTT实现可以同时作为MQTT客户端和MQTT服务端.</p><h2 id="7-1-一致性条款"><a href="#7-1-一致性条款" class="headerlink" title="7.1 一致性条款"></a>7.1 一致性条款</h2><h4 id="7-1-1-MQTT服务端一致性条款"><a href="#7-1-1-MQTT服务端一致性条款" class="headerlink" title="7.1.1 MQTT服务端一致性条款"></a>7.1.1 MQTT服务端一致性条款</h4><p>服务端的定义, 参考术语章节的<code>服务端(Server)</code>部分.</p><p>MQTT服务端只有满足下面所有的要求才算是符合本规范:<br>\1. 服务端发送的所有MQTT控制报文的格式符合<a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章</a>和<a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章</a>描述的格式.<br>\2. 遵守<a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> 描述的主题匹配规则和<a href="https://www.zybuluo.com/khan-lau/note/1325300#48-订阅" target="_blank" rel="noopener">4.8节</a> 匹配的订阅规则.<br>\3. 满足下列章节中所有必须级别的要求, 明确仅适用于对客户端的除外:<br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#1-概述" target="_blank" rel="noopener">第一章 - 介绍</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章 - MQTT控制报文格式</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章 - MQTT控制报文</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#4-操作行为" target="_blank" rel="noopener">第四章 - 操作行为</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">第六章 - 使用WebSocket作为网络层</a><br>\4. 为了能够与任何其他一致的(MQTT)实现进行互操作, 无需使用在规范之外定义的任何扩展.</p><h4 id="7-1-2-MQTT客户端一致性条款"><a href="#7-1-2-MQTT客户端一致性条款" class="headerlink" title="7.1.2 MQTT客户端一致性条款"></a>7.1.2 MQTT客户端一致性条款</h4><p>客户端的定义, 参考术语章节的<code>客户端(Client)</code> 部分.</p><p>MQTT客户端只有满足下面所有的要求才算是符合本规范:<br>\1. 客户端发送端所有MQTT控制报文的格式符合<a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章</a>和<a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章</a>描述的格式.<br>\2. 满足下列章节中所有必须级别的要求, 明确仅适用于对服务端的除外:<br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#1-概述" target="_blank" rel="noopener">第一章 - 介绍</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章 - MQTT控制报文格式</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章 - MQTT控制报文</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#4-操作行为" target="_blank" rel="noopener">第四章 - 操作行为</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">第六章 - 使用WebSocket作为网络层</a><br>\3. 为了能够与任何其他一致的(MQTT)实现进行互操作, 无需使用在规范之外定义的任何扩展.</p><h2 id="Appendix-A-致谢"><a href="#Appendix-A-致谢" class="headerlink" title="Appendix A. 致谢"></a>Appendix A. 致谢</h2><p>技术委员会特别感谢Andy Stanford-Clark博士和Arlen Nipper博士作为MQTT协议的原始发明者以及他们对标准化过程的持续支持.</p><p>以下成员在本规范制定期间为OASIS技术委员会成员, 他们的贡献值得感谢:</p><p>参与者:<br>- Senthil Nathan Balasubramaniam (Infiswift)<br>- Dr. Andrew Banks, editor (IBM)<br>- Ken Borgendale, editor (IBM)<br>- Ed Briggs, editor (Microsoft)<br>- Raphael Cohn (Individual)<br>- Richard Coppen, chairman (IBM)<br>- William Cox (Individual)<br>- Ian Craggs , secretary (IBM)<br>- Konstantin Dotchkoff (Microsoft)<br>- Derek Fu (IBM)<br>- Rahul Gupta, editor (IBM)<br>- Stefan Hagen (Individual)<br>- David Horton (Solace Systems)<br>- Alex Kritikos (Software AG, Inc.)<br>- Jonathan Levell (IBM)<br>- Shawn McAllister (Solace Systems)<br>- William McLane (TIBCO Software Inc.)<br>- Peter Niblett (IBM)<br>- Dominik Obermaier (dc-square GmbH)<br>- Nicholas O’Leary (IBM)<br>- Brian Raymor, chairman (Microsoft)<br>- Andrew Schofield (IBM)<br>- Tobias Sommer (Cumulocity)<br>- Joe Speed (IBM)<br>- Dr Andy Stanford-Clark (IBM)<br>- Allan Stockdill-Mander (IBM)<br>- Stehan Vaillant (Cumulocity)</p><p>有关对早期版本MQTT协议做出贡献的人员列表, 参考MQTT v3.1.1规范中的附录A [MQTTV311].</p><h2 id="Appendix-B-强制性规范声明-非规范"><a href="#Appendix-B-强制性规范声明-非规范" class="headerlink" title="Appendix B. 强制性规范声明(非规范)"></a>Appendix B. 强制性规范声明(非规范)</h2><p>此附录是非规范性的, 只作为本文档正文中可以找到的大量一致性声明的摘要提供. 参考 <a href="https://www.zybuluo.com/khan-lau/note/1325300#7-一致性" target="_blank" rel="noopener">第七章</a> 一致性要求限制列表.</p><p>规范声明序号 规范声明<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">MQTT-1.5.4-1</a> UTF-8编码字符串中的数据<strong>必须</strong>是按照 [Unicode] 规范定义的, 在RFC 3629 [RFC3629] 中重申的有效的UTF-8格式. 特别需要指出的是, 这些数据<strong>不能</strong>包含字符码在U+D800和U+DFFF之间的数据.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">MQTT-1.5.4-2</a> UTF-8编码的字符串<strong>不能</strong>包含空字符U+0000.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">MQTT-1.5.4-3</a> UTF-8编码序列0xEF 0xBB 0xBF总是被解释为U+FEFF (“零宽度非换行空白字符”) , 无论它出现在字符串的什么位置, 报文接收者都<strong>不能</strong>跳过或者剥离它.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#155-变长字节整数" target="_blank" rel="noopener">MQTT-1.5.5-1</a> 编码值<strong>必须</strong>使用表示该值所需的最少字节数.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#157-utf-8字符串对" target="_blank" rel="noopener">MQTT-1.5.7-1</a> 所有的字符串都<strong>必须</strong>符合UTF-8编码字符串的要求.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#213-标志" target="_blank" rel="noopener">MQTT-2.1.3-1</a> 如果标记位被标记为“保留”, 则保留它以供将来使用, 并且<strong>必须</strong>设置为所列出的值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-2</a> QoS等级为0的<code>PUBLISH</code>报文<strong>不能</strong>包含报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-3</a> 客户端每次发送新的<code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>或<code>PUBLISH</code>(当QoS等级&gt;0)MQTT控制报文时, 它<strong>必须</strong>为其分配一个当前未被使用的非0报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-4</a> 服务端每次发送新的<code>PUBLISH</code>(当QoS等级&gt;0)MQTT控制报文时, 它<strong>必须</strong>为其分配一个当前未被使用的非0报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-5</a> <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>或<code>PUBCOMP</code>报文<strong>必须</strong>包含<code>PUBLISH</code>报文中发送的原始报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-6</a> <code>SUBACK</code>和<code>UNSUBACK</code>报文<strong>必须</strong>包含相应的<code>SUBSCRIBE</code>和<code>UNSUBSCRIBE</code>报文中使用的报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#2221-属性长度" target="_blank" rel="noopener">MQTT-2.2.2-1</a> 如果没有属性, 属性长度必须为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#31-connect--连接请求" target="_blank" rel="noopener">MQTT-3.1.0-1</a> 客户端到服务端的网络连接建立后, 客户端发送给服务端的第一个报文<strong>必须</strong>是<code>CONNECT</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#31-connect--连接请求" target="_blank" rel="noopener">MQTT-3.1.0-2</a> 当协议错误并关闭网络连接时, 服务端<strong>必须</strong>处理客户端发送的第二个<code>CONNECT</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-1</a> 协议名<strong>必须</strong>是UTF-8字符串”MQTT”. 如果服务端不想接受<code>CONNECT</code>, 并希望透露它是MQTT服务端, 它<strong>可以</strong>发送一个包含原因码为<code>0x84(不支持的协议版本)</code>的<code>CONNACK</code>报文, 然后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-2</a> 如果协议版本不为5, 且服务端不想接受<code>CONNECT</code>报文, 则服务端<strong>可以</strong>发送一个包含原因码为<code>0x84(不支持的协议版本)</code>的<code>CONNACK</code>报文, 然后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-3</a> 服务端<strong>必须</strong>验证<code>CONNECT</code>报文的保留标志位(第0位)是否为 0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-4</a> 如果<code>CONNECT</code>报文的新开始标志被设置为1, 则客户端和服务端<strong>必须</strong>丢弃任何已存在的会话并开始一个新的会话.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-5</a> 如果<code>CONNECT</code>报文的新开始标志被设置为0, 并且存在与该客户标识符相关联的会话, 服务端<strong>必须</strong>基于此会话恢复与客户端的通信.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-6</a> 如果<code>CONNECT</code>报文的新开始标志被设置为0, 并且不存在与该客户标识符相关联的会话, 则服务端<strong>必须</strong>创建一个新的会话.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-7</a> 遗嘱标志被设置为1, 表示遗嘱消息<strong>必须</strong>被存储在服务端并与会话相关联.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-8</a> 在网络连接被关闭且遗嘱延时间隔已过或会话结束时遗嘱消息<strong>必须</strong>被发布, 除非遗嘱消息被服务端在收到包含原因码为<code>0x00(正常关闭)</code>的<code>DISCONNECT</code>报文后删除或关于此客户标识符的一个新的网络连接在遗嘱消息间隔过期之前被打开.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-9</a> 如果遗嘱标志被设置为0, 连接标志中的遗嘱QoS等级和遗嘱保留字段<strong>将会</strong>被服务端使用, 遗嘱属性、遗嘱主题和遗嘱消息字段<strong>必须</strong>存在于载荷中.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-10</a> 一旦遗嘱消息被发布或者服务端收到包含原因码为0x00(正常关闭)的<code>DISCONNECT</code>报文, 遗嘱消息<strong>必须</strong>从服务端的会话中删除.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-11</a> 如果遗嘱标志设置为0, 遗嘱QoS等级<strong>必须</strong>也设置为0 (0x00).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-12</a> 如果遗嘱标志设置为1, 遗嘱QoS等级<strong>可以</strong>被设置为0(0x00), 1(0x01)或2(0x02).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-13</a> 如果遗嘱标志被设置为0, 遗嘱保留标志也<strong>必须</strong>设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-14</a> 如果遗嘱标志被设置为1时, 如果遗嘱保留被设置为0, 则服务端<strong>必须</strong>将遗嘱消息当做非保留消息发布.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-15</a> 如果遗嘱保留被设置为1, 则服务端<strong>必须</strong>将遗嘱消息当做保留消息发布.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-16</a> 如果用户名标志被设置为 0, 有效载荷中<strong>不能</strong>包含用户名字段.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-17</a> 如果用户名标志被设置为 0, 有效载荷中<strong>必须</strong>包含用户名字段.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-18</a> 如果密码标志被设置为 0, 有效载荷中<strong>不能</strong>包含密码字段.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-19</a> 如果密码标志被设置为 1, 有效载荷中<strong>必须</strong>包含密码字段.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-20</a> 如果保持连接值不为0, 且没有任何其它的MQTT控制报文可以发送, 客户端<strong>必须</strong>发送一个<code>PINGREQ</code> 报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-21</a> 如果服务端返回的<code>CONNACK</code>报文中包含服务端保持连接, 客户端<strong>必须</strong>使用此值代替其发送的保持连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-22</a> 如果保持连接的值非零, 并且服务端在1.5倍的保持连接时间内没有收到客户端的MQTT控制报文, 它<strong>必须</strong>断开客户端的网络连接, 并判定网络连接已断开.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-23</a> 如果网络连接关闭时会话过期间隔大于0, 则客户端与服务端<strong>必须</strong>存储会话状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-24</a> 服务端<strong>不能</strong>发送超过最大报文长度的报文给客户端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-25</a> 当报文过大而不能发送时, 服务端<strong>必须</strong>丢弃这些报文, 然后当做应用消息发送已完成处理.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-26</a> 服务端在一个<code>PUBLISH</code>报文中发送的主题别名<strong>不能</strong>超过客户端设置的主题别名最大值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-27</a> 如果主题别名最大值没有设置, 或者设置为零, 则服务端<strong>不能</strong>向此客户端发送任何主题别名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-28</a> 请求响应信息值为0, 表示服务端<strong>不能</strong>返回响应信息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-29</a> 如果请求问题信息的值为0, 服务端可以选择在<code>CONNACK</code>或<code>DISCONNECT</code>报文中返回原因字符串或用户属性, 但<strong>不能</strong>在除<code>PUBLISH</code>, <code>CONNACK</code>或<code>DISCONNECT</code>之外的报文中发送原因字符串或用户属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-30</a> 如果客户端在<code>CONNECT</code>报文中设置了认证方法, 则客户端在收到<code>CONNACK</code>报文之前<strong>不能</strong>发送除<code>AUTH</code>或<code>DISCONNECT</code>之外的报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-1</a> <code>CONNECT</code>报文的载荷中包含由可变报头中的标志确定的一个或多个以长度为前缀的字段.这些字段若存在, <strong>必须</strong>按照客户标识符、遗嘱属性、遗嘱主题、遗嘱载荷、用户名、密码的顺序出现.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-2</a> 客户端和服务端都<strong>必须</strong>使用客户标识符识别两者之间的 MQTT 会话相关的状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-3</a> 客户标识符<strong>必须</strong>存在, 且作为<code>CONNECT</code>报文载荷的第一个字段出现.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-4</a> 客户标识符<strong>必须</strong>被编码为UTF-8字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-5</a> 服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的客户标识符, 客户标识符只能包含这些字符:<code>&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</code><br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-6</a> 服务端<strong>可以</strong>允许客户端提供一个零字节的客户标识符, 如果这样做了, 服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户标识符给那个客户端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-7</a> 服务端<strong>必须</strong>假设客户端提供了那个唯一的客户标识符, 且<strong>必须</strong>在<code>CONNACK</code>报文中返回分配的客户标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-8</a> 如果服务端拒绝了某个客户标识符, 它<strong>可以</strong>发送包含原因码<code>0x85(客户标识符无效)</code>的<code>CONNACK</code>报文作为对客户端的<code>CONNECT</code>报文的回应 , 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>所述.之后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-9</a> 如果某个会话在遗嘱延时间隔到期之前创建了新的网络连接, 则服务端<strong>不能</strong>发送遗嘱消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-10</a> 服务端在发布遗嘱消息时<strong>必须</strong>维护用户属性的顺序.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-11</a> 遗嘱主题<strong>必须</strong>为UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-12</a> 如果用户名标志被设置为1, 用户名为载荷中下一个字段. 用户名<strong>必须</strong>是UTF-8编码字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-1</a> 服务端<strong>必须</strong>按照<a href="https://www.zybuluo.com/khan-lau/note/1325300#31-connect--连接请求" target="_blank" rel="noopener">3.1节</a>的要求验证<code>CONNECT</code>报文, 如果报文不符合规范, 服务端关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-2</a> 服务端<strong>可以</strong>检查<code>CONNECT</code>报文的内容是不是满足任何进一步的限制, <strong>应该</strong>执行身份验证和授权检查. 如果任何一项检查没通过, 服务端<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-3</a> 如果客户标识符所代表的客户端已经连接到此服务端, 那么向原有的客户端发送一个包含原因码为<code>0x8E(会话被接管)</code>的<code>DISCONNECT</code>报文, 并且<strong>必须</strong>关闭原有的网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-4</a> 服务端<strong>必须</strong>对新开始标志进行处理.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-5</a> 服务端<strong>必须</strong>使用包含原因码为<code>0x00(成功)</code>的<code>CONNACK</code>报文对客户端的<code>CONNECT</code>报文进行确认.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-6</a> 如果服务端拒绝了<code>CONNECT</code>报文, 它<strong>不能</strong>处理客户端在<code>CONNECT</code>报文之后发送的任何除<code>AUTH</code>以外的报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#32-connack--确认连接请求" target="_blank" rel="noopener">MQTT-3.2.0-1</a> 服务端在发送任何除<code>AUTH</code>以外的报文之前<strong>必须</strong>先发送包含原因码为<code>0x00(成功)</code>的<code>CONNACK</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#32-connack--确认连接请求" target="_blank" rel="noopener">MQTT-3.2.0-2</a> 服务端在一次网络连接中不能发送多个<code>CONNACK</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-1</a> 第1个字节是连接确认标志, 位7-1是保留位且<strong>必须</strong>设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-2</a> 如果服务端接受一个新开始为1的连接, 服务端在<code>CONNACK</code>报文中除了把原因码设置为<code>0x00(成功)</code>之外, 还<strong>必须</strong>把会话存在标志设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-3</a> 如果服务端接受一个新开始为0的连接, 并且服务端已经保存了此客户标识符的会话状态, 服务端在<code>CONNACK</code>报文中<strong>必须</strong>把会话存在标志设置为1. 否则, 服务端<strong>必须</strong>把会话存在标志设置为0.无论如何, 服务端在<code>CONNACK</code>报文中<strong>必须</strong>把原因码设置为<code>0x00(成功)</code>.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-4</a> 如果客户端没有保存的会话状态, 但收到会话存在标志为1, 客户端<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-5</a> 如果客户端保存了会话状态, 但收到的会话存在标志为0, 客户端若要继续此网络连接, 它<strong>必须</strong>丢弃其保存的会话状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-6</a> 如果服务端发送的<code>CONNACK</code>报文中原因码非0, 它<strong>必须</strong>把会话存在标志设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-7</a> 如果服务端发送了一个包含原因码大于等于128的<code>CONNACK</code>报文, 它随后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-8</a> 服务端发送的<code>CONNACK</code>报文<strong>必须</strong>设置一种原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-9</a> 如果服务端不支持Qos为1或2的<code>PUBLISH</code>报文, 服务端<strong>必须</strong>在<code>CONNACK</code>报文中发送<code>最大服务质量</code>以指定其支持的<code>最大QoS值</code>.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-10</a> 即使不支持QoS为1或2的<code>PUBLISH</code>报文, 服务端也<strong>必须</strong>接受请求QoS为0、1或2的<code>SUBSCRIBE</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-11</a> 如果从服务端接收到了<code>最大QoS等级</code>, 则客户端<strong>不能</strong>发送超过<code>最大QoS等级</code>所指定的QoS等级的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-12</a> 如果服务端收到包含遗嘱的QoS超过服务端处理能力的<code>CONNECT</code>报文, 服务端<strong>必须</strong>拒绝此连接. 服务端<strong>应该</strong>使用包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>CONNACK</code>报文进行错误处理, 随后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-13</a> 如果服务端收到一个包含保留标志位1的遗嘱消息的<code>CONNECT</code>报文且服务端不支持保留消息, 服务端<strong>必须</strong>拒绝此连接请求, 且<strong>应该</strong>发送包含原因码为<code>0x9A(不支持保留)</code>的<code>CONNACK</code>报文, 随后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-14</a> 从服务端接收到的保留可用标志为0时, 客户端<strong>不能</strong>发送保留标志设置为1的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-15</a> 客户端不应该发送超过最大报文长度的报文给服务端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-16</a> 如果客户端使用长度为0的客户标识符, 服务端<strong>必须</strong>回复包含分配客户标识符的<code>CONNACK</code>报文. 分配客户标识符<strong>必须</strong>是没有被服务端的其他会话所使用的新客户标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-17</a> 客户端在一个<code>PUBLISH</code>报文中发送的主题别名值<strong>不能</strong>超过服务端设置的主题别名最大值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-18</a> 如果主题别名最大值没有设置, 或者设置为0, 则客户端<strong>不能</strong>向此服务端发送任何主题别名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-19</a> 如果加上原因字符串之后的<code>CONNACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-20</a> 如果加上用户属性之后的<code>CONNACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-21</a> 如果服务端发送了服务端保持连接属性, 客户端<strong>必须</strong>使用此值代替其在<code>CONNECT</code>报文中发送的保持连接时间值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-22</a> 如果服务端没有发送服务端保持连接属性, 服务端<strong>必须</strong>使用客户端在<code>CONNECT</code>报文中设置的保持连接时间值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-1</a> 客户端或服务端请求重发一个<code>PUBLISH</code>报文时, <strong>必须</strong>将<code>DUP标志</code>设置为1.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-2</a> 对于QoS为0的消息, DUP标志<strong>必须</strong>设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-3</a> 发送(出站)的<code>PUBLISH</code>报文与收到(入站)的<code>PUBLISH</code>报文中的<code>DUP标志</code>是独立设置的, 它的值<strong>必须</strong>单独的根据发送(出站)的<code>PUBLISH</code>报文是否是一个重发来确定.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-4</a> <code>PUBLISH</code>报文的2个QoS比特位<strong>不能</strong>同时设置为1.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-5</a> 如果客户端发给服务端的<code>PUBLISH</code>报文的保留标志被设置为1, 服务端<strong>必须</strong>存储此应用消息, 并用其替换此话题下任何已存在的消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-6</a> 如果载荷为空, 消息<strong>可以</strong>正常被服务端所处理, 但是此话题下的任何保留消息<strong>必须</strong>被丢弃, 并且此话题未来的订阅者将<strong>不会</strong>收到保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-7</a> 载荷为空的保留消息将<strong>不能</strong>被存储在服务端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-8</a> 如果客户端发给服务端的<code>PUBLISH</code>报文的保留标志位为0, 服务器<strong>不能</strong>把此消息存储为保留消息, 也<strong>不能</strong>丢弃或替换任何已存在的保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-9</a> 如果保留消息处理属性被设置为0, 服务端<strong>必须</strong>发送主题与客户端订阅的主题过滤器相匹配的所有保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-10</a> 如果保留消息处理属性被设置为1, 如果尚不存在匹配的订阅, 服务端<strong>必须</strong>发送主题与客户端订阅的主题过滤器相匹配的所有保留消息.如果已存在相匹配的订阅, 服务器<strong>不能</strong>发送这些保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-11</a> 如果保留消息处理属性被设置为2, 服务器<strong>不能</strong>发送这些保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-12</a> 如果发布保留订阅选项被设置为0, 服务端在转发应用消息时<strong>必须</strong>将保留标志设置为0, 而不管收到的<code>PUBLISH</code>报文中保留标志位如何设置的.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-13</a> 如果发布保留订阅选项被设置为1, 服务端在转发应用消息时<strong>必须</strong>将保留标志设置为与收到的<code>PUBLISH</code>消息中的保留标志位相同.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-1</a> 主题名<strong>必须</strong>是<code>PUBLISH</code>报文可变报头的第一个字段. 它必须是UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-2</a> <code>PUBLISH</code>报文中的主题名<strong>不能</strong>包含通配符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-3</a> 服务端发送给订阅客户端的<code>PUBLISH</code>报文中的主题名<strong>必须</strong>匹配该订阅的主题过滤器.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-4</a> 服务端<strong>必须</strong>把接收到的应用消息中的载荷格式指示原封不动的发给所有的订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-5</a> 如果消息过期间隔已过期, 服务端还没开始向匹配的订阅者交付该消息, 则服务端<strong>必须</strong>删除该订阅者的消息副本.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-6</a> 服务端发送给客户端的<code>PUBLISH</code>报文中<strong>必须</strong>包含消息过期间隔, 值为接收时间减去消息在服务端的等待时间.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-7</a> 接收端<strong>不能</strong>将任何主题别名映射从一个网络连接转发到另一个网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-8</a> 发送端<strong>不能</strong>发送包含主题别名值为0的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-9</a> 客户端<strong>不能</strong>发送主题别名值大于服务端的<code>CONNACK</code>报文中指定的主题别名最大值的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-10</a> 客户端<strong>必须</strong>接受所有值大于0且小于等于其发送的<code>CONNECT</code>报文中的主题别名最大值的主题别名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-11</a> 服务端<strong>不能</strong>发送包含主题别名值大于客户端在<code>CONNECT</code>报文中指定的主题别名最大值的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-12</a> 服务端<strong>必须</strong>接受所有值大于0且小于等于其发送的<code>CONNACK</code>报文中的主题别名最大值的主题别名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-13</a> 响应主题<strong>必须</strong>是UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-14</a> 响应主题<strong>不能</strong>包含通配符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-15</a> 服务端在收到应用消息时<strong>必须</strong>将响应主题原封不动的发送给所有的订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-16</a> 服务端在收到应用消息时<strong>必须</strong>原封不动的把对比数据发送给所有的订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-17</a> 服务端在转发应用消息到客户端时<strong>必须</strong>原封不动的把所有的用户属性放在<code>PUBLISH</code>报文中.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-18</a> 服务端在转发应用消息时<strong>必须</strong>保持所有用户属性的先后顺序.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-19</a> 内容类型<strong>必须</strong>是UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-20</a> 服务端<strong>必须</strong>把收到的应用消息中的内容类型原封不动的发送给所有的订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-1</a> <code>PUBLISH</code>报文的接收端<strong>必须</strong>按照<code>PUBLISH</code>报文中的 <code>QoS等级</code> 发送响应报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-2</a> 这种情况下, 服务端<strong>必须</strong>按照所有匹配的订阅中最大的<code>QoS等级</code>把消息发送给客户端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-3</a> 如果客户端在这些重叠的订阅中指定了订阅标识符, 服务端在发布这些订阅相匹配的消息时<strong>必须</strong>包含这些订阅标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-4</a> 如果服务端对这些重叠的订阅只发送一条相匹配的消息, 服务端<strong>必须</strong>在<code>PUBLISH</code>报文中包含所有的相匹配的订阅标识符(如果存在), 但没有顺序要求.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-5</a> 如果服务端对这些重叠的订阅<strong>必须</strong>分别发送相匹配的消息, 则每个<code>PUBLISH</code>报文中包含与订阅相匹配的订阅标识符(如果存在).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-6</a> 从客户端发送给服务端的<code>PUBLISH</code>报文<strong>不能</strong>包含订阅标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-7</a> 客户端在收到服务端的<code>PUBACK</code>, <code>PUBCOMP</code>或包含原因码大于等于128的<code>PUBREC</code>报文之前, <strong>不能</strong>发送数量超过服务端的接收最大值的QoS为1和2的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-8</a> 客户端<strong>不能</strong>延迟发送任何报文, 除了<code>PUBLISH</code>报文–如果已发送且没有收到确认的<code>PUBLISH</code>报文数量已达到服务端的接收最大值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-9</a> 服务端在接收到客户端的<code>PUBACK</code>, <code>PUBCOMP</code>或包含原因码大于等于128的<code>PUBREC</code>报文之前, <strong>不能</strong>发送数量超过客户端的接收最大值的QoS为1和2的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-10</a> 服务端<strong>不能</strong>延迟发送任何报文, 除了<code>PUBLISH</code>报文–如果已发送且没有收到确认的<code>PUBLISH</code>报文数量已到达客户端的接收最大值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#342-puback可变报头" target="_blank" rel="noopener">MQTT-3.4.2-1</a> 服务端或客户端发送<code>PUBACK</code>报文时<strong>必须</strong>设置其中一种<code>PUBACK</code>原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#342-puback可变报头" target="_blank" rel="noopener">MQTT-3.4.2-2</a> 如果加上原因字符串之后的<code>PUBACK</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#342-puback可变报头" target="_blank" rel="noopener">MQTT-3.4.2-3</a> 如果加上用户属性之后的<code>PUBACK</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#352-pubrec可变报头" target="_blank" rel="noopener">MQTT-3.5.2-1</a> 服务端或客户端发送<code>PUBREC</code>报文时<strong>必须</strong>设置其中一种原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#352-pubrec可变报头" target="_blank" rel="noopener">MQTT-3.5.2-2</a> 发送端使用此值向接收端提供附加信息. 如果加上原因字符串之后的<code>PUBREC</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#352-pubrec可变报头" target="_blank" rel="noopener">MQTT-3.5.2-3</a> 如果加上用户属性之后的<code>PUBREC</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#361-pubrel固定报头" target="_blank" rel="noopener">MQTT-3.6.1-1</a> <code>PUBREL</code>固定报头的第3, 2, 1, 0位是保留位, 必须被设置为0, 0, 1, 0. 服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#362-pubrel可变报头" target="_blank" rel="noopener">MQTT-3.6.2-1</a> 客户端或服务端发送<code>PUBREL</code>报文时<strong>必须</strong>设置其中一种<code>PUBREL</code>原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#362-pubrel可变报头" target="_blank" rel="noopener">MQTT-3.6.2-2</a> 如果加上原因字符串之后的<code>PUBREL</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#362-pubrel可变报头" target="_blank" rel="noopener">MQTT-3.6.2-3</a> 如果加上用户属性之后的<code>PUBREL</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#372-pubcomp可变报头" target="_blank" rel="noopener">MQTT-3.7.2-1</a> 服务端或客户端发送<code>PUBCOMP</code>报文时<strong>必须</strong>设置一种<code>PUBCOMP</code>原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#372-pubcomp可变报头" target="_blank" rel="noopener">MQTT-3.7.2-2</a> 如果加上原因字符串之后的<code>PUBCOMP</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#372-pubcomp可变报头" target="_blank" rel="noopener">MQTT-3.7.2-3</a> 如果加上用户属性之后的<code>PUBCOMP</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#381-subscribe固定报头" target="_blank" rel="noopener">MQTT-3.8.1-1</a> <code>SUBSCRIBE</code>报文固定报头第3, 2, 1, 0比特位是保留位, 必须被设置为0, 0, 1, 0. 服务端<strong>必须</strong>将其他的任何值都当做是不合法的并关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-1</a> <code>主题过滤器</code> <strong>必须</strong>为UTF-8 编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-2</a> 载荷<strong>必须</strong>包含至少一个<code>主题过滤器</code>/<code>订阅选项</code>对.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-3</a> 订阅选项的第2比特表示非本地选项.值为1, 表示应用消息<strong>不能</strong>被转发给发布此消息的客户标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-4</a> 共享订阅时把非本地选项设为1将造成协议错误.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-5</a> 订阅选项的第6和7比特为将来所保留. 服务端<strong>必须</strong>把此保留位非0的<code>SUBSCRIBE</code>报文当做无效报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-1</a> 当服务端收到来自客户端的<code>SUBSCRIBE</code>报文时, <strong>必须</strong>使用<code>SUBACK</code>报文作为相应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-2</a> <code>SUBACK</code>报文<strong>必须</strong>和待确认的<code>SUBSCRIBE</code>报文有相同的报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-3</a> 如果服务端收到的<code>SUBSCRIBE</code>报文中的一个主题过滤器与当前会话的一个非共享订阅相同, 那么<strong>必须</strong>使用新的订阅替换现存的订阅.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-4</a> 如果保留处理选项为0, 任何匹配该<code>主题过滤器</code>的保留消息必须被重发, 但替换订阅<strong>不能</strong>造成应用消息的丢失.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-5</a> 如果服务端收到的<code>SUBSCRIBE</code>报文包含多个主题过滤器, 服务端<strong>必须</strong>当做收到一系列多个<code>SUBSCRIBE</code>报文来处理–除了将它们的响应组合为单个<code>SUBACK</code>响应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-6</a> 服务端发送给客户端的<code>SUBACK</code>报文<strong>必须</strong>为每一个<code>主题过滤器</code>/<code>订阅选项</code>对包含一个原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-7</a> 此原因码<strong>必须</strong>说明为该订阅授予的<code>最大QoS等级</code>, 或指示订阅失败.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-8</a> 响应该订阅的应用消息<code>QoS等级</code> <strong>必须</strong>为该消息发布时的<code>QoS等级</code>和服务端授予的<code>最大QoS等级</code>二者最小值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#392-suback可变报头" target="_blank" rel="noopener">MQTT-3.9.2-1</a> 如果加上原因字符串之后的<code>SUBACK报文</code>长度超出了客户端指定的<code>最大报文长度</code>, 则服务端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#392-suback可变报头" target="_blank" rel="noopener">MQTT-3.9.2-2</a> 如果加上用户属性之后的<code>SUBACK</code>报文长度超出了客户端指定的<code>最大报文长度</code>, 则服务端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#393-suback载荷" target="_blank" rel="noopener">MQTT-3.9.3-1</a> <code>SUBACK</code>报文中的原因码顺序<strong>必须</strong>与<code>SUBSCRIBE</code>报文中的<code>主题过滤器</code>顺序相匹配.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#393-suback载荷" target="_blank" rel="noopener">MQTT-3.9.3-2</a> 服务端发送<code>SUBACK报文</code>时<strong>必须</strong>对收到的每一个<code>主题过滤器</code>设置一种原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3101-unsubscribe固定报头" target="_blank" rel="noopener">MQTT-3.10.1-1</a> <code>UNSUBSCRIBE</code>固定报头的第3, 2, 1, 0位是保留位且<strong>必须</strong>分别设置为0, 0, 1, 0. 服务端<strong>必须</strong>认为任何其它的值都是不合法的并关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3103-unsubscribe载荷" target="_blank" rel="noopener">MQTT-3.10.3-1</a> <code>UNSUBSCRIBE</code>报文中的主题过滤器<strong>必须</strong>为UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3103-unsubscribe载荷" target="_blank" rel="noopener">MQTT-3.10.3-2</a> <code>UNSUBSCRIBE</code>报文有效载荷<strong>必须</strong>包含至少一个主题过滤器.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-1</a> 服务端<strong>必须</strong>对客户端的<code>UNSUBSCRIBE</code>报文中提供的主题过滤器(不管是否包含通配符)逐个字符与当前持有的主题过滤器集进行比较. 如果任何过滤器完全匹配, 则<strong>必须</strong>删除其拥有的订阅.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-2</a> 当服务端收到<code>UNSUBSCRIBE</code>报文, 它<strong>必须</strong>停止添加为了交付给客户端的与主题过滤器相匹配的任何新消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-3</a> 当服务端收到<code>UNSUBSCRIBE</code>报文, 它<strong>必须</strong>完成任何已经开始发送给客户端的、与主题过滤器相匹配的、<code>QoS等级</code>为1或2的消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-4</a> 服务端<strong>必须</strong>发送<code>UNSUBACK</code>报文以响应客户端的<code>UNSUBSCRIBE</code>请求.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-5</a> <code>UNSUBACK</code>报文<strong>必须</strong>包含和<code>UNSUBSCRIBE</code>报文相同的报文标识符. 即使没有删除任何主题订阅, 服务端也<strong>必须</strong>发送一个<code>UNSUBACK</code>响应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-6</a> 如果服务端收到的<code>UNSUBSCRIBE</code>报文包含多个主题过滤器, 服务端<strong>必须</strong>当做收到一系列多个<code>UNSUBSCRIBE</code>报文来处理–除了将它们的响应组合为单个<code>SUBACK</code>响应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3112-unsuback可变报头" target="_blank" rel="noopener">MQTT-3.11.2-1</a> 如果加上原因字符串之后的<code>UNSUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3112-unsuback可变报头" target="_blank" rel="noopener">MQTT-3.11.2-2</a> 如果加上用户属性之后的<code>UNSUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3113-unsuback载荷" target="_blank" rel="noopener">MQTT-3.11.3-1</a> <code>UNSUBACK</code>报文中的原因码顺序<strong>必须</strong>与<code>UNSUBSCRIBE</code>报文中的主题过滤器顺序相匹配.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3113-unsuback载荷" target="_blank" rel="noopener">MQTT-3.11.3-2</a> 服务端发送<code>UNSUBACK</code>报文时对于每个收到的主题过滤器, <strong>必须</strong>使用一个取消订阅原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3124-pingreq行为" target="_blank" rel="noopener">MQTT-3.12.4-1</a> 服务端<strong>必须</strong>发送<code>PINGRESP</code>报文响应客户端的<code>PINGREQ</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-disconnect--断开通知" target="_blank" rel="noopener">MQTT-3.14.0-1</a> 服务端<strong>不能</strong>发送<code>DISCONNECT</code>报文, 直到它发送了包含原因码小于0x80的<code>CONNACK</code>报文之后.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3141-disconnect固定报头" target="_blank" rel="noopener">MQTT-3.14.1-1</a> 服务端或客户端<strong>必须</strong>验证所有的保留位都被设置为0, 如果他们不为0, 发送包含原因码为<code>0x81(无效报文)</code>的<code>DISCONNECT</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3142-disconnect可变报头" target="_blank" rel="noopener">MQTT-3.14.2-1</a> 客户端或服务端发送<code>DISCONNECT</code>报文时<strong>必须</strong>使用一种<code>DISCONNECT</code>原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3142-disconnect可变报头" target="_blank" rel="noopener">MQTT-3.14.2-2</a> 会话过期间隔<strong>不能</strong>由服务端的<code>DISCONNECT</code>报文发送.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3142-disconnect可变报头" target="_blank" rel="noopener">MQTT-3.14.2-3</a> 如果此属性使得<code>DISCONNECT</code>报文的长度超出了接收端指定的<code>最大报文长度</code>, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3142-disconnect可变报头" target="_blank" rel="noopener">MQTT-3.14.2-4</a> 如果加上用户属性之后的<code>DISCONNECT</code>报文长度超出了接收端指定的<code>最大报文长度</code>, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3144-disconnect行为" target="_blank" rel="noopener">MQTT-3.14.4-1</a> 发送端发送完<code>DISCONNECT</code>报文之后<strong>不能</strong>再在此网络连接上发送任何MQTT控制报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3144-disconnect行为" target="_blank" rel="noopener">MQTT-3.14.4-2</a> 发送端发送完<code>DISCONNECT</code>报文之后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3144-disconnect行为" target="_blank" rel="noopener">MQTT-3.14.4-3</a> 接收到包含原因码为<code>0x00(成功)</code>的<code>DISCONNECT</code>时, 服务端<strong>必须</strong>丢弃任何与当前连接相关的<code>遗嘱消息</code>, 而不发布它.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3151-auth固定报头" target="_blank" rel="noopener">MQTT-3.15.1-1</a> <code>AUTH</code>报文固定报头第3, 2, 1, 0位是保留位, <strong>必须</strong>全设置为0. 客户端或服务端<strong>必须</strong>把其他值当做无效值并关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3152-auth可变报头" target="_blank" rel="noopener">MQTT-3.15.2-1</a> <code>AUTH</code>报文的发送端<strong>必须</strong>使用一种认证原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3152-auth可变报头" target="_blank" rel="noopener">MQTT-3.15.2-2</a> 如果加上原因字符串之后的<code>AUTH</code>报文长度超出了接收端所指定的<code>最大报文长度</code>, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3152-auth可变报头" target="_blank" rel="noopener">MQTT-3.15.2-3</a> 如果加上用户属性之后的<code>AUTH</code>报文长度超出了接收端指定的<code>最大报文长度</code>, 则服务端<strong>不能</strong>发送此属性.<br><a href="[MQTT-4.1.0-2](https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态">MQTT-4.1.0-1</a> 当网络连接被关闭并且会话过期间隔已过时, 服务端必须丢弃会话状态.) 当网络连接打开时, 客户端和服务端<strong>不能</strong>丢弃会话状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">MQTT-4.1.0-2</a> 当网络连接被关闭并且会话过期间隔已过时, 服务端<strong>必须</strong>丢弃会话状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#42-网络连接" target="_blank" rel="noopener">MQTT-4.2.0-1</a> 客户端或服务端<strong>必须</strong>支持使用一个或多个提供有序的、可靠的、双向传输(从客户端到服务端和从服务端到客户端)字节流传输的底层传输协议.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#431-qos-0最多分发一次" target="_blank" rel="noopener">MQTT-4.3.1-1</a> 对于<code>QoS等级0</code>的分发协议, 发送端<strong>必须</strong>发送QoS等于0, DUP等于0的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-1</a> 对于<code>QoS等级1</code>的分发协议, 发送端每次发送新的应用消息都<strong>必须</strong>分配一个未使用的用户标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-2</a> 对于<code>QoS等级1</code>的分发协议, 发送端发送的<code>PUBLISH</code>报文<strong>必须</strong>包含报文标识符且QoS等于1, DUP等于0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-3</a> 对于<code>QoS等级1</code>的分发协议, 发送端<strong>必须</strong>将这个<code>PUBLISH</code>报文看作是未确认的, 直到从接收端那收到对应的<code>PUBACK</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-4</a> 对于QoS等级1的分发协议, 接收端响应的<code>PUBACK</code>报文<strong>必须</strong>包含一个报文标识符, 这个标识符来自接收到的、已经接受所有权的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-5</a> 对于<code>QoS等级1</code>的分发协议, 接收端发送了<code>PUBACK</code>报文之后, 接收端<strong>必须</strong>将任何包含相同报文标识符的入站<code>PUBLISH</code>报文当做一个新的消息, 并忽略它的<code>DUP标志</code>的值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-1</a> 对于<code>QoS等级2</code>的分发协议, 发送端<strong>必须</strong>给要发送的新应用消息分配一个未使用的报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-2</a> 对于<code>QoS等级2</code>的分发协议, 发送端<code>PUBLISH</code>报文<strong>必须</strong>包含报文标识符且报文的QoS等于2, DUP等于0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-3</a> 对于<code>QoS等级2</code>的分发协议, 发送端<strong>必须</strong>将这个<code>PUBLISH</code>报文看作是未确认的, 直到从接收端那收到对应的<code>PUBREC</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-4</a> 对于<code>QoS等级2</code>的分发协议, 收到发送端发送的包含原因码小于0x80的<code>PUBREC</code>报文后<strong>必须</strong>发送一个<code>PUBREL</code>报文. <code>PUBREL</code>报文<strong>必须</strong>包含与原始<code>PUBLISH</code>报文相同的报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-5</a> 对于<code>QoS等级2</code>的分发协议, 发送端<strong>必须</strong>将这个<code>PUBREL</code>报文看作是未确认的 , 直到从接收端那收到对应的<code>PUBCOMP</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-6</a> 对于<code>QoS等级2</code>的分发协议, 发送端一旦发送了对应的<code>PUBREL</code>报文就<strong>不能</strong>重发这个<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-7</a> 对于<code>QoS等级2</code>的分发协议, 如果<code>PUBLISH</code>报文已发送, <strong>不能</strong>应用消息过期属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-8</a> 对于<code>QoS等级2</code>的分发协议, 接收端响应的<code>PUBREC</code>报文<strong>必须</strong>包含报文标识符, 这个标识符来自接收到的、已经接受所有权的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-9</a> 对于<code>QoS等级2</code>的分发协议, 如果接收端发送了包含原因码大于等于0x80的<code>PUBREC</code>报文, 它<strong>必须</strong>将后续包含相同报文标识符的<code>PUBLISH</code>报文当做是新的应用消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-10</a> 对于<code>QoS等级2</code>的分发协议, 接收端在收到对应的<code>PUBREL</code>报文之前, 接收端<strong>必须</strong>发送<code>PUBREC</code>报文确认任何后续的具有相同报文标识符的<code>PUBLISH</code>报文. 在这种情况下, 它<strong>不能</strong>重复分发消息给任何后续的接收者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-11</a> 对于<code>QoS等级2</code>的分发协议, 接收端<strong>必须</strong>发送包含与<code>PUBREL</code>相同报文标识符的<code>PUBCOMP</code>报文作为对<code>PUBREL</code>报文的响应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-12</a> 对于<code>QoS等级2</code>的分发协议, 接收端发送<code>PUBCOMP</code>报文之后, <strong>必须</strong>将后续包含相同报文标识符的<code>PUBLISH</code>报文当做是新的应用消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-13</a> 对于<code>QoS等级2</code>的分发协议, 接收端<strong>必须</strong>继续<code>QoS等级2</code>确认序列, 即使它已经应用了消息过期属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#44-消息分发重试" target="_blank" rel="noopener">MQTT-4.4.0-1</a> 客户端以新开始标志为0且会话存在的情况下重连时, 客户端和服务端都<strong>必须</strong>使用原始报文标识符重新发送任何未被确认的<code>PUBLISH</code>报文(当QoS &gt; 0)和<code>PUBREL</code>报文. 这是唯一要求客户端或服务端重发消息的情况. 客户端和服务端<strong>不能</strong>在其他任何时间重发消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#44-消息分发重试" target="_blank" rel="noopener">MQTT-4.4.0-2</a> 如果收到包含原因码大于等于0x80的<code>PUBACK</code>或<code>PUBREC</code>, 则对应的<code>PUBLISH</code>报文被看作已确认, 且<strong>不能</strong>被重传.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#45-消息收到" target="_blank" rel="noopener">MQTT-4.5.0-1</a> 当服务端接受入站应用消息的所有权时, 它<strong>必须</strong>将消息添加到订阅匹配的客户端的会话状态中.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#45-消息收到" target="_blank" rel="noopener">MQTT-4.5.0-2</a> 客户端<strong>必须</strong>按照可用的<code>服务质量(QoS)</code>规则确认它收到的任何<code>PUBLISH</code>报文, 不管它是否选择处理其包含的应用消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-1</a> 重发任何之前的<code>PUBLISH</code>报文时, 客户端<strong>必须</strong>按原始<code>PUBLISH</code>报文的发送顺序重发(适用于<code>QoS等级1</code>和<code>QoS等级2</code> 消息).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-2</a> 客户端<strong>必须</strong>按照对应的<code>PUBLISH</code>报文的顺序发送<code>PUBACK报文</code>(<code>QoS等级1</code>消息).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-3</a> 客户端<strong>必须</strong>按照对应的<code>PUBLISH</code>报文的顺序发送<code>PUBREC</code>报文(<code>QoS等级2</code>消息).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-4</a> 客户端<strong>必须</strong>按照对应的<code>PUBREC</code>报文的顺序发送<code>PUBREL</code>报文(<code>QoS等级2</code>消息).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-5</a> 当服务端处理发布到有序主题的消息时, 它<strong>必须</strong>按照消息从任何给定客户端接收的顺序发送<code>PUBLISH</code>报文给消费端(对于同一主题和QoS等级).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-6</a> 默认情况下, 服务端转发非共享订阅的消息时, <strong>必须</strong>将每个主题都视为有序主题.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">MQTT-4.7.0-1</a> 主题过滤器中可以使用通配符, 但是主题名<strong>不能</strong>使用通配符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#471-主题通配符" target="_blank" rel="noopener">MQTT-4.7.1-1</a> 多层通配符<strong>必须</strong>单独指定, 或者跟在主题层级分隔符后面. 不管哪种情况, 它都<strong>必须</strong>是主题过滤器的最后一个字符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#471-主题通配符" target="_blank" rel="noopener">MQTT-4.7.1-2</a> 在主题过滤器的任意层级都可以使用单层通配符, 包括第一个和最后一个层级. 在使用它时, 它<strong>必须</strong>占据过滤器的整个层级.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#472--以开头的主题" target="_blank" rel="noopener">MQTT-4.7.2-1</a> 服务端<strong>不能</strong>将<code>$</code>字符开头的主题名匹配通配符(<code>#</code>或<code>+</code>)开头的主题过滤器.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#473-主题语义和用法" target="_blank" rel="noopener">MQTT-4.7.3-1</a> 所有的主题名和主题过滤器<strong>必须</strong>至少包含一个字符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#473-主题语义和用法" target="_blank" rel="noopener">MQTT-4.7.3-2</a> 主题名和主题过滤器<strong>不能</strong>包含空字符(Unicode U+0000).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#473-主题语义和用法" target="_blank" rel="noopener">MQTT-4.7.3-3</a> 主题名和主题过滤器是UTF-8编码字符串, 它们<strong>不能</strong>超过65,535字节.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#473-主题语义和用法" target="_blank" rel="noopener">MQTT-4.7.3-4</a> 匹配订阅时, 服务端<strong>不能</strong>对主题名或主题过滤器执行任何规范化处理, <strong>不能</strong>修改或替换任何未识别的字符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-1</a> 共享订阅主题过滤器必须以<code>&quot;$share/&quot;</code>开始, 且<strong>必须</strong>包含至少一个字符长度的共享名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-2</a> 共享名<strong>不能</strong>包含字符<code>&quot;/&quot;</code>, <code>&quot;+&quot;</code>或<code>&quot;#&quot;</code>, 但<strong>必须</strong>跟在<code>&quot;/&quot;</code>字符后面. 此<code>&quot;/&quot;</code>字符后面<strong>必须</strong>跟随一个主题过滤器.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-3</a> 向客户端发送应用消息时, 服务端<strong>必须</strong>考虑授予客户端的QoS等级.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-4</a> 服务端<strong>必须</strong>在客户端重新连接时完成向该客户端的消息分发.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-5</a> 如果客户端的会话在客户端重连之前终止, 服务端<strong>不能</strong>把此消息发送给其他订阅的客户端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-6</a> 如果客户端对来自服务端的<code>PUBLISH</code>报文使用包含原因码大于等于0x80的<code>PUBACK</code>或<code>PUBREC</code>报文进行响应, 服务端<strong>必须</strong>丢弃应用消息而不尝试将其发送给任何其他订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">MQTT-4.9.0-1</a> 客户端或服务端<strong>必须</strong>将其初始发送配额设置为不超过接收最大值的非0值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">MQTT-4.9.0-2</a> 每当客户端或服务端发送了一个QoS等级大于0的<code>PUBLISH</code>报文, 它就会减少发送配额. 如果发送配额减为0, 客户端或服务端<strong>不能</strong>再发送任何QoS等级大于0的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">MQTT-4.9.0-3</a> 它<strong>可以</strong>继续发送QoS为0的<code>PUBLISH</code>报文, 也<strong>可以</strong>选择暂停发送这些报文. 即使配额为0, 客户端和服务端也<strong>必须</strong>继续处理和响应其他MQTT控制报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-1</a> 如果服务端不支持客户端提供的认证方法, 它<strong>可以</strong>发送一个包含原因码<code>0x8C(无效的认证方法)</code>或<code>0x87(未授权)</code>的<code>CONNACK</code>报文, 并且<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-2</a> 如果服务端需要额外的信息来完成认证, 它可以向客户端发送<code>AUTH</code>报文, 此报文<strong>必须</strong>包含原因码<code>0x18(继续认证)</code>.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-3</a> 客户端通过发送另一个<code>AUTH</code>报文响应来自服务端的<code>AUTH</code>报文, 此报文<strong>必须</strong>包含原因码<code>0x18(继续认证)</code>.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-4</a> 服务端可以在处理过程中随时拒绝认证. 它<strong>可以</strong>发送包含原因码大于等于0x80的<code>CONNACK</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>所述, 并且<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-5</a> 如果初始<code>CONNECT</code>报文包含认证方法属性, 则所有的<code>AUTH</code>报文和成功的<code>CONNACK</code>报文<strong>必须</strong>包含与<code>CONNECT</code>报文中相同的认证方法属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-6</a> 如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 则服务端<strong>不能</strong>发送<code>AUTH</code>报文, 且<strong>不能</strong>在<code>CONNACK</code>报文中发送认证方法.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-7</a> 如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 则客户端<strong>不能</strong>向服务端发送<code>AUTH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#4121-重新认证" target="_blank" rel="noopener">MQTT-4.12.1-1</a> 如果客户端在<code>CONNECT</code>报文中提供了认证方法, 它<strong>可以</strong>在收到<code>CONNACK</code>报文之后的任何时间通过发送包含原因码<code>0x19(重新认证)</code>的<code>AUTH</code>报文发起重新认证. 客户端<strong>必须</strong>将认证方法设置为与最初验证网络连接时的认证方法一致.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#4121-重新认证" target="_blank" rel="noopener">MQTT-4.12.1-2</a> 如果重新认证失败, 客户端或服务端<strong>应该</strong>发送包含适当原因码的<code>DISCONNECT</code>报文, 如 section <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 并且<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#4131-无效报文和协议错误" target="_blank" rel="noopener">MQTT-4.13.1-1</a> 当服务端检测到无效报文或协议错误, 并且本规范中给出了相应的原因码时, 它<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#4132-其他错误" target="_blank" rel="noopener">MQTT-4.13.2-1</a> <code>CONNACK</code>报文和<code>DISCONNECT</code>报文允许使用大于等于0x80的原因码以指示网络连接将被关闭. 如果某个大于等于0x80的原因码被指定, 无论是否发送<code>CONNACK</code>报文或<code>DISCONNECT</code>报文, <strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">MQTT-6.0.0-1</a> MQTT控制报文<strong>必须</strong>使用WebSocket二进制数据帧发送. 如果收到任何其它类型的数据帧, 接收者<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">MQTT-6.0.0-2</a> 单个WebSocket数据帧<strong>可以</strong>包含多个或者部分MQTT报文. 接收者<strong>不能</strong>假设MQTT控制报文按WebSocket帧边界对齐.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">MQTT-6.0.0-3</a> 客户端<strong>必须</strong>将字符串”mqtt”包含在它提供的WebSocket子协议列表里.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">MQTT-6.0.0-4</a> 服务端选择和返回的WebSocket子协议名<strong>必须</strong>是”mqtt”.</p><h2 id="Appendix-C-MQTT-v5-0新特性总结-非规范"><a href="#Appendix-C-MQTT-v5-0新特性总结-非规范" class="headerlink" title="Appendix C. MQTT v5.0新特性总结(非规范)"></a>Appendix C. MQTT v5.0新特性总结(非规范)</h2><p>MQTT v5.0添加了以下特性</p><ul><li>会话过期<br>把<code>清理会话标志</code>拆分成<code>新开始标志(指示会话应该在不使用现有会话的情况下开始)</code>和<code>会话过期间隔标志(指示连接断开之后会话保留的时间)</code>.<code>会话过期间隔时间</code>可以在断开时修改. 把<code>新开始标志</code>设置为1且<code>会话过期间隔标志</code>设置为0, 等同于在MQTT v3.1.1中把<code>清理会话(CleanSession)</code>设置为1.</li><li>消息过期<br>允许消息在发布时设置一个<code>过期间隔</code>.</li><li>所有确认报文原因码<br>更改所有响应报文以包含原因码, 包括<code>CONNACK</code>, <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBACK</code>, <code>UNSUBACK</code>, <code>DISCONNECT</code>和<code>AUTH</code>, 以使得调用方确定请求的函数是否成功.</li><li>所有确认报文原因字符串<br>更改大部分报文以包含原因码同时也允许一个可选的<code>原因字符串</code>.这是为问题定位而设计的, 并且不应由接收端所解析.</li><li>服务端断开<br>允许服务端发送<code>DISCONNECT</code>报文, 以指示连接被关闭的原因.</li><li>载荷格式和内容类型<br>允许在消息发布时指定载荷格式(二进制、文本)和<code>MIME样式内容类型</code>.这些信息被转发到消息的接收端.</li><li>请求/响应<br>规定MQTT请求/响应模式, 提供响应主题和对比数据属性, 以使得响应消息被路由回请求的发布者. 此外, 为客户端添加从服务端获取获取关于构造响应主题的配置信息的能力.</li><li>共享订阅<br>添加对<code>共享订阅</code>的支持, 以允许多个订阅消费者进行负载均衡.</li><li>订阅标识符<br>允许在<code>SUBSCRIBE</code>报文中指定一个数字订阅标识符, 并在消息分发时返回此标识符. 这使得客户端收到分发的消息时确定此消息是由哪个或哪些订阅导致的.</li><li>主题别名<br>通过将<code>主题名</code>缩写为<code>小整数</code>来减小MQTT报文的开销大小. 客户端和服务端分别指定它们允许的主题别名的数量.</li><li>流量控制<br>允许客户端和服务端分别指定未完成的可靠消息(QoS&gt;0)的数量.发送端可以暂停发送此类消息以保持消息数量低于配额.这被用于限制<code>可靠消息</code>的速率和某一时刻的传输中(in-flight)消息数量.</li><li>用户属性<br>为大多数报文添加用户属性.PUBLISH报文的用户属性由客户端应用程序定义.PUBLISH报文和遗嘱报文的用户属性由服务端转发给应用消息的接收端.<code>CONNECT</code>, <code>SUBSCRIBE</code>和<code>UNSUBSCRIBE</code>报文的用户属性由服务端实现定义. <code>CONNACK</code>, <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBACK</code>, <code>UNSUBACK</code>和<code>AUTH</code>报文的用户属性由发送端定义, 且对发送端具有唯一性. MQTT规范不定义用户属性的意义.</li><li>最大报文长度<br>允许客户端和服务端各自指定它们支持的<code>最大报文长度</code>.会话参与方发送更大的报文将造成错误.</li><li>可选的服务端功能可用性<br>提供定义一组服务端不允许的功能, 并告知客户端的机制.可以使用这种方式指定的功能包括:<code>最大QoS等级</code>, <code>保留可用</code>, <code>通配符订阅可用</code>, <code>订阅标识符可用</code>和<code>共享订阅可用</code>.客户端使用服务端通知了(不可用)的功能将造成错误.<br>在早期版本的MQTT协议中, 服务端没有实现的功能通过未授权告知客户端.当客户端使用其中一种(不可用的)功能时, 此功能允许服务端告知客户端, 并添加特定的原因码.</li><li>增强的认证<br>提供一种机制来启用包括<code>互相认证</code>在内的<code>质询</code>/<code>响应</code>风格的认证.这允许在客户端和服务端都支持的情况下使用SASL风格的认证, 包括客户端在连接中重新认证的功能.</li><li>订阅选项<br>提供主要用于定义允许消息桥接应用的<code>订阅选项</code>.包括不要把消息发送给消息源客户端(非本地)的选项和订阅时处理保留消息的选项.</li><li>遗嘱延迟<br>提供指定<code>遗嘱消息</code>在连接中断后延时发送的能力.设计此特性是为了在会话的连接重建的情况下不发送遗嘱消息.此特性允许连接短暂中断而不通知其他客户端.</li><li>服务端保持连接<br>允许服务端指定其希望客户端使用的保持连接值.此特性允许服务端设置最大允许的保持连接值并被客户端使用.</li><li>分配客户标识符<br>服务端分配了<code>客户标识符</code>的情况下, 向客户端返回此<code>客户标识符</code>.服务端分配<code>客户标识符</code>只能用于<code>新开始标志</code>为1的连接.</li><li>服务端参考<br>允许服务端使用<code>CONNACK</code>或<code>DISCONNECT</code>报文指定备用服务端.此特性被用于(服务端)重定向或做准备.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式 Strategy Pattern</title>
    <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy-Pattern/"/>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy-Pattern/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>目前我在加密算法的使用上用到了这样的策略模式，可以动态选择加密的具体方法：MD5/SHA2/SM3等</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>这里按照我个人的理解方式，我会拿一个商场促销活动的例子。</p><p>商场促销，有2种可以选择的折扣方式：1.总价打八折；2.每满100元减22元。</p><p>首先可以建立一个策略的抽象类：</p><pre><code class="C++">class Strategy{public:    virtual void Calculation(double &amp;total) = 0;    virtual ~Strategy(){}};</code></pre><p>然后继承于策略类写出具体的算法：</p><pre><code class="C++">class ConcreteStrategyA : public Strategy   //总价打八折{public:    void Calculation(double &amp;total)    {        total = 0.8*total;    }};class ConcreteStrategyB : public Strategy   //每满100减22{public:    void Calculation(double &amp;total)    {        int n = total/100;        total = total - 22*n;    }};</code></pre><p>写完算法类后就需要一个上下文连接类，连接用户交互与底层算法，这里我配合简单工厂模式写了一个策略的配置方式：</p><pre><code class="C++">class ContextFactory{private:    Strategy * strategy = nullptr;public:    ContextFactory(int p)    {        switch (p) {        case 1:            strategy = new ConcreteStrategyA();            break;        case 2:            strategy = new ConcreteStrategyB();            break;        }    }    void ChoseFactory(double &amp;total)    {        strategy-&gt;Calculation(total);    }};</code></pre><p>可以看到配置类里有个私有的策略类，初始化为空，当用户构造ContextFactory类时传入策略方案，根据选择的策略方案构造具体的算法，选择完策略算法后就可以调用计算函数进行总价的计算。</p><h1 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h1><p>1，多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。</p><p>2，需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</p><p>3，对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p><strong>优点：</strong></p><p>1，策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p><p>2，使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</p><p><strong>缺点：</strong></p><p>1，客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p><p>2，由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p><h1 id="和其他设计模式的区别"><a href="#和其他设计模式的区别" class="headerlink" title="和其他设计模式的区别"></a>和其他设计模式的区别</h1><p><strong>1，与状态模式</strong></p><p>在解决的问题上，状态模式是解决内在状态的改变，而策略模式是解决内部算法的改变。在解决的方法上，状态模式是自我控制状态的改变，而策略模式是由外部制定使用使用啥策略。</p><p><strong>2，简单工厂模式</strong></p><p>简单工厂模式是创建型模式，关注对象的创建。策略模式是行为型模式，关注行为的封装。简单工厂模式是根据不同的条件返回一个适合的类给你使用，然后调用者使用工厂类返回的类去完成相应的操作。而策略模式是必须首先创建一个想使用的类实例，然后实例被当作参数传递进去，既而通过该实例去调用不用的算法。在简单工厂模式中实现了通过条件选取一个类去实例化对象，策略模式则将选取相应对象的工作交给模式的使用者，它本身不去做选取工作。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式 Builder Pattern</title>
    <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder-Pattern/"/>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder-Pattern/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>在建造者模式中， <strong>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</strong></li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong> 。</li><li><strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li><strong>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</strong></li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><pre><code class="c++">class Product{public:    Product(){}    ~Product(){}    void setA(QString A) {        this-&gt;m_A = A;    }    void setB(QString B) {        this-&gt;m_B = B;    }    void setC(QString C) {        this-&gt;m_C = C;    }    void show(){        qDebug()&lt;&lt;m_A&lt;&lt;endl               &lt;&lt;m_B&lt;&lt;endl              &lt;&lt;m_C;    }private:    QString m_A;    QString m_B;    QString m_C;};class AbstractBuilder{public:    AbstractBuilder(){}    virtual ~AbstractBuilder(){}    virtual void createProduct() = 0;    virtual void buildPartA(QString param) = 0;    virtual void buildPartB(QString param) = 0;    virtual void buildPartC(QString param) = 0;    virtual Product* getProduct() = 0;};class Builder: public AbstractBuilder{public:    Builder(){}    ~Builder(){}    void createProduct() {        m_product = new Product;    }    void buildPartA(QString param) {        m_product-&gt;setA(param);    }    void buildPartB(QString param) {        m_product-&gt;setB(param);    }    void buildPartC(QString param) {        m_product-&gt;setC(param);    }    Product* getProduct() {        return m_product;    }private:    Product* m_product;};class Director{public:    Director(AbstractBuilder* builder) {        m_builder = builder;    }    ~Director() {}    void construct() {        if(!m_builder)            return;        m_builder-&gt;buildPartA(&quot;A&quot;);        m_builder-&gt;buildPartB(&quot;B&quot;);        m_builder-&gt;buildPartC(&quot;C&quot;);    }private:    AbstractBuilder* m_builder;};</code></pre><pre><code class="c++">    Builder *builder = new Builder;    Director *director = new Director(builder);    builder-&gt;createProduct();    director-&gt;construct();    Product *product = builder-&gt;getProduct();    product-&gt;show();</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式 Abstract Factory</title>
    <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Abstract-Factory/"/>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Abstract-Factory/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li><li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><pre><code class="c++">class Shop{public:    virtual void name() = 0;protected:    ~Shop(){}};class AbstractFactory{public:    virtual Shop *createA() = 0;    virtual Shop *createB() = 0;protected:    ~AbstractFactory(){}};class Milk : public Shop{public:    virtual void name(){        qDebug()&lt;&lt;&quot;milk&quot;;    }protected:    ~Milk(){}};class Water : public Shop{public:    virtual void name(){        qDebug()&lt;&lt;&quot;Water&quot;;    }protected:    ~Water(){}};class Meat : public Shop{public:    virtual void name(){        qDebug()&lt;&lt;&quot;Meat&quot;;    }protected:    ~Meat(){}};class Vegetables : public Shop{public:    virtual void name(){        qDebug()&lt;&lt;&quot;Vegetables&quot;;    }protected:    ~Vegetables(){}};class Drink : public AbstractFactory{public:    virtual Shop *createA(){        return new Milk;    }    virtual Shop *createB(){        return new Water;    }protected:    ~Drink(){}};class Food : public AbstractFactory{public:    virtual Shop *createA(){        return new Meat;    }    virtual Shop *createB(){        return new Vegetables;    }protected:    ~Food(){}};</code></pre><pre><code class="c++">    Shop *shop = nullptr;    AbstractFactory *ab = nullptr;    ab = new Drink;    shop = ab-&gt;createA();    shop-&gt;name();    shop = ab-&gt;createB();    shop-&gt;name();    ab = new Food;    shop = ab-&gt;createA();    shop-&gt;name();    shop = ab-&gt;createB();    shop-&gt;name();</code></pre>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式 Factory Method Pattern</title>
    <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Factory-Method-Pattern/"/>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Factory-Method-Pattern/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>专门定义一个类来负责创建其它类的实例，被创建的实例通常都具有共同的父类</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><pre><code class="c++">class Shop{public:    virtual void commodity() = 0;protected:    ~Shop(){}};class Water : public Shop{public:    void commodity()    {        qDebug()&lt;&lt;&quot;Water&quot;;    }protected:    ~Water(){}};class Milk : public Shop{public:    void commodity()    {        qDebug()&lt;&lt;&quot;Milk&quot;;    }protected:    ~Milk(){}};class Factory{public:    virtual Shop *create() = 0;protected:    ~Factory(){}};class WaterFactory : public Factory{public:    virtual Shop *create()    {        return new Water;    }protected:    ~WaterFactory(){}};class MilkFactory : public Factory{public:    virtual Shop *create()    {        return new Milk;    }protected:    ~MilkFactory(){}};</code></pre><pre><code class="c++">int main(int argc, char *argv[]){    QCoreApplication a(argc, argv);    Factory *factory = nullptr;    Shop *shop = nullptr;    factory = new MilkFactory;    shop = factory-&gt;create();    shop-&gt;commodity();    factory = new WaterFactory;    shop = factory-&gt;create();    shop-&gt;commodity();    return a.exec();}</code></pre><p><img src="C:%5CUsers%5Cl9776%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588589709274.png" srcset="/img/loading.gif" alt="1588589709274"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单工厂模式 Simple Factory Pattern</title>
    <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Simple-Factory-Pattern/"/>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Simple-Factory-Pattern/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>调用一个类达到创建其他类实例的效果</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><pre><code class="C++">class Commodity{public:    virtual void getPrice() = 0;protected:    ~Commodity(){}};class Water : public Commodity{public:    virtual void getPrice()    {        qDebug()&lt;&lt;&quot;Water Price: 2.5&quot;;    }protected:    ~Water(){}};class Milk : public Commodity{public:    virtual void getPrice()    {        qDebug()&lt;&lt;&quot;Milk Price: 4&quot;;    }protected:    ~Milk(){}};class CoKe : public Commodity{public:    virtual void getPrice()    {        qDebug()&lt;&lt;&quot;CoKe Price: 3&quot;;    }protected:    ~CoKe(){}};class ChoseCommodity{public:    Commodity *create(const QString &amp;commodity)    {        if(commodity==&quot;Water&quot;)        {            return new Water;        }        else if (commodity==&quot;Milk&quot;)        {            return new Milk;        }        else if (commodity==&quot;CoKe&quot;)        {            return new CoKe;        }        else        {            qDebug()&lt;&lt;&quot;dont have this commodity!&quot;;            return nullptr;        }    }};</code></pre><pre><code class="c++">int main(int argc, char *argv[]){    QCoreApplication a(argc, argv);    ChoseCommodity *c = new ChoseCommodity;    Commodity *commodity = nullptr;    commodity = c-&gt;create(&quot;Water&quot;);    commodity-&gt;getPrice();    commodity = c-&gt;create(&quot;Milk&quot;);    commodity-&gt;getPrice();    commodity = c-&gt;create(&quot;CoKe&quot;);    commodity-&gt;getPrice();    return a.exec();}</code></pre><p><img src="C:%5CUsers%5Cl9776%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588581388356.png" srcset="/img/loading.gif" alt="1588581388356"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式 Singleton Pattem</title>
    <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattem/"/>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattem/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在面向对象设计与开发中，往往会碰到一些特殊的情况，必须保证一个类在系统中只存在一个实例，这样才能确保它们的逻辑正确性。</p><p>因此就产生了这种特殊的设计模式：单例模式。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>单例类只有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>Windows的Task Manager（任务管理器）就是很典型的单例模式，你不能同时打开两个任务管理器。Windows的回收站也是同理。</li><li>应用程序的日志应用，一般都可以用单例模式实现，只能有一个实例去操作文件。</li><li>读取配置文件，读取的配置项是公有的，一个地方读取了所有地方都能用，没有必要所有的地方都能读取一遍配置。</li><li>数据库连接池，多线程的线程池。</li></ul><h1 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h1><p>懒汉模式：单例类的静态局部变量只在第一次调用的时候被初始化一次，时间换空间，<strong>线程不安全</strong></p><pre><code class="C++">class Singleton{public:    static Singleton&amp; GetInstance()    {        static Singleton instance;        return instance;    }private:    Singleton();    //构造函数私有化};</code></pre><h1 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h1><p>饿汉模式：在程序启动时就提前创建好全局静态对象，空间换时间，<strong>线程安全</strong></p><pre><code class="C++">class Singleton{public:    static Singleton&amp; GetInstance()    {        return *instance;    }public:    static Singleton *instance;private:    Singleton();};Singleton* Singleton::instance = new Singleton;    //创建静态对象</code></pre><h1 id="模板包装类"><a href="#模板包装类" class="headerlink" title="模板包装类"></a>模板包装类</h1><p>单例模式时常用的一种设计模式，往往一个工程中多个类需要创建成单例类，如果每个类都单独写一次单例构造模式，就会很浪费时间，因此用模板类包装好单例模式，在其他需要用到单例的类中调用该方法即可。</p><pre><code class="c++">template&lt;typename T&gt;class Singleton{public:    static T* GetInstance()    {        return instance;    }    static void destoryInstance()    {        if(instance != nullptr)        {            delete instance;            instance = nullptr;        }    }private:    static T *instance;};template &lt;typename T&gt;T* Singleton&lt;T&gt;::instance = new T();</code></pre><pre><code class="C++">friend class Singleton&lt;testClass&gt;;    //单例类为本类的友元类，才能构造对象testClass * obj1 = Singleton&lt;testClass&gt;::GetInstance();</code></pre><h1 id="单次检查锁"><a href="#单次检查锁" class="headerlink" title="单次检查锁"></a>单次检查锁</h1><p>多线程下创建单例加锁可以使线程安全，但是每次访问都会加锁，代价太大</p><pre><code class="C++">#include &lt;QMutex&gt;template&lt;typename T&gt;class Singleton{public:    static T* GetInstance()    {        QMutexLocker mutexLocker(&amp;s_lock);        if(nullptr == instance)        {            instance = new T;        }        return instance;    }    static void destoryInstance()    {        if(nullptr != instance)        {            delete instance;            instance = nullptr;        }    }private:    static T *instance;    static QMutex s_lock;};template &lt;typename T&gt;T* Singleton&lt;T&gt;::instance = nullptr;template &lt;typename T&gt;QMutex Singleton&lt;T&gt;::s_lock;</code></pre><h1 id="双检查锁-DCL"><a href="#双检查锁-DCL" class="headerlink" title="双检查锁 DCL"></a>双检查锁 DCL</h1><p>多线程下使用单例类时，如下加锁并双重检查类是否已构造来访问。双重检查可以防止每次访问都加锁，代价大的问题，但因为编译器内存读写会乱序执行，这样的检查机制严格意义上也不是线程安全的。</p><pre><code class="C++">#include &lt;QMutex&gt;template&lt;typename T&gt;class Singleton{public:    static T* GetInstance()    {        if(nullptr == instance)        {            QMutexLocker mutexLocker(&amp;s_lock);            if(nullptr == instance)            {                instance = new T;            }        }        return instance;    }    static void destoryInstance()    {        if(nullptr != instance)        {            delete instance;            instance = nullptr;        }    }private:    static T *instance;    static QMutex s_lock;};template &lt;typename T&gt;T* Singleton&lt;T&gt;::instance = nullptr;template &lt;typename T&gt;QMutex Singleton&lt;T&gt;::s_lock;</code></pre><h1 id="原子指针-DCL安全"><a href="#原子指针-DCL安全" class="headerlink" title="原子指针 DCL安全"></a>原子指针 DCL安全</h1><p>上面所讲的双重锁检查因为内存读写的乱序性，会使得线程不安全，因此在上述基础上使用原子指针可以在使用双重锁检查的基础上，保证内存访问不会被重新排序。</p><p>我用了QT中的<a href="https://doc.qt.io/qt-5/qatomicpointer.html" target="_blank" rel="noopener">QAtomicPointer</a>，QAtomicPointer是一个模板类，提供原子指针操作。</p><p><strong>bool QAtomicPointer::testAndSetOrdered(T expectedValue<em>, T newValue</em>)</strong></p><p>Atomic test-and-set.</p><p>If the current value of this <a href="https://doc.qt.io/qt-5/qatomicpointer.html" target="_blank" rel="noopener">QAtomicPointer</a> is the <em>expectedValue</em>, the test-and-set functions assign the <em>newValue</em> to this <a href="https://doc.qt.io/qt-5/qatomicpointer.html" target="_blank" rel="noopener">QAtomicPointer</a> and return true. If the values are <em>not</em> the same, this function does nothing and returns <code>false</code>.</p><p>This function uses <em>ordered</em> <a href="https://doc.qt.io/qt-5/qatomicpointer.html#memory-ordering" target="_blank" rel="noopener">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p><p>这个成员函数就可以保证原子指针操作前后内存访问不会被重新排序</p><pre><code class="C++">template&lt;typename T&gt;class Singleton{public:    static T* Instance()    {        QMutexLocker mutexLocker(&amp;s_lock);        if(m_instance.testAndSetOrdered(0,0))        {            m_instance.testAndSetOrdered(0, new T);        }        return m_instance;    }    static void release()    {        QMutexLocker mutexLocker(&amp;s_lock);        m_instance.fetchAndStoreOrdered(0);    }private:    Q_DISABLE_COPY(Singleton)private:    static QMutex s_lock;    static QAtomicPointer&lt;T&gt; m_instance;};template &lt;typename T&gt;QAtomicPointer&lt;T&gt; Singleton&lt;T&gt;::m_instance;template &lt;typename T&gt;QMutex Singleton&lt;T&gt;::s_lock;</code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>除了这些方法，构造单例类的方法还有很多，但每一种都有利有弊，因此具体采用哪种方式也是智者见智。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ClamAV 开源杀毒引擎二次开发 0x01</title>
    <link href="/Security/ClamAV%E5%BC%80%E6%BA%90%E6%9D%80%E6%AF%92%E5%BC%95%E6%93%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%910x01/"/>
    <url>/Security/ClamAV%E5%BC%80%E6%BA%90%E6%9D%80%E6%AF%92%E5%BC%95%E6%93%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%910x01/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>从本文开始我会记录下研究ClamAV开源反病毒引擎的过程，会对整个源码的编译/使用/注释按个人理解做一些说明。学习过程必然是由浅入深的，可能有时前面文章中自己的看法并不正确，之后也会按自己的理解深入来修改之前的文章。</p><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><blockquote><p>ClamAV防病毒引擎编译环境：VS2017  Professional</p></blockquote><blockquote><p>二次开发环境：QT5.12.4 MSVC 2017 32/64bit</p></blockquote><blockquote><p>引擎源码下载：clamav-0.101.4 （哪边下都行）</p></blockquote><ul><li><p>github仓库：<a href="https://github.com/Cisco-Talos/clamav-devel" target="_blank" rel="noopener">https://github.com/Cisco-Talos/clamav-devel</a></p><pre><code class="go">git clone https://github.com/vrtadmin/clamav-devel.git</code></pre></li></ul><ul><li>官网地址：<a href="https://www.clamav.net/downloads" target="_blank" rel="noopener">https://www.clamav.net/downloads</a></li></ul><blockquote><p>OpenSSL库</p></blockquote><h1 id="0x02-目录结构"><a href="#0x02-目录结构" class="headerlink" title="0x02 目录结构"></a>0x02 目录结构</h1><p>首先我们要进入win32目录，找到VS工程配置文件打开，可以看到clamav 工程目录下有很多项目，目前我们只需要着重关注 <code>libclamav</code> ，这就是整个防病毒引擎库项目，官方介绍 The library is thread-safe，即这个库是线程安全的。我们还需重点关注的是<code>clamscan</code> <code>clmad</code> <code>clamdscan</code> 这三个项目。</p><h1 id="0x03-libclamav-构建"><a href="#0x03-libclamav-构建" class="headerlink" title="0x03 libclamav 构建"></a>0x03 libclamav 构建</h1><p>libclamav构建依赖于第三方库，除了OpenSSL外均已包含在工程中，所以第一步要准备好编译完毕的OpenSSL依赖库。将OpenSSL头文件拷贝至根目录openssl目录下，将libcrypto.lib和libssl.lib库拷贝至win32根目录。准备好openssl后即可执行编译，其他的依赖库均已在工程配置文件中设置完毕，编译libclamav时会自动先编译依赖库。</p><p>编译成功生成libclamav.lib和libclamav.dll，还有mspack.dll，pthreads.dll等</p><p>这个就是我们要调用的杀毒引擎库</p><h1 id="0X04-libclamav-调用"><a href="#0X04-libclamav-调用" class="headerlink" title="0X04 libclamav 调用"></a>0X04 libclamav 调用</h1><ol><li><p>创建自己的工程，先包含头文件</p><pre><code class="c++">#include “clamav.h”</code></pre></li><li><p>初始化libclamav库</p><pre><code class="c++">int ret = 0;ret = cl_init(CL_INIT_DEFAULT);//CL_INIT_DEFAULT默认配置 return CL_SUCCESS or another Error code</code></pre></li><li><p>创建扫描引擎</p><pre><code class="c++">static struct cl_engine *engine = nullptr;engine = cl_engine_new();//成功返回指针，存储引擎结构 or NULL</code></pre></li><li><p>加载病毒库/loading database</p><pre><code class="c++">unsigned int sigs = 0;unsigned int dboptions = 0;const char *dbdir = cl_retdbdir();//获取数据库路径//// 设置加载数据库模块选项//dboptions |= CL_DB_STDOPT;//This is an alias for a recommended set of scan optionsdboptions |= CL_DB_PUA;//Load signatures for Potentially Unwanted Applicationsdboptions |= CL_DB_OFFICIAL_ONLY;//Only load official signatures from digitally signed databasesdboptions |= CL_DB_PHISHING;//Load phishing signaturesdboptions |= CL_DB_BYTECODE;//Load bytecodedboptions |= CL_DB_PHISHING_URLS;//Initialize the phishing detection module and load .wdb and .pdb filesret = cl_load(dbdir, engine, &amp;sigs, dboptions)//成功返回CL_SUCCESSif(ret != CL_SUCCESS){  cl_engine_free(engine);//若加载失败必须释放引擎，否则会造成内存泄漏}</code></pre></li><li><p>病毒库加载成功后，需要编译准备反病毒引擎</p><pre><code class="c++">ret = cl_engine_compile(engine))//成功返回CL_SUCCESS，同样失败时需释放引擎</code></pre></li><li><p>准备完毕反病毒引擎后就可以调用扫描接口cl_scanfile进行文件扫描了</p><pre><code class="c++">// 原型int cl_scanfile(    const char *filename,//扫描的文件路径    const char **virname,//病毒名    unsigned long int *scanned,//扫描的byte大小，可置为NULL则不会计数    const struct cl_engine *engine,//已初始化的引擎指针    struct cl_scan_options *options);//扫描功能选项</code></pre><pre><code class="c++">// examplestruct cl_scan_options options;const char * fileName = &quot;C:/XXX.exe&quot;;const char * virname = nullptr;if(cl_scanfile(fileName,&amp;virname,nullptr,engine,&amp;options) == CL_VIRUS){    qDebug()&lt;&lt;&quot;there have virus!&quot;;}</code></pre><p>除了cl_scanfile还有cl_scanfile_callback同样也能扫描文件，具体的参数含义在接口源码上都有注释。</p><p>扫描中比较中要的是最后一个cl_scan_options结构</p><pre><code>struct cl_scan_options {        uint32_t general;        uint32_t parse;        uint32_t alert;        uint32_t heuristic_alert;        uint32_t mail;        uint32_t dev;    };</code></pre><p><code>general</code> 常规扫描选项</p><p><strong>CL_SCAN_GENERAL_ALLMATCHES</strong> 在全匹配模式下扫描</p><p><strong>CL_SCAN_GENERAL_COLLECT_METADATA</strong> 收集元数据</p><p><strong>CL_SCAN_GENERAL_HEURISTICS</strong> 启发式警报选项</p><p><code>parse</code> 启用或禁用特定的解析功能，设置~0可以开启全部解析功能</p><p><strong>CL_SCAN_PARSE_ARCHIVE</strong> 该标志启用透明扫描各种存档格式。</p><p><strong>CL_SCAN_PARSE_ELF</strong> 启用对ELF文件的支持。</p><p><strong>CL_SCAN_PARSE_PDF</strong> 允许在PDF文件中进行扫描。</p><p><strong>CL_SCAN_PARSE_SWF</strong> 允许在SWF文件（尤其是压缩的SWF）中进行扫描。</p><p><strong>CL_SCAN_PARSE_HWP</strong> 启用对韩文文字处理器（HWP）文件的扫描。</p><p><strong>CL_SCAN_PARSE_XMLDOCS</strong> 启用扫描XML格式的文档（例如Word，Excel，Powerpoint，HWP）。</p><p><strong>CL_SCAN_PARSE_MAIL</strong> 启用对邮件文件的支持。</p><p><strong>CL_SCAN_PARSE_OLE2</strong> 启用对OLE2容器的支持（由MS Office和.msi文件使用）。</p><p><strong>CL_SCAN_PARSE_HTML</strong> 此标志启用HTML规范化（包括ScrEnc解密）。</p><p><strong>CL_SCAN_PARSE_PE</strong> 该标志启用对可移植可执行文件的深度扫描，并允许libclamav来解压缩使用运行时拆包程序压缩的可执行文件。</p><p><code>heuristic</code> 启用特定启发式警报的选项</p><p><strong>CL_SCAN_GENERAL_HEURISTIC_PRECEDENCE</strong> 允许启发式匹配优先。启用后，如果启发式扫描（例如phishingScan）检测到可能的病毒/网络钓鱼，它将立即停止扫描。推荐使用，节省CPU扫描时间。当<em>禁用</em>启发式扫描检测到的病毒/网络钓鱼将只在扫描结束时报告。如果存档同时包含启发式检测到的病毒/网络钓鱼和真实恶意软件，则将报告真实恶意软件。</p><p><strong>CL_SCAN_HEURISTIC_ENCRYPTED_ARCHIVE</strong> 带有该标志的库将标记加密的存档为病毒（加密的.zip，.7zip，.rar）。</p><p><strong>CL_SCAN_HEURISTIC_ENCRYPTED_DOC</strong> 带有此标志的库将标记加密的文档为病毒（加密的.pdf）。</p><p><strong>CL_SCAN_HEURISTIC_BROKEN</strong> libclamav将尝试检测损坏的可执行文件并将其标记为Broken.Executable。</p><p><strong>CL_SCAN_HEURISTIC_EXCEEDS_MAX</strong> 当任何文件的扫描超过最大值（例如最大文件大小，最大扫描大小，最大递归级别）时<strong>发出</strong>警报。</p><p><strong>CL_SCAN_HEURISTIC_PHISHING_SSL_MISMATCH</strong> 网络钓鱼模块的启发式：提示URL中的SSL不匹配。</p><p><strong>CL_SCAN_HEURISTIC_PHISHING_CLOAK</strong> 网页仿冒模块的启发式：对隐藏的URL <strong>发出</strong>警报。</p><p>包含VBA宏的<strong>CL_SCAN_HEURISTIC_MACROS</strong> OLE2容器将被标记为已感染（Heuristics.OLE2.ContainsMacros）。</p><p>如果分区表大小没有意义，则<strong>CL_SCAN_HEURISTIC_PARTITION_INTXN发出</strong>警报</p><p><strong>CL_SCAN_HEURISTIC_STRUCTURED</strong> 启用数据丢失防护（DLP）模块，该模块扫描信用卡号和SSN号。即在检测到个人信息时发出警报</p><p><strong>CL_SCAN_HEURISTIC_STRUCTURED_SSN_NORMAL</strong> 搜索[检测到]格式为xx-yy-zzzz的SSN并<strong>发出</strong>警报。</p><p><strong>CL_SCAN_HEURISTIC_STRUCTURED_SSN_STRIPPED</strong> 搜索[并在检测到格式为xxyyzzzz的SSN时发出警报。</p><p><code>mail</code> -启用特定邮件解析功能的选项</p><p><strong>CL_SCAN_MAIL_PARTIAL_MESSAGE</strong> 扫描RFC1341邮件，分为多封电子邮件。您将需要定期清理<code>$TemporaryDirectory/clamav-partial</code>目录。</p><p><code>dev</code> -专供ClamAV开发人员使用的选件</p><p><strong>CL_SCAN_DEV_COLLECT_SHA</strong> 在sha-collect版本中启用哈希输出-仅供内部使用</p><p><strong>CL_SCAN_DEV_COLLECT_PERFORMANCE_INFO</strong> 收集性能计时</p></li><li><p>最后在结束扫描关闭反病毒引擎时必须释放引擎指针！！</p><h1 id="0x05-结语"><a href="#0x05-结语" class="headerlink" title="0x05 结语"></a>0x05 结语</h1><p>至此按上述步骤已经成编译并调用ClamAV反病毒引擎。其中具体的参数介绍是按照官网手册介绍所描述，具体没有一项一项仔细深入研究，接下来会基于clamscan项目对这些配置参数深入研究。</p><p>本节源码：<a href="https://github.com/ljh951028/ClamAV" target="_blank" rel="noopener">https://github.com/ljh951028/ClamAV</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ClamAV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ClamAV 开源杀毒引擎二次开发 0x00</title>
    <link href="/Security/ClamAV%E5%BC%80%E6%BA%90%E6%9D%80%E6%AF%92%E5%BC%95%E6%93%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%910x00/"/>
    <url>/Security/ClamAV%E5%BC%80%E6%BA%90%E6%9D%80%E6%AF%92%E5%BC%95%E6%93%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%910x00/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近来有想法研究下windows下的杀毒引擎，一来是为了之后的工作中大概率会接触一些，二来也是因为自己兴趣所向。接下来发布的“基于ClamAV开源杀毒引擎二次开发”文章都是为研究该开源杀毒引擎编译/调用/工作方式所做的笔记，其中所述的方式方法不一定正确，若有错误理解也请指正。</p><p>首先为什么选择ClamAV这款杀毒引擎来学习呢？因为我就只找到了这么一个开源的，能在windows上用的…</p><p>然后我看了官网上使用手册中的介绍，功能还是相当强大的，不逊于一般的杀毒引擎。</p><h1 id="ClamAV®-Introduction-简介"><a href="#ClamAV®-Introduction-简介" class="headerlink" title="ClamAV®  Introduction/简介"></a>ClamAV®  Introduction/简介</h1><p>ClamAV® is an open source antivirus engine for detecting trojans, viruses, malware &amp; other malicious threats.</p><p>ClamAV® is an open source (GPL) anti-virus engine used in a variety of situations including email scanning, web scanning, and end point security. It provides a number of utilities including a flexible and scalable multi-threaded daemon, a command line scanner and an advanced tool for automatic database updates.</p><h2 id="Features-特点"><a href="#Features-特点" class="headerlink" title="Features/特点"></a>Features/特点</h2><ul><li>Command-line scanner</li><li>Milter interface for sendmail</li><li>Advanced database updater with support for scripted updates and digital signatures</li><li>Virus database updated multiple times per day</li><li>Built-in support for all standard mail file formats</li><li>Built-in support for various archive formats, including Zip, RAR, Dmg, Tar, Gzip, Bzip2, OLE2, Cabinet, CHM, BinHex, SIS and others</li><li>Built-in support for ELF executables and Portable Executable files packed with UPX, FSG, Petite, NsPack, wwpack32, MEW, Upack and obfuscated with SUE, Y0da Cryptor and others</li><li>Built-in support for popular document formats including MS Office and MacOffice files, HTML, Flash, RTF and PDF</li></ul><p>上述简介都是ClamAV官网上对于ClamAV杀毒引擎的简介。<a href="https://www.clamav.net/" target="_blank" rel="noopener">https://www.clamav.net/</a></p><p>简单的来说ClamAV是一款开源（GPLv2）的杀毒引擎，它的功能包含：邮件扫描/web扫描/针对性的端点安全；可检测超过一百万种病毒，蠕虫和木马，包括Microsoft Office宏病毒，移动恶意软件和其他威胁；支持好多好多文件类型；官网上开源工程里也提供了好几种基于该杀毒引擎开发的高级工具。我基本也是根据官网开发好的工具，调试他的源码，再根据文档说明，理解整个杀毒引擎的工作模式，然后自己写一些小工具。</p><h2 id="Supported-platforms-支持平台"><a href="#Supported-platforms-支持平台" class="headerlink" title="Supported platforms/支持平台"></a>Supported platforms/支持平台</h2><p>GNU/Linux：Ubuntu/Debian/CentOS</p><p>UNIX：Solaris/FreeBSD/macOS</p><p>Windows：7/10</p><p>我的话现在仅仅在windows上做二次开发，因为Linux下开发平时工作用的少，等要用了再学吧。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>第一篇文章就这样吧，拷贝了一下官网的说明，主要第一篇也是自己先熟悉熟悉Hexo建站+发文章，熟悉码字写文章啥的，下一篇就会开始记录ClamAV这个杀毒引擎在windows下怎么编译，然后官方的工具怎么用。要是有啥问题想联系我，可以点击主页里我的Github主页留言或者Github里我留了邮箱。</p>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ClamAV</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
