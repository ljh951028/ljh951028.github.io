<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>策略模式 Strategy Pattern</title>
    <link href="undefined%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy-Pattern/"/>
    <url>%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy-Pattern/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>目前我在加密算法的使用上用到了这样的策略模式，可以动态选择加密的具体方法：MD5/SHA2/SM3等</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>这里按照我个人的理解方式，我会拿一个商场促销活动的例子。</p><p>商场促销，有2种可以选择的折扣方式：1.总价打八折；2.每满100元减22元。</p><p>首先可以建立一个策略的抽象类：</p><pre><code class="C++">class Strategy{public:    virtual void Calculation(double &amp;total) = 0;    virtual ~Strategy(){}};</code></pre><p>然后继承于策略类写出具体的算法：</p><pre><code class="C++">class ConcreteStrategyA : public Strategy   //总价打八折{public:    void Calculation(double &amp;total)    {        total = 0.8*total;    }};class ConcreteStrategyB : public Strategy   //每满100减22{public:    void Calculation(double &amp;total)    {        int n = total/100;        total = total - 22*n;    }};</code></pre><p>写完算法类后就需要一个上下文连接类，连接用户交互与底层算法，这里我配合简单工厂模式写了一个策略的配置方式：</p><pre><code class="C++">class ContextFactory{private:    Strategy * strategy = nullptr;public:    ContextFactory(int p)    {        switch (p) {        case 1:            strategy = new ConcreteStrategyA();            break;        case 2:            strategy = new ConcreteStrategyB();            break;        }    }    void ChoseFactory(double &amp;total)    {        strategy-&gt;Calculation(total);    }};</code></pre><p>可以看到配置类里有个私有的策略类，初始化为空，当用户构造ContextFactory类时传入策略方案，根据选择的策略方案构造具体的算法，选择完策略算法后就可以调用计算函数进行总价的计算。</p><h1 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h1><p>1，多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。</p><p>2，需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</p><p>3，对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p><strong>优点：</strong></p><p>1，策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p><p>2，使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</p><p><strong>缺点：</strong></p><p>1，客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p><p>2，由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p><h1 id="和其他设计模式的区别"><a href="#和其他设计模式的区别" class="headerlink" title="和其他设计模式的区别"></a>和其他设计模式的区别</h1><p><strong>1，与状态模式</strong></p><p>在解决的问题上，状态模式是解决内在状态的改变，而策略模式是解决内部算法的改变。在解决的方法上，状态模式是自我控制状态的改变，而策略模式是由外部制定使用使用啥策略。</p><p><strong>2，简单工厂模式</strong></p><p>简单工厂模式是创建型模式，关注对象的创建。策略模式是行为型模式，关注行为的封装。简单工厂模式是根据不同的条件返回一个适合的类给你使用，然后调用者使用工厂类返回的类去完成相应的操作。而策略模式是必须首先创建一个想使用的类实例，然后实例被当作参数传递进去，既而通过该实例去调用不用的算法。在简单工厂模式中实现了通过条件选取一个类去实例化对象，策略模式则将选取相应对象的工作交给模式的使用者，它本身不去做选取工作。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式 Singleton Pattem</title>
    <link href="undefined%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattem/"/>
    <url>%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattem/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在面向对象设计与开发中，往往会碰到一些特殊的情况，必须保证一个类在系统中只存在一个实例，这样才能确保它们的逻辑正确性。</p><p>因此就产生了这种特殊的设计模式：单例模式。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>单例类只有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>Windows的Task Manager（任务管理器）就是很典型的单例模式，你不能同时打开两个任务管理器。Windows的回收站也是同理。</li><li>应用程序的日志应用，一般都可以用单例模式实现，只能有一个实例去操作文件。</li><li>读取配置文件，读取的配置项是公有的，一个地方读取了所有地方都能用，没有必要所有的地方都能读取一遍配置。</li><li>数据库连接池，多线程的线程池。</li></ul><h1 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h1><p>懒汉模式：单例类的静态局部变量只在第一次调用的时候被初始化一次，时间换空间，<strong>线程不安全</strong></p><pre><code class="C++">class Singleton{public:    static Singleton&amp; GetInstance()    {        static Singleton instance;        return instance;    }private:    Singleton();    //构造函数私有化};</code></pre><h1 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h1><p>饿汉模式：在程序启动时就提前创建好全局静态对象，空间换时间，<strong>线程安全</strong></p><pre><code class="C++">class Singleton{public:    static Singleton&amp; GetInstance()    {        return *instance;    }public:    static Singleton *instance;private:    Singleton();};Singleton* Singleton::instance = new Singleton;    //创建静态对象</code></pre><h1 id="模板包装类"><a href="#模板包装类" class="headerlink" title="模板包装类"></a>模板包装类</h1><p>单例模式时常用的一种设计模式，往往一个工程中多个类需要创建成单例类，如果每个类都单独写一次单例构造模式，就会很浪费时间，因此用模板类包装好单例模式，在其他需要用到单例的类中调用该方法即可。</p><pre><code class="c++">template&lt;typename T&gt;class Singleton{public:    static T* GetInstance()    {        return instance;    }    static void destoryInstance()    {        if(instance != nullptr)        {            delete instance;            instance = nullptr;        }    }private:    static T *instance;};template &lt;typename T&gt;T* Singleton&lt;T&gt;::instance = new T();</code></pre><pre><code class="C++">friend class Singleton&lt;testClass&gt;;    //单例类为本类的友元类，才能构造对象testClass * obj1 = Singleton&lt;testClass&gt;::GetInstance();</code></pre><h1 id="单次检查锁"><a href="#单次检查锁" class="headerlink" title="单次检查锁"></a>单次检查锁</h1><p>多线程下创建单例加锁可以使线程安全，但是每次访问都会加锁，代价太大</p><pre><code class="C++">#include &lt;QMutex&gt;template&lt;typename T&gt;class Singleton{public:    static T* GetInstance()    {        QMutexLocker mutexLocker(&amp;s_lock);        if(nullptr == instance)        {            instance = new T;        }        return instance;    }    static void destoryInstance()    {        if(nullptr != instance)        {            delete instance;            instance = nullptr;        }    }private:    static T *instance;    static QMutex s_lock;};template &lt;typename T&gt;T* Singleton&lt;T&gt;::instance = nullptr;template &lt;typename T&gt;QMutex Singleton&lt;T&gt;::s_lock;</code></pre><h1 id="双检查锁-DCL"><a href="#双检查锁-DCL" class="headerlink" title="双检查锁 DCL"></a>双检查锁 DCL</h1><p>多线程下使用单例类时，如下加锁并双重检查类是否已构造来访问。双重检查可以防止每次访问都加锁，代价大的问题，但因为编译器内存读写会乱序执行，这样的检查机制严格意义上也不是线程安全的。</p><pre><code class="C++">#include &lt;QMutex&gt;template&lt;typename T&gt;class Singleton{public:    static T* GetInstance()    {        if(nullptr == instance)        {            QMutexLocker mutexLocker(&amp;s_lock);            if(nullptr == instance)            {                instance = new T;            }        }        return instance;    }    static void destoryInstance()    {        if(nullptr != instance)        {            delete instance;            instance = nullptr;        }    }private:    static T *instance;    static QMutex s_lock;};template &lt;typename T&gt;T* Singleton&lt;T&gt;::instance = nullptr;template &lt;typename T&gt;QMutex Singleton&lt;T&gt;::s_lock;</code></pre><h1 id="原子指针-DCL安全"><a href="#原子指针-DCL安全" class="headerlink" title="原子指针 DCL安全"></a>原子指针 DCL安全</h1><p>上面所讲的双重锁检查因为内存读写的乱序性，会使得线程不安全，因此在上述基础上使用原子指针可以在使用双重锁检查的基础上，保证内存访问不会被重新排序。</p><p>我用了QT中的<a href="https://doc.qt.io/qt-5/qatomicpointer.html" target="_blank" rel="noopener">QAtomicPointer</a>，QAtomicPointer是一个模板类，提供原子指针操作。</p><p><strong>bool QAtomicPointer::testAndSetOrdered(T expectedValue<em>, T newValue</em>)</strong></p><p>Atomic test-and-set.</p><p>If the current value of this <a href="https://doc.qt.io/qt-5/qatomicpointer.html" target="_blank" rel="noopener">QAtomicPointer</a> is the <em>expectedValue</em>, the test-and-set functions assign the <em>newValue</em> to this <a href="https://doc.qt.io/qt-5/qatomicpointer.html" target="_blank" rel="noopener">QAtomicPointer</a> and return true. If the values are <em>not</em> the same, this function does nothing and returns <code>false</code>.</p><p>This function uses <em>ordered</em> <a href="https://doc.qt.io/qt-5/qatomicpointer.html#memory-ordering" target="_blank" rel="noopener">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p><p>这个成员函数就可以保证原子指针操作前后内存访问不会被重新排序</p><pre><code class="C++">template&lt;typename T&gt;class Singleton{public:    static T* Instance()    {        QMutexLocker mutexLocker(&amp;s_lock);        if(m_instance.testAndSetOrdered(0,0))        {            m_instance.testAndSetOrdered(0, new T);        }        return m_instance;    }    static void release()    {        QMutexLocker mutexLocker(&amp;s_lock);        m_instance.fetchAndStoreOrdered(0);    }private:    Q_DISABLE_COPY(Singleton)private:    static QMutex s_lock;    static QAtomicPointer&lt;T&gt; m_instance;};template &lt;typename T&gt;QAtomicPointer&lt;T&gt; Singleton&lt;T&gt;::m_instance;template &lt;typename T&gt;QMutex Singleton&lt;T&gt;::s_lock;</code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>除了这些方法，构造单例类的方法还有很多，但每一种都有利有弊，因此具体采用哪种方式也是智者见智。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ClamAV 开源杀毒引擎二次开发 0x01</title>
    <link href="undefinedSecurity/ClamAV%E5%BC%80%E6%BA%90%E6%9D%80%E6%AF%92%E5%BC%95%E6%93%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%910x01/"/>
    <url>Security/ClamAV%E5%BC%80%E6%BA%90%E6%9D%80%E6%AF%92%E5%BC%95%E6%93%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%910x01/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>从本文开始我会记录下研究ClamAV开源反病毒引擎的过程，会对整个源码的编译/使用/注释按个人理解做一些说明。学习过程必然是由浅入深的，可能有时前面文章中自己的看法并不正确，之后也会按自己的理解深入来修改之前的文章。</p><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><blockquote><p>ClamAV防病毒引擎编译环境：VS2017  Professional</p></blockquote><blockquote><p>二次开发环境：QT5.12.4 MSVC 2017 32/64bit</p></blockquote><blockquote><p>引擎源码下载：clamav-0.101.4 （哪边下都行）</p></blockquote><ul><li><p>github仓库：<a href="https://github.com/Cisco-Talos/clamav-devel" target="_blank" rel="noopener">https://github.com/Cisco-Talos/clamav-devel</a></p><pre><code class="go">git clone https://github.com/vrtadmin/clamav-devel.git</code></pre></li></ul><ul><li>官网地址：<a href="https://www.clamav.net/downloads" target="_blank" rel="noopener">https://www.clamav.net/downloads</a></li></ul><blockquote><p>OpenSSL库</p></blockquote><h1 id="0x02-目录结构"><a href="#0x02-目录结构" class="headerlink" title="0x02 目录结构"></a>0x02 目录结构</h1><p>首先我们要进入win32目录，找到VS工程配置文件打开，可以看到clamav 工程目录下有很多项目，目前我们只需要着重关注 <code>libclamav</code> ，这就是整个防病毒引擎库项目，官方介绍 The library is thread-safe，即这个库是线程安全的。我们还需重点关注的是<code>clamscan</code> <code>clmad</code> <code>clamdscan</code> 这三个项目。</p><h1 id="0x03-libclamav-构建"><a href="#0x03-libclamav-构建" class="headerlink" title="0x03 libclamav 构建"></a>0x03 libclamav 构建</h1><p>libclamav构建依赖于第三方库，除了OpenSSL外均已包含在工程中，所以第一步要准备好编译完毕的OpenSSL依赖库。将OpenSSL头文件拷贝至根目录openssl目录下，将libcrypto.lib和libssl.lib库拷贝至win32根目录。准备好openssl后即可执行编译，其他的依赖库均已在工程配置文件中设置完毕，编译libclamav时会自动先编译依赖库。</p><p>编译成功生成libclamav.lib和libclamav.dll，还有mspack.dll，pthreads.dll等</p><p>这个就是我们要调用的杀毒引擎库</p><h1 id="0X04-libclamav-调用"><a href="#0X04-libclamav-调用" class="headerlink" title="0X04 libclamav 调用"></a>0X04 libclamav 调用</h1><ol><li><p>创建自己的工程，先包含头文件</p><pre><code class="c++">#include “clamav.h”</code></pre></li><li><p>初始化libclamav库</p><pre><code class="c++">int ret = 0;ret = cl_init(CL_INIT_DEFAULT);//CL_INIT_DEFAULT默认配置 return CL_SUCCESS or another Error code</code></pre></li><li><p>创建扫描引擎</p><pre><code class="c++">static struct cl_engine *engine = nullptr;engine = cl_engine_new();//成功返回指针，存储引擎结构 or NULL</code></pre></li><li><p>加载病毒库/loading database</p><pre><code class="c++">unsigned int sigs = 0;unsigned int dboptions = 0;const char *dbdir = cl_retdbdir();//获取数据库路径//// 设置加载数据库模块选项//dboptions |= CL_DB_STDOPT;//This is an alias for a recommended set of scan optionsdboptions |= CL_DB_PUA;//Load signatures for Potentially Unwanted Applicationsdboptions |= CL_DB_OFFICIAL_ONLY;//Only load official signatures from digitally signed databasesdboptions |= CL_DB_PHISHING;//Load phishing signaturesdboptions |= CL_DB_BYTECODE;//Load bytecodedboptions |= CL_DB_PHISHING_URLS;//Initialize the phishing detection module and load .wdb and .pdb filesret = cl_load(dbdir, engine, &amp;sigs, dboptions)//成功返回CL_SUCCESSif(ret != CL_SUCCESS){  cl_engine_free(engine);//若加载失败必须释放引擎，否则会造成内存泄漏}</code></pre></li><li><p>病毒库加载成功后，需要编译准备反病毒引擎</p><pre><code class="c++">ret = cl_engine_compile(engine))//成功返回CL_SUCCESS，同样失败时需释放引擎</code></pre></li><li><p>准备完毕反病毒引擎后就可以调用扫描接口cl_scanfile进行文件扫描了</p><pre><code class="c++">// 原型int cl_scanfile(    const char *filename,//扫描的文件路径    const char **virname,//病毒名    unsigned long int *scanned,//扫描的byte大小，可置为NULL则不会计数    const struct cl_engine *engine,//已初始化的引擎指针    struct cl_scan_options *options);//扫描功能选项</code></pre><pre><code class="c++">// examplestruct cl_scan_options options;const char * fileName = &quot;C:/XXX.exe&quot;;const char * virname = nullptr;if(cl_scanfile(fileName,&amp;virname,nullptr,engine,&amp;options) == CL_VIRUS){    qDebug()&lt;&lt;&quot;there have virus!&quot;;}</code></pre><p>除了cl_scanfile还有cl_scanfile_callback同样也能扫描文件，具体的参数含义在接口源码上都有注释。</p><p>扫描中比较中要的是最后一个cl_scan_options结构</p><pre><code>struct cl_scan_options {        uint32_t general;        uint32_t parse;        uint32_t alert;        uint32_t heuristic_alert;        uint32_t mail;        uint32_t dev;    };</code></pre><p><code>general</code> 常规扫描选项</p><p><strong>CL_SCAN_GENERAL_ALLMATCHES</strong> 在全匹配模式下扫描</p><p><strong>CL_SCAN_GENERAL_COLLECT_METADATA</strong> 收集元数据</p><p><strong>CL_SCAN_GENERAL_HEURISTICS</strong> 启发式警报选项</p><p><code>parse</code> 启用或禁用特定的解析功能，设置~0可以开启全部解析功能</p><p><strong>CL_SCAN_PARSE_ARCHIVE</strong> 该标志启用透明扫描各种存档格式。</p><p><strong>CL_SCAN_PARSE_ELF</strong> 启用对ELF文件的支持。</p><p><strong>CL_SCAN_PARSE_PDF</strong> 允许在PDF文件中进行扫描。</p><p><strong>CL_SCAN_PARSE_SWF</strong> 允许在SWF文件（尤其是压缩的SWF）中进行扫描。</p><p><strong>CL_SCAN_PARSE_HWP</strong> 启用对韩文文字处理器（HWP）文件的扫描。</p><p><strong>CL_SCAN_PARSE_XMLDOCS</strong> 启用扫描XML格式的文档（例如Word，Excel，Powerpoint，HWP）。</p><p><strong>CL_SCAN_PARSE_MAIL</strong> 启用对邮件文件的支持。</p><p><strong>CL_SCAN_PARSE_OLE2</strong> 启用对OLE2容器的支持（由MS Office和.msi文件使用）。</p><p><strong>CL_SCAN_PARSE_HTML</strong> 此标志启用HTML规范化（包括ScrEnc解密）。</p><p><strong>CL_SCAN_PARSE_PE</strong> 该标志启用对可移植可执行文件的深度扫描，并允许libclamav来解压缩使用运行时拆包程序压缩的可执行文件。</p><p><code>heuristic</code> 启用特定启发式警报的选项</p><p><strong>CL_SCAN_GENERAL_HEURISTIC_PRECEDENCE</strong> 允许启发式匹配优先。启用后，如果启发式扫描（例如phishingScan）检测到可能的病毒/网络钓鱼，它将立即停止扫描。推荐使用，节省CPU扫描时间。当<em>禁用</em>启发式扫描检测到的病毒/网络钓鱼将只在扫描结束时报告。如果存档同时包含启发式检测到的病毒/网络钓鱼和真实恶意软件，则将报告真实恶意软件。</p><p><strong>CL_SCAN_HEURISTIC_ENCRYPTED_ARCHIVE</strong> 带有该标志的库将标记加密的存档为病毒（加密的.zip，.7zip，.rar）。</p><p><strong>CL_SCAN_HEURISTIC_ENCRYPTED_DOC</strong> 带有此标志的库将标记加密的文档为病毒（加密的.pdf）。</p><p><strong>CL_SCAN_HEURISTIC_BROKEN</strong> libclamav将尝试检测损坏的可执行文件并将其标记为Broken.Executable。</p><p><strong>CL_SCAN_HEURISTIC_EXCEEDS_MAX</strong> 当任何文件的扫描超过最大值（例如最大文件大小，最大扫描大小，最大递归级别）时<strong>发出</strong>警报。</p><p><strong>CL_SCAN_HEURISTIC_PHISHING_SSL_MISMATCH</strong> 网络钓鱼模块的启发式：提示URL中的SSL不匹配。</p><p><strong>CL_SCAN_HEURISTIC_PHISHING_CLOAK</strong> 网页仿冒模块的启发式：对隐藏的URL <strong>发出</strong>警报。</p><p>包含VBA宏的<strong>CL_SCAN_HEURISTIC_MACROS</strong> OLE2容器将被标记为已感染（Heuristics.OLE2.ContainsMacros）。</p><p>如果分区表大小没有意义，则<strong>CL_SCAN_HEURISTIC_PARTITION_INTXN发出</strong>警报</p><p><strong>CL_SCAN_HEURISTIC_STRUCTURED</strong> 启用数据丢失防护（DLP）模块，该模块扫描信用卡号和SSN号。即在检测到个人信息时发出警报</p><p><strong>CL_SCAN_HEURISTIC_STRUCTURED_SSN_NORMAL</strong> 搜索[检测到]格式为xx-yy-zzzz的SSN并<strong>发出</strong>警报。</p><p><strong>CL_SCAN_HEURISTIC_STRUCTURED_SSN_STRIPPED</strong> 搜索[并在检测到格式为xxyyzzzz的SSN时发出警报。</p><p><code>mail</code> -启用特定邮件解析功能的选项</p><p><strong>CL_SCAN_MAIL_PARTIAL_MESSAGE</strong> 扫描RFC1341邮件，分为多封电子邮件。您将需要定期清理<code>$TemporaryDirectory/clamav-partial</code>目录。</p><p><code>dev</code> -专供ClamAV开发人员使用的选件</p><p><strong>CL_SCAN_DEV_COLLECT_SHA</strong> 在sha-collect版本中启用哈希输出-仅供内部使用</p><p><strong>CL_SCAN_DEV_COLLECT_PERFORMANCE_INFO</strong> 收集性能计时</p></li><li><p>最后在结束扫描关闭反病毒引擎时必须释放引擎指针！！</p><h1 id="0x05-结语"><a href="#0x05-结语" class="headerlink" title="0x05 结语"></a>0x05 结语</h1><p>至此按上述步骤已经成编译并调用ClamAV反病毒引擎。其中具体的参数介绍是按照官网手册介绍所描述，具体没有一项一项仔细深入研究，接下来会基于clamscan项目对这些配置参数深入研究。</p><p>本节源码：<a href="https://github.com/ljh951028/ClamAV" target="_blank" rel="noopener">https://github.com/ljh951028/ClamAV</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ClamAV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ClamAV 开源杀毒引擎二次开发 0x00</title>
    <link href="undefinedSecurity/ClamAV%E5%BC%80%E6%BA%90%E6%9D%80%E6%AF%92%E5%BC%95%E6%93%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%910x00/"/>
    <url>Security/ClamAV%E5%BC%80%E6%BA%90%E6%9D%80%E6%AF%92%E5%BC%95%E6%93%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%910x00/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近来有想法研究下windows下的杀毒引擎，一来是为了之后的工作中大概率会接触一些，二来也是因为自己兴趣所向。接下来发布的“基于ClamAV开源杀毒引擎二次开发”文章都是为研究该开源杀毒引擎编译/调用/工作方式所做的笔记，其中所述的方式方法不一定正确，若有错误理解也请指正。</p><p>首先为什么选择ClamAV这款杀毒引擎来学习呢？因为我就只找到了这么一个开源的，能在windows上用的…</p><p>然后我看了官网上使用手册中的介绍，功能还是相当强大的，不逊于一般的杀毒引擎。</p><h1 id="ClamAV®-Introduction-简介"><a href="#ClamAV®-Introduction-简介" class="headerlink" title="ClamAV®  Introduction/简介"></a>ClamAV®  Introduction/简介</h1><p>ClamAV® is an open source antivirus engine for detecting trojans, viruses, malware &amp; other malicious threats.</p><p>ClamAV® is an open source (GPL) anti-virus engine used in a variety of situations including email scanning, web scanning, and end point security. It provides a number of utilities including a flexible and scalable multi-threaded daemon, a command line scanner and an advanced tool for automatic database updates.</p><h2 id="Features-特点"><a href="#Features-特点" class="headerlink" title="Features/特点"></a>Features/特点</h2><ul><li>Command-line scanner</li><li>Milter interface for sendmail</li><li>Advanced database updater with support for scripted updates and digital signatures</li><li>Virus database updated multiple times per day</li><li>Built-in support for all standard mail file formats</li><li>Built-in support for various archive formats, including Zip, RAR, Dmg, Tar, Gzip, Bzip2, OLE2, Cabinet, CHM, BinHex, SIS and others</li><li>Built-in support for ELF executables and Portable Executable files packed with UPX, FSG, Petite, NsPack, wwpack32, MEW, Upack and obfuscated with SUE, Y0da Cryptor and others</li><li>Built-in support for popular document formats including MS Office and MacOffice files, HTML, Flash, RTF and PDF</li></ul><p>上述简介都是ClamAV官网上对于ClamAV杀毒引擎的简介。<a href="https://www.clamav.net/" target="_blank" rel="noopener">https://www.clamav.net/</a></p><p>简单的来说ClamAV是一款开源（GPLv2）的杀毒引擎，它的功能包含：邮件扫描/web扫描/针对性的端点安全；可检测超过一百万种病毒，蠕虫和木马，包括Microsoft Office宏病毒，移动恶意软件和其他威胁；支持好多好多文件类型；官网上开源工程里也提供了好几种基于该杀毒引擎开发的高级工具。我基本也是根据官网开发好的工具，调试他的源码，再根据文档说明，理解整个杀毒引擎的工作模式，然后自己写一些小工具。</p><h2 id="Supported-platforms-支持平台"><a href="#Supported-platforms-支持平台" class="headerlink" title="Supported platforms/支持平台"></a>Supported platforms/支持平台</h2><p>GNU/Linux：Ubuntu/Debian/CentOS</p><p>UNIX：Solaris/FreeBSD/macOS</p><p>Windows：7/10</p><p>我的话现在仅仅在windows上做二次开发，因为Linux下开发平时工作用的少，等要用了再学吧。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>第一篇文章就这样吧，拷贝了一下官网的说明，主要第一篇也是自己先熟悉熟悉Hexo建站+发文章，熟悉码字写文章啥的，下一篇就会开始记录ClamAV这个杀毒引擎在windows下怎么编译，然后官方的工具怎么用。要是有啥问题想联系我，可以点击主页里我的Github主页留言或者Github里我留了邮箱。</p>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ClamAV</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>