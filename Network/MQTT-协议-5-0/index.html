<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/brain.ico">
  <link rel="icon" type="image/png" href="/img/brain.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content>
  <meta name="author" content="Li Junhao">
  <meta name="keywords" content="Windows,Kernel,Qt,Security">
  <title>MQTT 协议 5.0 ~ God mercy me</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css">


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>God mercy me</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/homepage.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期二, 十一月 5日 2019, 6:00 晚上
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    72.5k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      276 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="MQTT-协议-5-0中文版"><a href="#MQTT-协议-5-0中文版" class="headerlink" title="MQTT 协议 5.0中文版"></a>MQTT 协议 5.0中文版</h1><hr>
<pre><code>委员会规范草案 02 
公开评审草案 02
2017年10月26日</code></pre><ul>
<li><p>规范链接</p>
<ul>
<li>当前版本:<ul>
<li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.docx" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.docx</a> (Authoritative)</li>
<li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.html</a></li>
<li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.pdf" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.pdf</a></li>
</ul>
</li>
<li>以前的版本:<ul>
<li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.docx" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.docx</a> (Authoritative)</li>
<li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.html</a></li>
<li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.pdf" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.pdf</a></li>
</ul>
</li>
<li>最新版本:<ul>
<li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.docx" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.docx</a> (Authoritative)</li>
<li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html</a></li>
<li><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.pdf" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.pdf</a></li>
</ul>
</li>
</ul>
</li>
<li><p>技术委员会:<br><code>OASIS Message Queuing Telemetry Transport (MQTT) TC</code></p>
<ul>
<li>主席:</li>
<li>Brian Raymor (<a href="mailto:brian.raymor@microsoft.com" target="_blank" rel="noopener">brian.raymor@microsoft.com</a>), Microsoft</li>
<li>Richard Coppen (<a href="mailto:coppen@uk.ibm.com" target="_blank" rel="noopener">coppen@uk.ibm.com</a>), IBM</li>
<li>编辑:</li>
<li>Andrew Banks (<a href="mailto:andrew_banks@uk.ibm.com" target="_blank" rel="noopener">andrew_banks@uk.ibm.com</a>), IBM</li>
<li>Ed Briggs (<a href="mailto:edbriggs@microsoft.com" target="_blank" rel="noopener">edbriggs@microsoft.com</a>), Microsoft</li>
<li>Ken Borgendale (<a href="mailto:kwb@us.ibm.com" target="_blank" rel="noopener">kwb@us.ibm.com</a>), IBM</li>
<li>Rahul Gupta (<a href="mailto:rahul.gupta@us.ibm.com" target="_blank" rel="noopener">rahul.gupta@us.ibm.com</a>), IBM</li>
</ul>
</li>
<li><p>相关文档:</p>
<ul>
<li>本规范代替:</li>
<li>MQTT协议3.1.1版本. 编辑是Andrew Banks和Rahul Gupta, 发布于2014年10月29日, OASIS标准:<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a>.</li>
</ul>
</li>
<li><p>本规范与此有关:</p>
<ul>
<li>MQTT 和 NIST 网络安全框架 1.0 版. 编辑是Geoff Brown和Louis-Philippe Lamoureux.最新版本:<a href="http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html</a>.</li>
</ul>
</li>
<li><p>摘要:</p>
<ul>
<li>MQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议. 它的设计思想是轻巧、开放、简单、规范, 因此易于实现. 这些特点使得它对很多场景来说都是很好的选择, 包括受限的环境如<code>机器与机器的通信(M2M)</code>以及<code>物联网环境(IoT)</code>, 这些场景要求很小的代码封装或者网络带宽非常昂贵.</li>
<li>本协议运行在TCP/IP, 或其他提供了有序、可靠、双向连接的网络连接上. 它有以下特点:</li>
<li>使用发布/订阅消息模式, 提供了一对多的消息分发和应用之间的解耦.</li>
<li>消息传输不需要知道负载内容.</li>
<li>提供三种等级的服务质量:<ul>
<li>“<code>最多一次</code>”, 尽操作环境所能提供的最大努力分发消息. 消息可能会丢失. 例如, 这个等级可用于环境传感器数据, 单次的数据丢失没关系, 因为不久之后会再次发送.</li>
<li>“<code>至少一次</code>”, 保证消息可以到达, 但是可能会重复.</li>
<li>“<code>仅一次</code>”, 保证消息只到达一次. 例如, 这个等级可用在一个计费系统中, 这里如果消息重复或丢失会导致不正确的收费.</li>
</ul>
</li>
<li>很小的传输消耗和协议数据交换, 最大限度减少网络流量.</li>
<li>异常连接断开发生时, 能通知到相关各方.</li>
</ul>
</li>
<li><p>状态:</p>
<ul>
<li>本文档最后由OASIS成员在上面标示的日期最终修订或批准. 批准的级别也在上面列出了. 如果要查看本文档最新的修订版请检查上面的 最新版本位置. 技术委员会产生的其他修订版和其他技术文档都列在这里:<a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt#technical" target="_blank" rel="noopener">https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt#technical</a> .</li>
<li>技术委员会成员对本规范的评论应该发送到技术委员会的邮件列表. 其他人应该发送评论到技术委员会的公共评论列表, 方法是点击技术委员会网站的发送评论按钮, 网页地址是<a href="https://www.oasis-open.org/committees/mqtt/" target="_blank" rel="noopener">https://www.oasis-open.org/committees/mqtt/</a> .</li>
<li>本规范草案的发布基于OASIS 知识产权政策的Non-Assertion模式. 关于实现本规范必不可少的任何专利是否已公开, 以及其他的专利许可条款相关的信息, 请参考技术委员会网站的知识产权部分 (<a href="https://www.oasis-open.org/committees/mqtt/ipr.php" target="_blank" rel="noopener">https://www.oasis-open.org/committees/mqtt/ipr.php</a>).</li>
<li>请注意, 为本产品声明的任何机器可读内容(计算机语言定义)单独提供纯文本文件. 对于产品叙述文档中出现的任何不一致, 以纯文本文档为准.</li>
</ul>
</li>
<li><p>引用格式:</p>
<ul>
<li><p>引用此规范时应该使用下面的引文格式:</p>
</li>
<li><p>[mqtt-v5.0]</p>
<p>MQTT Version 5.0. Edited by Andrew Banks, Ed Briggs, Ken Borgendale, and Rahul Gupta. 26 October 2017. OASIS Committee Specification Draft 02</p>
<ul>
<li>Public Review Draft 02. <a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd02/mqtt-v5.0-csprd02.html</a>.</li>
<li>Latest version: <a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html</a>.</li>
</ul>
</li>
</ul>
</li>
<li><p>文档链接</p>
<ul>
<li><a href="https://github.com/hui6075/mqtt_v5" target="_blank" rel="noopener">MQTT v5.0草案公开审阅版中文翻译项目</a></li>
<li><a href="https://github.com/hui6075/mqtt_v5/tree/master/protocol/mqtt-v5.0-zh_cn.pdf" target="_blank" rel="noopener">MQTT v5.0草案公开审阅版中文版PDF</a></li>
</ul>
</li>
<li><p>修订记录</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">版本</th>
<th align="left">日期</th>
<th align="left">发布说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0.0.1</td>
<td align="left">2018-05-18</td>
<td align="left">发布全部文本, 完成初步审校, 公开发布第一版</td>
</tr>
</tbody></table>
<p>- 关于译者<br>- <a href="https://github.com/hui6075" target="_blank" rel="noopener">GitHub</a><br>- Email</p>
<ul>
<li>注意<ul>
<li>Copyright © OASIS Open 2017. All Rights Reserved.<br>All capitalized terms in the following text have the meanings assigned to them in the OASIS Intellectual Property Rights Policy (the “OASIS IPR Policy”). The full Policy may be found at the OASIS website.</li>
<li>This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published, and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this section are included on all such copies and derivative works. However, this document itself may not be modified in any way, including by removing the copyright notice or references to OASIS, except as needed for the purpose of developing any document or deliverable produced by an OASIS Technical Committee (in which case the rules applicable to copyrights, as set forth in the OASIS IPR Policy, must be followed) or as required to translate it into languages other than English.</li>
<li>The limited permissions granted above are perpetual and will not be revoked by OASIS or its successors or assigns.</li>
<li>This document and the information contained herein is provided on an “AS IS” basis and OASIS DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</li>
<li>OASIS requests that any OASIS Party or any other party that believes it has patent claims that would necessarily be infringed by implementations of this OASIS Committee Specification or OASIS Standard, to notify OASIS TC Administrator and provide an indication of its willingness to grant patent licenses to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification.</li>
<li>OASIS invites any party to contact the OASIS TC Administrator if it is aware of a claim of ownership of any patent claims that would necessarily be infringed by implementations of this specification by a patent holder that is not willing to provide a license to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification. OASIS may include such claims on its website, but disclaims any obligation to do so.</li>
<li>OASIS takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on OASIS’ procedures with respect to rights in any document or deliverable produced by an OASIS Technical Committee can be found on the OASIS website. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this OASIS Committee Specification or OASIS Standard, can be obtained from the OASIS TC Administrator. OASIS makes no representation that any information or list of intellectual property rights will at any time be complete, or that any claims in such list are, in fact, Essential Claims.</li>
<li>The name “OASIS” is a trademark of OASIS, the owner and developer of this specification, and should be used only to refer to the organization and its official outputs. OASIS welcomes reference to, and implementation and use of, specifications, while reserving the right to enforce its marks against misleading uses. Please see <a href="https://www.oasis-open.org/policies-guidelines/trademark" target="_blank" rel="noopener">https://www.oasis-open.org/policies-guidelines/trademark</a> for above guidance.</li>
</ul>
</li>
</ul>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-0-知识产权政策"><a href="#1-0-知识产权政策" class="headerlink" title="1.0 知识产权政策"></a>1.0 知识产权政策</h3><pre><code>此公开评审草案的发布基于OASIS IPR Policy的Non-Assertion模式. 
关于实现本规范必不可少的任何专利是否已公开, 以及其他的专利许可条款相关的信息, 请参考技术委员会网站的知识产权部分(https://www.oasis-open.org/committees/mqtt/ipr.php).</code></pre><h3 id="1-1-MQTT协议的组织结构"><a href="#1-1-MQTT协议的组织结构" class="headerlink" title="1.1 MQTT协议的组织结构"></a>1.1 MQTT协议的组织结构</h3><ul>
<li>本规范分为七个章节:<ul>
<li><a href="https://www.zybuluo.com/khan-lau/note/1325300#1-概述" target="_blank" rel="noopener">第一章 - 介绍</a></li>
<li><a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章 - MQTT控制报文格式</a></li>
<li><a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章 - MQTT控制报文</a></li>
<li><a href="https://www.zybuluo.com/khan-lau/note/1325300#4-操作行为" target="_blank" rel="noopener">第四章 - 操作行为</a></li>
<li><a href="https://www.zybuluo.com/khan-lau/note/1325300#5-安全非规范" target="_blank" rel="noopener">第五章 - 安全</a></li>
<li><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">第六章 - 使用Websocket作为网络传输层</a></li>
<li><a href="https://www.zybuluo.com/khan-lau/note/1325300#7-一致性" target="_blank" rel="noopener">第七章 - 一致性目标</a></li>
</ul>
</li>
</ul>
<h3 id="1-2-术语"><a href="#1-2-术语" class="headerlink" title="1.2 术语"></a>1.2 术语</h3><p>本规范中用到的关键字 <code>必须</code> <code>MUST</code>, <code>不能</code> <code>MUST NOT</code>, <code>要求</code> <code>REQUIRED</code>, <code>将会</code> <code>SHALL</code>, <code>不会</code> <code>SHALL NOT</code>, <code>应该</code> <code>SHOULD</code>, <code>不应该</code> <code>SHOULD NOT</code>, <code>推荐</code> <code>RECOMMENDED</code>, <code>可以</code> <code>MAY</code>, <code>可选</code> <code>OPTIONAL</code>都是按照<code>IETF RFC 2119 [RFC2119]</code> 中的描述解释.</p>
<ul>
<li>网络连接(Network Connection):<ul>
<li>MQTT使用的底层传输协议基础设施.</li>
<li>客户端使用它连接服务端.</li>
<li>它提供有序的、可靠的、双向字节流传输.</li>
<li>例子见<a href="https://www.zybuluo.com/khan-lau/note/1325300#42-网络连接" target="_blank" rel="noopener">4.2节</a>.</li>
</ul>
</li>
<li>应用消息(Application Message):<ul>
<li>MQTT协议通过网络传输应用数据.应用消息通过MQTT传输时, 它们有关联的服务质量(QoS)和主题(Topic).</li>
</ul>
</li>
<li>客户端(Client):<ul>
<li>使用MQTT的程序或设备.客户端总是通过网络连接到服务端. 它可以:</li>
<li>打开连接到服务端的网络连接</li>
<li>发布应用消息给其他相关的客户端</li>
<li>订阅以请求接受相关的应用消息</li>
<li>取消订阅以移除接受相应消息的请求</li>
<li>关闭连接到服务端的网络连接</li>
</ul>
</li>
<li>服务端(Server):<ul>
<li>一个程序或设备, 作为发送消息的客户端和请求订阅的客户端之间的中介. 服务端:</li>
<li>接受来自客户端的网络连接</li>
<li>接受客户端发布的应用消息</li>
<li>处理客户端的订阅和取消订阅请求</li>
<li>转发应用消息给符合条件的客户端订阅</li>
<li>关闭来自客户端的网络连接</li>
</ul>
</li>
<li>会话(Session):<ul>
<li>客户端和服务端之间的状态交互.一些会话持续时长与网络连接一样, 另一些可以在客户端和服务端的多个连续网络连接间扩展.</li>
</ul>
</li>
<li>订阅(Subscription):<ul>
<li>订阅包含一个<code>主题过滤器(Topic Filter)</code>和一个最大的<code>服务质量(QoS)</code>等级. 订阅与单个<code>会话(Session)</code>关联.会话可以包含多于一个的订阅. 会话的每个订阅都有一个不同的主题过滤器.</li>
</ul>
</li>
<li>共享订阅(Shared Subscription):<ul>
<li>一个共享订阅包含一个<code>主题过滤器(Topic Filter)</code>和一个最大的<code>服务质量(QoS)</code>等级. 一个共享订阅可以与多个订阅会话相关联, 便于支持大范围消息交换模式. 一条主题匹配的应用消息只发送给关联到此共享订阅的多个会话中的一个会话. 一个会话可以包括多个共享订阅, 可以同时包含共享订阅与非共享订阅.</li>
</ul>
</li>
<li>通配符订阅(Wildcard Subscription):<ul>
<li>通配符订阅是指<code>主题过滤器(Topic Filter)</code>包含一个或多个通配符的订阅.通配符订阅使得一次订阅匹配多个<code>主题名(Topic Name)</code>. <a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> 描述了主题过滤器中的通配符.</li>
</ul>
</li>
<li>主题名(Topic Name):<ul>
<li>附加在应用消息上的一个标签, 服务端已知且与订阅匹配. 服务端发送应用消息的一个副本给每一个匹配的客户端订阅.</li>
</ul>
</li>
<li>主题过滤器(Topic Filter):<ul>
<li>订阅中包含的一个表达式, 用于表示相关的一个或多个主题.主题过滤器可以使用通配符.</li>
</ul>
</li>
<li>MQTT控制报文(MQTT Control Packet):<ul>
<li>通过网络连接发送的信息数据包. MQTT 规范定义了十四种不同类型的MQTT控制报文, 其中一个(<code>PUBLISH</code> 报文)用于传输应用消息.</li>
</ul>
</li>
<li>无效报文(Malformed Packet):<ul>
<li>根据规范不能被正确解析的控制报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 描述了如何进行相应的错误处理.</li>
</ul>
</li>
<li>协议错误(Protocol Error):<ul>
<li>在报文解析之后发现包含协议不允许或与客户端或服务端当前状态不一致的数据的错误. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 描述了如何进行相应的错误处理.</li>
</ul>
</li>
<li>遗嘱消息(Will Message):<ul>
<li>在网络连接非正常关闭的情况下, 由服务端发布的应用消息. <a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a> 描述了遗嘱消息.</li>
</ul>
</li>
</ul>
<h3 id="1-3-规范引用"><a href="#1-3-规范引用" class="headerlink" title="1.3 规范引用"></a>1.3 规范引用</h3><ul>
<li>[RFC2119]<ul>
<li>Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <a href="http://www.rfc-editor.org/info/rfc2119" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc2119</a></li>
</ul>
</li>
<li>[RFC3629]<br>-Yergeau, F., “UTF-8, a transformation format of ISO 10646”, STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <a href="http://www.rfc-editor.org/info/rfc3629" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc3629</a></li>
<li>[RFC6455]<ul>
<li>Fette, I. and A. Melnikov, “The WebSocket Protocol”, RFC 6455, DOI 10.17487/RFC6455, December 2011, <a href="http://www.rfc-editor.org/info/rfc6455" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6455</a></li>
</ul>
</li>
<li>[Unicode]<ul>
<li>The Unicode Consortium. The Unicode Standard, <a href="http://www.unicode.org/versions/latest/" target="_blank" rel="noopener">http://www.unicode.org/versions/latest/</a></li>
</ul>
</li>
</ul>
<h3 id="1-4-非规范引用"><a href="#1-4-非规范引用" class="headerlink" title="1.4 非规范引用"></a>1.4 非规范引用</h3><ul>
<li>[RFC0793]<ul>
<li>Postel, J., “Transmission Control Protocol”, STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <a href="http://www.rfc-editor.org/info/rfc793" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc793</a></li>
</ul>
</li>
<li>[RFC5246]<ul>
<li>Dierks, T. and E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.2”, RFC 5246, DOI 10.17487/RFC5246, August 2008, <a href="http://www.rfc-editor.org/info/rfc5246" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc5246</a></li>
</ul>
</li>
<li>[AES]<ul>
<li>Advanced Encryption Standard (AES) (FIPS PUB 197). <a href="https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf" target="_blank" rel="noopener">https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf</a></li>
</ul>
</li>
<li>[CHACHA20]<ul>
<li>ChaCha20 and Poly1305 for IETF Protocols, <a href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7539</a></li>
</ul>
</li>
<li>[FIPS1402]<ul>
<li>Security Requirements for Cryptographic Modules (FIPS PUB 140-2), <a href="https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf" target="_blank" rel="noopener">https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf</a></li>
</ul>
</li>
<li>[IEEE 802.1AR]<ul>
<li>IEEE Standard for Local and metropolitan area networks - Secure Device Identity, <a href="http://standards.ieee.org/findstds/standard/802.1AR-2009.html" target="_blank" rel="noopener">http://standards.ieee.org/findstds/standard/802.1AR-2009.html</a></li>
</ul>
</li>
<li>[ISO29192]<ul>
<li>ISO/IEC 29192-1:2012 Information technology – Security techniques – Lightweight cryptography – Part 1: General, <a href="https://www.iso.org/standard/56425.html" target="_blank" rel="noopener">https://www.iso.org/standard/56425.html</a></li>
</ul>
</li>
<li>[MQTT NIST]<ul>
<li>MQTT supplemental publication, MQTT and the NIST Framework for Improving Critical Infrastructure Cybersecurity, <a href="http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html</a></li>
</ul>
</li>
<li>[MQTTV311]<ul>
<li>MQTT V3.1.1 Protocol Specification, <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></li>
</ul>
</li>
<li>[ISO20922]<ul>
<li>MQTT V3.1.1 ISO Standard (ISO/IEC 20922:2016), <a href="https://www.iso.org/standard/69466.html" target="_blank" rel="noopener">https://www.iso.org/standard/69466.html</a></li>
</ul>
</li>
<li>[NISTCSF]<ul>
<li>Improving Critical Infrastructure Cybersecurity Executive Order 13636, <a href="https://www.nist.gov/sites/default/files/documents/itl/preliminary-cybersecurity-framework.pdf" target="_blank" rel="noopener">https://www.nist.gov/sites/default/files/documents/itl/preliminary-cybersecurity-framework.pdf</a></li>
</ul>
</li>
<li>[NIST7628]<ul>
<li>NISTIR 7628 Guidelines for Smart Grid Cyber Security Catalogue, <a href="https://www.nist.gov/sites/default/files/documents/smartgrid/nistir-7628_total.pdf" target="_blank" rel="noopener">https://www.nist.gov/sites/default/files/documents/smartgrid/nistir-7628_total.pdf</a></li>
</ul>
</li>
<li>[NSAB]<ul>
<li>NSA Suite B Cryptography, <a href="http://www.nsa.gov/ia/programs/suiteb_cryptography/" target="_blank" rel="noopener">http://www.nsa.gov/ia/programs/suiteb_cryptography/</a></li>
</ul>
</li>
<li>[PCIDSS]<ul>
<li>PCI-DSS Payment Card Industry Data Security Standard, <a href="https://www.pcisecuritystandards.org/pci_security/" target="_blank" rel="noopener">https://www.pcisecuritystandards.org/pci_security/</a></li>
</ul>
</li>
<li>[RFC1928]<ul>
<li>Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, “SOCKS Protocol Version 5”, RFC 1928, DOI 10.17487/RFC1928, March 1996, <a href="http://www.rfc-editor.org/info/rfc1928" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc1928</a></li>
</ul>
</li>
<li>[RFC4511]<ul>
<li>Sermersheim, J., Ed., “Lightweight Directory Access Protocol (LDAP): The Protocol”, RFC 4511, DOI 10.17487/RFC4511, June 2006, <a href="http://www.rfc-editor.org/info/rfc4511" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc4511</a></li>
</ul>
</li>
<li>[RFC5280]<ul>
<li>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, “Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile”, RFC 5280, DOI 10.17487/RFC5280, May 2008, <a href="http://www.rfc-editor.org/info/rfc5280" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc5280</a></li>
</ul>
</li>
<li>[RFC6066]<ul>
<li>Eastlake 3rd, D., “Transport Layer Security (TLS) Extensions: Extension Definitions”, RFC 6066, DOI 10.17487/RFC6066, January 2011, <a href="http://www.rfc-editor.org/info/rfc6066" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6066</a></li>
</ul>
</li>
<li>[RFC6749]<ul>
<li>Hardt, D., Ed., “The OAuth 2.0 Authorization Framework”, RFC 6749, DOI 10.17487/RFC6749, October 2012, <a href="http://www.rfc-editor.org/info/rfc6749" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6749</a></li>
</ul>
</li>
<li>[RFC6960]<ul>
<li>Santesson, S., Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, “X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP”, RFC 6960, DOI 10.17487/RFC6960, June 2013, <a href="http://www.rfc-editor.org/info/rfc6960" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6960</a></li>
</ul>
</li>
<li>[SARBANES]<ul>
<li>Sarbanes-Oxley Act of 2002.<br><a href="http://www.gpo.gov/fdsys/pkg/PLAW-107publ204/html/PLAW-107publ204.htm" target="_blank" rel="noopener">http://www.gpo.gov/fdsys/pkg/PLAW-107publ204/html/PLAW-107publ204.htm</a></li>
</ul>
</li>
<li>[USEUPRIVSH]<ul>
<li>U.S.-EU Privacy Shield Framework, <a href="https://www.privacyshield.gov/" target="_blank" rel="noopener">https://www.privacyshield.gov</a></li>
</ul>
</li>
<li>[RFC3986]<ul>
<li>Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax”, STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <a href="http://www.rfc-editor.org/info/rfc3986" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc3986</a></li>
</ul>
</li>
<li>[RFC1035]<ul>
<li>Mockapetris, P., “Domain names - implementation and specification”, STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987, <a href="http://www.rfc-editor.org/info/rfc1035" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc1035</a></li>
</ul>
</li>
<li>[RFC2782]<ul>
<li>Gulbrandsen, A., Vixie, P., and L. Esibov, “A DNS RR for specifying the location of services (DNS SRV)”, RFC 2782, DOI 10.17487/RFC2782, February 2000, <a href="http://www.rfc-editor.org/info/rfc2782" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc2782</a></li>
</ul>
</li>
</ul>
<h3 id="1-5-数据表示"><a href="#1-5-数据表示" class="headerlink" title="1.5 数据表示"></a>1.5 数据表示</h3><h4 id="1-5-1-二进制位"><a href="#1-5-1-二进制位" class="headerlink" title="1.5.1 二进制位"></a>1.5.1 二进制位</h4><p>字节中的位从0到7. <code>第7位</code>是<code>最高有效位</code>, <code>第0位</code>是<code>最低有效位</code>.</p>
<h4 id="1-5-2-双字节整数"><a href="#1-5-2-双字节整数" class="headerlink" title="1.5.2 双字节整数"></a>1.5.2 双字节整数</h4><p><code>双字节整数</code>是 16 位, 使用<code>大端序(big-endian, 高位字节在低位字节前面)</code>. 这意味着一个 16 位的字在网络上表示为最高有效字节(MSB), 后面跟着最低有效字节(LSB).</p>
<h4 id="1-5-3-四字节整数"><a href="#1-5-3-四字节整数" class="headerlink" title="1.5.3 四字节整数"></a>1.5.3 四字节整数</h4><p><code>四字节整数</code>是32位, 使用<code>大端序(big-endian, 高位字节在低位字节前面)</code>. 这意味着一个32位的字在网络上表示为第一个最高有效字节(MSB)后面跟着第一个最低有效字节(LSB), 再后面为第二个最高有效字节(MSB)后面跟着第二个最低有效字节(LSB).</p>
<h4 id="1-5-4-UTF-8-编码字符串"><a href="#1-5-4-UTF-8-编码字符串" class="headerlink" title="1.5.4 UTF-8 编码字符串"></a>1.5.4 UTF-8 编码字符串</h4><p>后续描述的MQTT控制报文中的文本字段编码为 <code>UTF-8 格式</code>的字符串. UTF-8 [RFC3629] 是一个高效的Unicode 字符编码格式, 为了支持基于文本的通信, 它对 ASCII 字符的编码做了优化.</p>
<p>每一个字符串都有一个两字节的长度字段作为前缀, 它给出这个字符串 UTF-8 编码的字节数, 它们在图1-1 UTF-8编码字符串的结构中描述. 因此可以传送的UTF-8编码的字符串大小有一个限制, <strong>不能</strong>超过65535字节.</p>
<p>除非另有说明, 所有的 UTF-8 编码字符串的长度都在 0 到 65535 字节这个范围内.</p>
<ul>
<li>图 1-1 UTF-8编码字符串的结构</li>
</ul>
<table>
<thead>
<tr>
<th align="left">二进制位</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">字符串长度的最高有效字节(MSB)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">字符串长度的最低有效字节(LSB)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 3 …</td>
<td align="left">如果长度大于0, 这里是UTF-8编码的字符数据</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<ul>
<li>UTF-8 编码字符串中的字符数据<strong>必须</strong>是按照Unicode 规范 [Unicode] 定义的和在RFC3629 [RFC3629]中重申的有效的UTF-8格式. 特别需要指出的是, 这些数据<strong>不能</strong>包含字符码在 U+D800 和 U+DFFF 之间的数据. 如果服务端或客户端收到了一个包含无效 <code>UTF-8</code> 字符的<code>MQTT控制报文</code>, 它<strong>必须</strong>关闭网络连接[MQTT-1.5.4-1].</li>
<li>UTF-8 编码的字符串<strong>不能</strong>包含空字符 U+0000[MQTT-1.5.4-2]. 如果客户端或服务端收到了一个包含 U+0000 的控制报文, 它<strong>必须</strong>关闭网络连接.</li>
<li>数据中<strong>不应该</strong>包含下面这些 Unicode 代码点的编码. 如果一个接收者(服务端或客户端)收到了包含下列任意字符的MQTT控制报文, 它<strong>可以</strong>把此报文当做无效报文.<ul>
<li>U+0001 和 U+001F 之间的控制字符</li>
<li>U+007F 和 U+009F 之间的控制字符</li>
<li>[Unicode] 规范定义的非字符代码点(例如U+0FFFF)</li>
</ul>
</li>
<li>UTF-8 编码序列 0XEF 0xBB 0xBF 总是被解释为 U+FEFF(零宽度非换行空白字符), 无论它出现在字符串的什么位置, 报文接收者都<strong>不能</strong>跳过或者剥离它 [MQTT-1.5.4-3].</li>
</ul>
<pre><code>- 非规范示例    例如, 字符串 `A𪛔` 是一个大写拉丁字母 A 后面跟着一个`代码点 U+2A6D4` (它表示一个中日韩统一表意文字扩展 B 中的字符), 这个字符串编码如下:</code></pre><ul>
<li>图1-2 UTF-8编码字符串非规范示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left">bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">字符串长度MSB (0x00)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">字符串长度LSB (0x05)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left">‘A’ (0x41)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left">(0xF0)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 5</td>
<td align="left">(0xAA)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 6</td>
<td align="left">(0x9B)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 7</td>
<td align="left">(0x94)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="1-5-5-变长字节整数"><a href="#1-5-5-变长字节整数" class="headerlink" title="1.5.5 变长字节整数"></a>1.5.5 变长字节整数</h4><ul>
<li><code>剩余长度</code>字段使用一个变长字节编码方案, 对小于 128 的值它使用单字节编码. 更大的值按下面的方式处理. 低 7 位有效位用于编码数据, 最高有效位用于指示是否有更多的字节. 因此每个字节可以编码 128 个数值和一个延续位(continuation bit). <code>剩余长度</code>字段最大 4 个字节 [MQTT-1.5.5-1], 如表 1-1 所示.</li>
<li>表 1-1 变长字节整数大小</li>
</ul>
<table>
<thead>
<tr>
<th align="left">字节数</th>
<th align="left">最小值</th>
<th align="left">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">0 (0x00)</td>
<td align="left">127 (0x7F)</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">128 (0x80, 0x01)</td>
<td align="left">16,383 (0xFF, 0x7F)</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">16,384 (0x80, 0x80, 0x01)</td>
<td align="left">2,097,151 (0xFF, 0xFF, 0x7F)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">2,097,152 (0x80, 0x80, 0x80, 0x01)</td>
<td align="left">268,435,455 (0xFF, 0xFF, 0xFF, 0x7F)</td>
</tr>
</tbody></table>
<p>非规范评注<br>非负整数 X 使用变长编码方案的算法如下:</p>
<pre><code>    do    encodedByte = X MOD 128    X = X DIV 128    // if there are more data to encode, set the top bit of this byte    if (X &gt; 0)        encodedByte = encodedByte OR 128    endif    &#39;output&#39; encodedByte    while (X &gt; 0)
MOD是模运算, DIV是整数除法, OR是位操作或(C语言中分别是%, /, |).

- 非规范评注
剩余长度字段的解码算法如下:</code></pre><pre><code>    multiplier = 1    value = 0    do    encodedByte = &#39;next byte from stream&#39;     value += (encodedByte AND 127) * multiplier    if (multiplier &gt; 128*128*128)        throw Error(Malformed Variable Byte Integer)    multiplier *= 128    while ((encodedByte AND 128) != 0)
    AND 是位操作与(C 语言中的&amp;)
    这个算法终止时, value 包含的就是剩余长度的值.</code></pre><h4 id="1-5-6-二进制数据"><a href="#1-5-6-二进制数据" class="headerlink" title="1.5.6 二进制数据"></a>1.5.6 二进制数据</h4><p>二进制数据由一个双字节整数指示其数据长度, 因此, 二进制数据的长度被限制为0到65,535字节.</p>
<h4 id="1-5-7-UTF-8字符串对"><a href="#1-5-7-UTF-8字符串对" class="headerlink" title="1.5.7 UTF-8字符串对"></a>1.5.7 UTF-8字符串对</h4><p><code>UTF-8字符串对</code>由两个UTF-8编码的字符串组成, 用来表示名字-值对, 第一个字符串表示名字, 第二个字符串表示值.</p>
<p>所有的字符串<strong>必须</strong>遵循<code>UTF-8字符串编码</code>规范 [MQTT-1.5.7-1]. 如果接受者(客户端或者服务端)接受到一个字符串对, 然而其编码并不遵循规范, 则此报文为无效报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>描述了错误处理的信息.</p>
<h3 id="1-6-安全"><a href="#1-6-安全" class="headerlink" title="1.6 安全"></a>1.6 安全</h3><p>MQTT客户端和服务端实现应该提供认证、授权和安全通信功能, 如 <a href="https://www.zybuluo.com/khan-lau/note/1325300#5-安全非规范" target="_blank" rel="noopener">第5章</a> 所描述. 强烈建议任何关注于个人身份信息或敏感信息的应用使用这些安全设施.</p>
<h3 id="1-7-编辑约定"><a href="#1-7-编辑约定" class="headerlink" title="1.7 编辑约定"></a>1.7 编辑约定</h3><p>本规范用蓝色文本标识一致性声明, 每个一致性声明都分配了一个这种格式的引用:[MQTT-x.x.x-y].</p>
<h3 id="1-8-变更历史"><a href="#1-8-变更历史" class="headerlink" title="1.8 变更历史"></a>1.8 变更历史</h3><h4 id="1-8-1-MQTT-v3-1-1"><a href="#1-8-1-MQTT-v3-1-1" class="headerlink" title="1.8.1 MQTT v3.1.1"></a>1.8.1 MQTT v3.1.1</h4><ul>
<li>MQTT v3.1.1 是首个OASIS标准版本MQTT [MQTTV311].</li>
<li>MQTT v3.1.1 也是ISO/IEC 20922:2016 [ISO20922] 标准.</li>
</ul>
<h4 id="1-8-2-MQTT-v5-0"><a href="#1-8-2-MQTT-v5-0" class="headerlink" title="1.8.2 MQTT v5.0"></a>1.8.2 MQTT v5.0</h4><ul>
<li>MQTT v5.0 在保持MQTT核心不变的基础上添加了大量的新功能. 这些功能的主要目标如下:<ul>
<li>进一步支持大规模可扩展系统</li>
<li>改进的错误报告Improved error reporting</li>
<li>规范化包括容量探索和请求响应在内的通用模式</li>
<li>包括用户属性在内的可扩展机制</li>
<li>改进性能并支持小型客户端</li>
</ul>
</li>
</ul>
<p><a href="https://www.zybuluo.com/khan-lau/note/1325300#appendix-c-mqtt-v50新特性总结非规范" target="_blank" rel="noopener">附录C</a>对MQTT v5.0的改进做出了总结.</p>
<h2 id="2-MQTT控制报文格式"><a href="#2-MQTT控制报文格式" class="headerlink" title="2 MQTT控制报文格式"></a>2 MQTT控制报文格式</h2><h3 id="2-1-MQTT控制报文结构"><a href="#2-1-MQTT控制报文结构" class="headerlink" title="2.1 MQTT控制报文结构"></a>2.1 MQTT控制报文结构</h3><p>MQTT协议通过交换预定义的 MQTT 控制报文来通信. 这一节描述这些报文的格式.</p>
<p>MQTT控制报文由三部分组成, 按照下图描述的顺序.</p>
<p>图 2 1 - MQTT控制报文的结构</p>
<table>
<thead>
<tr>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Fixed Header固定报头, 所有控制报文都包含</td>
</tr>
<tr>
<td align="left">Variable Header 可变报头, 部分控制报文包含</td>
</tr>
<tr>
<td align="left">Payload 有效载荷, 部分控制报文包含</td>
</tr>
</tbody></table>
<h4 id="2-1-1-固定报头"><a href="#2-1-1-固定报头" class="headerlink" title="2.1.1 固定报头"></a>2.1.1 固定报头</h4><p>如下图所示, 每个MQTT控制报文都包含一个固定报头.</p>
<ul>
<li>图 2-2 - 固定报头的格式</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文的类型</td>
<td align="left">用于指定控制报文类型的标志位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2…</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="2-1-2-MQTT控制报文的类型"><a href="#2-1-2-MQTT控制报文的类型" class="headerlink" title="2.1.2 MQTT控制报文的类型"></a>2.1.2 MQTT控制报文的类型</h4><p>位置:第<code>1</code>个字节, 二进制位<code>7-4</code>.<br>表示为4位无符号值, 这些值的定义见下表.</p>
<ul>
<li>表 2-1 - MQTT控制报文的类型</li>
</ul>
<table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">值</th>
<th align="left">报文流动方向</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">禁止</td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">CONNECT</td>
<td align="left">1</td>
<td align="left">客户端到服务端</td>
<td align="left">客户端请求连接服务端</td>
</tr>
<tr>
<td align="left">CONNACK</td>
<td align="left">2</td>
<td align="left">服务端到客户端</td>
<td align="left">连接报文确认</td>
</tr>
<tr>
<td align="left">PUBLISH</td>
<td align="left">3</td>
<td align="left">两个方向都允许</td>
<td align="left">发布消息</td>
</tr>
<tr>
<td align="left">PUBACK</td>
<td align="left">4</td>
<td align="left">两个方向都允许</td>
<td align="left"><code>QoS 1</code> 消息发布收到确认</td>
</tr>
<tr>
<td align="left">PUBREC</td>
<td align="left">5</td>
<td align="left">两个方向都允许</td>
<td align="left">发布收到(保证交付第一步)</td>
</tr>
<tr>
<td align="left">PUBREL</td>
<td align="left">6</td>
<td align="left">两个方向都允许</td>
<td align="left">发布释放(保证交付第二步)</td>
</tr>
<tr>
<td align="left">PUBCOMP</td>
<td align="left">7</td>
<td align="left">两个方向都允许</td>
<td align="left"><code>QoS 2</code> 消息发布完成(保证交付第三步)</td>
</tr>
<tr>
<td align="left">SUBSCRIBE</td>
<td align="left">8</td>
<td align="left">客户端到服务端</td>
<td align="left">客户端订阅请求</td>
</tr>
<tr>
<td align="left">SUBACK</td>
<td align="left">9</td>
<td align="left">服务端到客户端</td>
<td align="left">订阅请求报文确认</td>
</tr>
<tr>
<td align="left">UNSUBSCRIBE</td>
<td align="left">10</td>
<td align="left">客户端到服务端</td>
<td align="left">客户端取消订阅请求</td>
</tr>
<tr>
<td align="left">UNSUBACK</td>
<td align="left">11</td>
<td align="left">服务端到客户端</td>
<td align="left">取消订阅报文确认</td>
</tr>
<tr>
<td align="left">PINGREQ</td>
<td align="left">12</td>
<td align="left">客户端到服务端</td>
<td align="left">心跳请求</td>
</tr>
<tr>
<td align="left">PINGRESP</td>
<td align="left">13</td>
<td align="left">服务端到客户端</td>
<td align="left">心跳响应</td>
</tr>
<tr>
<td align="left">DISCONNECT</td>
<td align="left">14</td>
<td align="left">两个方向都允许</td>
<td align="left">断开连接通知</td>
</tr>
<tr>
<td align="left">AUTH</td>
<td align="left">15</td>
<td align="left">两个方向都允许</td>
<td align="left">认证信息交换</td>
</tr>
</tbody></table>
<h4 id="2-1-3-标志"><a href="#2-1-3-标志" class="headerlink" title="2.1.3 标志"></a>2.1.3 标志</h4><p>固定报头第1个字节的剩余的 4 位 [3-0]包含每个 MQTT 控制报文类型特定的标志如下表所示. 表格中任何标记为“保留”的标志位, 都是保留给以后使用的, <strong>必须</strong>设置为表格中列出的值 [MQTT-2.1.3-1]. 如果收到非法的标志, 此报文被当做无效报文. 有关错误处理的详细信息见<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p>
<ul>
<li>表格 2-2 - 标志位</li>
</ul>
<table>
<thead>
<tr>
<th align="left">MQTT控制报文</th>
<th align="left">固定报头标志</th>
<th align="left">Bit 3</th>
<th align="left">Bit 2</th>
<th align="left">Bit 1</th>
<th align="left">Bit 0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONNECT</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">CONNACK</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PUBLISH</td>
<td align="left">Used in MQTT v5.0</td>
<td align="left">DUP</td>
<td align="left">QOS</td>
<td align="left">RETAIN</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">PUBACK</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PUBREC</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PUBREL</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PUBCOMP</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SUBSCRIBE</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SUBACK</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">UNSUBSCRIBE</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">UNSUBACK</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PINGREQ</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PINGRESP</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">DISCONNECT</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">AUTH</td>
<td align="left">Reserved</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<ul>
<li>DUP = PUBLISH报文的重复分发标志</li>
<li>QoS = PUBLISH报文的服务质量等级</li>
<li>RETAIN = PUBLISH报文的保留标志</li>
<li>PUBLISH报文中的DUP、QoS和RETAIN标志的描述见<a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">3.3.1节</a>.</li>
</ul>
<h4 id="2-1-4-剩余长度"><a href="#2-1-4-剩余长度" class="headerlink" title="2.1.4 剩余长度"></a>2.1.4 剩余长度</h4><p>位置:从第 2 个字节开始.</p>
<p><code>剩余长度(Remaining Length)</code>是一个变长字节整数, 用来表示当前控制报文剩余部分的字节数, 包括可变报头和负载的数据. 剩余长度不包括用于编码剩余长度字段本身的字节数. MQTT控制报文总长度等于固定报头的长度加上剩余长度.</p>
<h3 id="2-2-可变报头"><a href="#2-2-可变报头" class="headerlink" title="2.2 可变报头"></a>2.2 可变报头</h3><p>某些MQTT控制报文包含一个可变报头部分. 它在固定报头和有效载荷之间. 可变报头的内容根据报文类型的不同而不同. 可变报头的<code>报文标识符(Packet Identifier)</code>字段存在于在多个类型的报文里.</p>
<h4 id="2-2-1-报文标识符"><a href="#2-2-1-报文标识符" class="headerlink" title="2.2.1 报文标识符"></a>2.2.1 报文标识符</h4><p>部分类型MQTT控制报文的可变报头部分包含了2个字节的报文标识符字段. 这些MQTT控制报文类型为:<code>PUBLISH</code>报文(当QoS&gt;0时), <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBSCRIBE</code>, <code>SUBACK</code>, <code>UNSUBSCRIBE</code>, <code>UNSUBACK.</code></p>
<p>需要报文标识符的MQTT控制报文如下表所示.</p>
<ul>
<li>表 2-3 包含报文标识符的MQTT控制报文</li>
</ul>
<table>
<thead>
<tr>
<th align="left">MQTT控制报文</th>
<th align="left">报文标识符字段</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONNECT</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">CONNACK</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">PUBLISH</td>
<td align="left">需要(如果QoS &gt; 0)</td>
</tr>
<tr>
<td align="left">PUBACK</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">PUBREC</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">PUBREL</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">PUBCOMP</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">SUBSCRIBE</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">SUBACK</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">UNSUBSCRIBE</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">UNSUBACK</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">PINGREQ</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">PINGRESP</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">DISCONNECT</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">AUTH</td>
<td align="left">不需要</td>
</tr>
</tbody></table>
<p>- <code>QoS</code>设置为0的<code>PUBLISH</code>报文<strong>不能</strong>包含报文标识符[MQTT-2.2.1-2].</p>
<ul>
<li>客户端每次发送一个新的SUBSCRIBE, <code>UNSUBSCRIBE</code>或者<code>PUBLISH</code>(当QoS&gt;0时)MQTT控制报文时都<strong>必须</strong>分配一个当前未使用的非零报文标识符 [MQTT-2.2.1-3].</li>
<li>服务端每次发送一个新的PUBLISH(当QoS&gt;0)MQTT控制报文时都<strong>必须</strong>分配一个当前未使用的非零报文标识符 [MQTT-2.2.1-4].</li>
<li>当客户端处理完这个报文对应的确认后, 这个报文标识符就释放可重用. <code>QoS 1</code>的<code>PUBLISH</code>对应的是<code>PUBACK</code>, <code>QoS 2</code>的<code>PUBLISH</code>对应的是包含原因码128以上的<code>PUBCOMP</code>或<code>PUBREC</code>, 与<code>SUBSCRIBE</code>或<code>UNSUBSCRIBE</code>对应的分别是<code>SUBACK</code>或<code>UNSUBACK</code>.</li>
<li><code>PUBLISH</code>, <code>SUBSCRIBE</code>和<code>UNSUBSCRIBE</code>的报文标识符, 在一次会话中对于客户端和服务端来说分属于不同的组. 某个报文标识符在某一时刻<strong>不能</strong>被多个命令所使用.</li>
<li><code>PUBACK</code>, <code>PUBREC</code>和<code>PUBREL</code>报文<strong>必须</strong>包含与最初发送的<code>PUBLISH</code>报文相同的报文标识符 [MQTT-2.2.1-5]. 类似地, <code>SUBACK</code>和<code>UNSUBACK</code> <strong>必须</strong> 包含在对应的<code>SUBSCRIBE</code>和<code>UNSUBSCRIBE</code>报文中使用的报文标识符 [MQTT-2.2.1-6].</li>
</ul>
<p>客户端和服务端彼此独立地分配报文标识符. 因此, 客户端服务端组合使用相同的报文标识符可以实现并发的消息交换.</p>
<pre><code>非规范评注
客户端发送标识符为 0x1234 的`PUBLISH`报文, 它有可能会在收到那个报文的`PUBACK`之前, 先收到服务端发送的另一个不同的但是报文标识符也为0x1234的`PUBLISH` 报文.</code></pre><table>
<thead>
<tr>
<th align="left">客户端</th>
<th align="left">服务端</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PUBLISH报文标识符 = 0x1234 —-&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">&lt;—- PUBLISH报文标识符 = 0x1234</td>
</tr>
<tr>
<td align="left">PUBACK报文标识符 = 0x1234 —-&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">&lt;—- PUBACK报文标识符 = 0x1234</td>
</tr>
</tbody></table>
<h4 id="2-2-2-属性"><a href="#2-2-2-属性" class="headerlink" title="2.2.2 属性"></a>2.2.2 属性</h4><p><code>CONNECT</code>, <code>CONNACK</code>, <code>PUBLISH</code>, <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBSCRIBE</code>, <code>SUBACK</code>, <code>UNSUBACK</code>, <code>DISCONNECT</code> 和 <code>AUTH</code> 报文可变报头的最后一部分是一组属性. <code>CONNECT</code> 报文的<code>遗嘱(Will)</code>属性字段中也包含了一组可选的属性.</p>
<p><code>属性字段</code>由<code>属性长度</code>和<code>所有属性</code>组成.</p>
<h5 id="2-2-2-1-属性长度"><a href="#2-2-2-1-属性长度" class="headerlink" title="2.2.2.1 属性长度"></a>2.2.2.1 属性长度</h5><p>属性长度被编码为变长字节整数. 属性长度不包含用于编码属性长度自身的字节数, 但包含所有属性的长度. 如果没有任何属性, <strong>必须</strong>由属性长度为零的字段来指示 [MQTT-2.2.2-1].</p>
<h5 id="2-2-2-2-属性"><a href="#2-2-2-2-属性" class="headerlink" title="2.2.2.2 属性"></a>2.2.2.2 属性</h5><h5 id="2-2-2-2-属性-1"><a href="#2-2-2-2-属性-1" class="headerlink" title="2.2.2.2 属性"></a>2.2.2.2 属性</h5><p>一个属性包含一段数据和一个定义了属性用途和数据类型的标识符. 标识符被编码为<code>变长字节整数</code>. 任何控制报文, 如果包含了对于该报文类型无效的标识符, 或者错误类型的数据, 都是无效报文. 收到无效报文时, 服务端或客户端使用包含原因码<code>0x81(无效报文)</code> <code>CONNACK</code>或<code>DISCONNECT</code>报文进行错误处理, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 标识符排序不分先后.</p>
<ul>
<li>表 2-4 属性</li>
</ul>
<table>
<thead>
<tr>
<th align="left">标识符</th>
<th align="left">属性名(用途)</th>
<th align="left">数据类型</th>
<th align="left">报文/遗嘱属性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DEC</td>
<td align="left">HEX</td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0x01</td>
<td align="left">载荷格式说明</td>
<td align="left">字节</td>
<td>PUBLISH, Will Properties</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">0x02</td>
<td align="left">消息过期时间</td>
<td align="left">四字节整数</td>
<td>PUBLISH, Will Properties</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">0x03</td>
<td align="left">内容类型</td>
<td align="left">UTF-8编码字符串</td>
<td>PUBLISH, Will Properties</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">0x08</td>
<td align="left">响应主题</td>
<td align="left">UTF-8编码字符串</td>
<td>PUBLISH, Will Properties</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">0x09</td>
<td align="left">相关数据</td>
<td align="left">二进制数据</td>
<td>PUBLISH, Will Properties</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">0x0B</td>
<td align="left">定义标识符</td>
<td align="left">变长字节整数</td>
<td>PUBLISH, SUBSCRIBE</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">0x11</td>
<td align="left">会话过期间隔</td>
<td align="left">四字节整数</td>
<td>CONNECT, CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">0x12</td>
<td align="left">分配客户标识符</td>
<td align="left">UTF-8编码字符串</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">0x13</td>
<td align="left">服务端保活时间</td>
<td align="left">双字节整数</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">0x15</td>
<td align="left">认证方法</td>
<td align="left">UTF-8编码字符串</td>
<td>CONNECT, CONNACK, AUTH</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">0x16</td>
<td align="left">认证数据</td>
<td align="left">二进制数据</td>
<td>CONNECT, CONNACK, AUTH</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">0x17</td>
<td align="left">请求问题信息</td>
<td align="left">字节</td>
<td>CONNECT</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">0x18</td>
<td align="left">遗嘱延时间隔</td>
<td align="left">四字节整数</td>
<td>Will Properties</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">0x19</td>
<td align="left">请求响应信息</td>
<td align="left">字节</td>
<td>CONNECT</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">0x1A</td>
<td align="left">请求信息</td>
<td align="left">UTF-8编码字符串</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">0x1C</td>
<td align="left">服务端参考</td>
<td align="left">UTF-8编码字符串</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">0x1F</td>
<td align="left">原因字符串</td>
<td align="left">UTF-8编码字符串</td>
<td>CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, UNSUBACK, DISCONNECT, AUTH</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left">0x21</td>
<td align="left">接收最大数量</td>
<td align="left">双字节整数</td>
<td>CONNECT, CONNACK</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left">0x22</td>
<td align="left">主题别名最大长度</td>
<td align="left">双字节整数</td>
<td>CONNECT, CONNACK</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left">0x23</td>
<td align="left">主题别名</td>
<td align="left">双字节整数</td>
<td>PUBLISH</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left">0x24</td>
<td align="left">最大QoS</td>
<td align="left">字节</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left">0x26</td>
<td align="left">用户属性</td>
<td align="left">UTF-8字符串对</td>
<td>CONNECT, CONNACK, PUBLISH, Will Properties, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK, DISCONNECT, AUTH</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left">0x27</td>
<td align="left">最大报文长度</td>
<td align="left">四字节整数</td>
<td>CONNECT, CONNACK</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left">0x28</td>
<td align="left">通配符订阅可用性</td>
<td align="left">字节</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left">0x29</td>
<td align="left">订阅标识符可用性</td>
<td align="left">字节</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left">0x2A</td>
<td align="left">共享订阅可用性</td>
<td align="left">字节</td>
<td>CONNACK</td>
</tr>
</tbody></table>
<pre><code>非规范评注
尽管属性标识符用变长字节整数来表示, 但在此版本协议中, 所有的标识符均由一个字节来表示.</code></pre><h3 id="2-3-有效载荷"><a href="#2-3-有效载荷" class="headerlink" title="2.3 有效载荷"></a>2.3 有效载荷</h3><p>某些MQTT控制报文在报文的最后部分包含一个有效载荷, 这将在<a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章</a>论述. 对于 <code>PUBLISH</code> 来说有效载荷就是应用消息.</p>
<p>表 2-5 包含有效载荷的MQTT控制报文</p>
<table>
<thead>
<tr>
<th align="left">MQTT控制报文</th>
<th align="left">有效载荷</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONNECT</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">CONNACK</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">PUBLISH</td>
<td align="left">可选</td>
</tr>
<tr>
<td align="left">PUBACK</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">PUBREC</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">PUBREL</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">PUBCOMP</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">SUBSCRIBE</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">SUBACK</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">UNSUBSCRIBE</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">UNSUBACK</td>
<td align="left">需要</td>
</tr>
<tr>
<td align="left">PINGREQ</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">PINGRESP</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">DISCONNECT</td>
<td align="left">不需要</td>
</tr>
<tr>
<td align="left">AUTH</td>
<td align="left">不需要</td>
</tr>
</tbody></table>
<h3 id="2-4-原因码"><a href="#2-4-原因码" class="headerlink" title="2.4 原因码"></a>2.4 原因码</h3><p>原因码是一个单字节无符号数, 用来指示一次操作的结果. 小于0x80的原因码指示某次操作成功完成, 通常用0来表示. 大于等于0x80的原因码用来指示操作失败.</p>
<p><code>CONNACK</code>, <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>DISCONNECT</code> 和 <code>AUTH</code> 控制报文的可变报头有一个单字节的原因码. <code>SUBACK</code>和<code>UNSUBACK</code>报文的载荷字段包含一个或多个原因码.</p>
<p>原因码如下表所示.</p>
<ul>
<li>表 2-6 原因码</li>
</ul>
<table>
<thead>
<tr>
<th align="left">原因码</th>
<th align="left">名称</th>
<th align="left">报文</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DEC</td>
<td align="left">HEX</td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">成功</td>
<td>CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, UNSUBACK, AUTH</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">正常断开</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">授权的QoS 0</td>
<td>SUBACK</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0x01</td>
<td align="left">授权的QoS 1</td>
<td>SUBACK</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">0x02</td>
<td align="left">授权的QoS 2</td>
<td>SUBACK</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">0x04</td>
<td align="left">包含遗嘱的断开</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">0x10</td>
<td align="left">无匹配订阅</td>
<td>PUBACK, PUBREC</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">0x11</td>
<td align="left">订阅不存在</td>
<td>UNSUBACK</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">0x18</td>
<td align="left">继续认证</td>
<td>AUTH</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">0x19</td>
<td align="left">重新认证</td>
<td>AUTH</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left">0x80</td>
<td align="left">未指明的错误</td>
<td>CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">129</td>
<td align="left">0x81</td>
<td align="left">无效报文</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">130</td>
<td align="left">0x82</td>
<td align="left">协议错误</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">131</td>
<td align="left">0x83</td>
<td align="left">实现错误</td>
<td>CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">132</td>
<td align="left">0x84</td>
<td align="left">协议版本不支持</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">133</td>
<td align="left">0x85</td>
<td align="left">客户标识符无效</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">134</td>
<td align="left">0x86</td>
<td align="left">用户名密码错误</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">135</td>
<td align="left">0x87</td>
<td align="left">未授权</td>
<td>CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">136</td>
<td align="left">0x88</td>
<td align="left">服务端不可用</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">137</td>
<td align="left">0x89</td>
<td align="left">服务端正忙</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">138</td>
<td align="left">0x8A</td>
<td align="left">禁止</td>
<td>CONNACK</td>
</tr>
<tr>
<td align="left">139</td>
<td align="left">0x8B</td>
<td align="left">服务端关闭中</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">140</td>
<td align="left">0x8C</td>
<td align="left">无效的认证方法</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">141</td>
<td align="left">0x8D</td>
<td align="left">保活超时</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">142</td>
<td align="left">0x8E</td>
<td align="left">会话被接管</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">143</td>
<td align="left">0x8F</td>
<td align="left">主题过滤器无效</td>
<td>SUBACK, UNSUBACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">144</td>
<td align="left">0x90</td>
<td align="left">主题名无效</td>
<td>CONNACK, PUBACK, PUBREC, DISCONNECT</td>
</tr>
<tr>
<td align="left">145</td>
<td align="left">0x91</td>
<td align="left">报文标识符已被占用</td>
<td>PUBACK, PUBREC, SUBACK, UNSUBACK</td>
</tr>
<tr>
<td align="left">146</td>
<td align="left">0x92</td>
<td align="left">报文标识符无效</td>
<td>PUBREL, PUBCOMP</td>
</tr>
<tr>
<td align="left">147</td>
<td align="left">0x93</td>
<td align="left">接收超出最大数量</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">148</td>
<td align="left">0x94</td>
<td align="left">主题别名无效</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">149</td>
<td align="left">0x95</td>
<td align="left">报文过长</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">150</td>
<td align="left">0x96</td>
<td align="left">消息太过频繁</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">151</td>
<td align="left">0x97</td>
<td align="left">超出配额</td>
<td>CONNACK, PUBACK, PUBREC, SUBACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">152</td>
<td align="left">0x98</td>
<td align="left">管理行为</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">153</td>
<td align="left">0x99</td>
<td align="left">载荷格式无效</td>
<td>CONNACK, PUBACK, PUBREC, DISCONNECT</td>
</tr>
<tr>
<td align="left">154</td>
<td align="left">0x9A</td>
<td align="left">不支持保留</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">155</td>
<td align="left">0x9B</td>
<td align="left">不支持的QoS等级</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">156</td>
<td align="left">0x9C</td>
<td align="left">(临时)使用其他服务端</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">157</td>
<td align="left">0x9D</td>
<td align="left">服务端已(永久)移动</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">158</td>
<td align="left">0x9E</td>
<td align="left">不支持共享订阅</td>
<td>SUBACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">159</td>
<td align="left">0x9F</td>
<td align="left">超出连接速率限制</td>
<td>CONNACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">160</td>
<td align="left">0xA0</td>
<td align="left">最大连接时间</td>
<td>DISCONNECT</td>
</tr>
<tr>
<td align="left">161</td>
<td align="left">0xA1</td>
<td align="left">不支持订阅标识符</td>
<td>SUBACK, DISCONNECT</td>
</tr>
<tr>
<td align="left">162</td>
<td align="left">0xA2</td>
<td align="left">不支持通配符订阅</td>
<td>SUBACK, DISCONNECT</td>
</tr>
</tbody></table>
<pre><code>非规范评注
对于原因码0x91(报文标识符已被占用)的处理可以为尝试修复会话、以新会话标志为1重置会话或者判定客户端或服务端实现有缺陷.</code></pre><h2 id="3-MQTT控制报文"><a href="#3-MQTT控制报文" class="headerlink" title="3 MQTT控制报文"></a>3 MQTT控制报文</h2><h3 id="3-1-CONNECT-–-连接请求"><a href="#3-1-CONNECT-–-连接请求" class="headerlink" title="3.1 CONNECT – 连接请求"></a>3.1 CONNECT – 连接请求</h3><p>客户端到服务端的网络连接建立后, 客户端发给服务端的第一个报文<strong>必须</strong>是CONNECT报文 [MQTT-3.1.0-1].</p>
<p>在一个网络连接上, 客户端只能发送一次 <code>CONNECT</code> 报文. 服务端<strong>必须</strong>将客户端发送的第二个 <code>CONNECT</code>报文当作协议违规处理并断开客户端的连接[MQTT-3.1.0-2]. 有关错误处理的信息请查看<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p>
<p>有效载荷包含一个或多个编码的字段. 包括客户端的唯一标识符, Will 主题, Will 消息, 用户名和密码. 除了客户端标识之外, 其它的字段都是可选的, 基于标志位来决定可变报头中是否需要包含这些字段.</p>
<h4 id="3-1-1-CONNECT固定报头"><a href="#3-1-1-CONNECT固定报头" class="headerlink" title="3.1.1 CONNECT固定报头"></a>3.1.1 CONNECT固定报头</h4><ul>
<li>图 3-1 CONNECT报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT 报文类型 (1)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2…</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<pre><code>剩余长度字段
剩余长度等于可变报头的长度加上有效载荷的长度.编码方式为变长字节整数.</code></pre><h4 id="3-1-2-CONNECT可变报头"><a href="#3-1-2-CONNECT可变报头" class="headerlink" title="3.1.2 CONNECT可变报头"></a>3.1.2 CONNECT可变报头</h4><p>CONNECT 报文的可变报头按下列次序包含四个字段:<code>协议名(Protocol Name)</code>, <code>协议级别(Protocol Level)</code>, <code>连接标志(Connect Flags)</code>, <code>保持连接(Keep Alive)</code>和<code>属性(Properties)</code>. <a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 描述了属性(Properties)编码规则.</p>
<h5 id="3-1-2-1-协议名"><a href="#3-1-2-1-协议名" class="headerlink" title="3.1.2.1 协议名"></a>3.1.2.1 协议名</h5><p>图 3 2 - 协议名字节</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">协议名</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 1</td>
<td align="left">长度MSB (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">长度 LSB (4)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left"><code>M</code></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left"><code>Q</code></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 5</td>
<td align="left"><code>T</code></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 6</td>
<td align="left"><code>T</code></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>协议名是表示协议名MQTT 的UTF-8编码的字符串. MQTT规范的后续版本不会改变这个字符串的偏移和长度.</p>
<p>支持多种协议的服务端使用协议名字段判断数据是否为MQTT报文. 协议名<strong>必须</strong>是UTF-8字符串“MQTT”. 如果服务端不愿意接受<code>CONNECT</code>但希望表明其MQTT服务端身份, <strong>可以</strong>发送包含原因码为0x84(不支持的协议版本)的<code>CONNACK</code>报文, 然后<strong>必须</strong>关闭网络连接 [MQTT-3.1.2-1].</p>
<pre><code>非规范评注
数据包检测工具, 例如防火墙, 可以使用协议名来识别 MQTT 流量.</code></pre><h5 id="3-1-2-2-协议版本"><a href="#3-1-2-2-协议版本" class="headerlink" title="3.1.2.2 协议版本"></a>3.1.2.2 协议版本</h5><ul>
<li>图 3-3 协议版本字节</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">协议级别</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 1</td>
<td align="left">版本(5)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>客户端使用一个字节无符号数表示协议修订级别.MQTT v5.0的协议版本字段为5(0x05).</p>
<p>支持多版本MQTT协议的服务端使用协议版本 字段判定客户端正使用的MQTT协议版本. 如果协议版本不是5且服务端不愿意接受此<code>CONNECT</code>报文, <strong>可以</strong>发送包含原因码<code>0x84(不支持的协议版本)</code>的<code>CONNACK</code>报文, 然后<strong>必须</strong>关闭网络连接[MQTT-3.1.2-2].</p>
<h5 id="3-1-2-3-连接标志"><a href="#3-1-2-3-连接标志" class="headerlink" title="3.1.2.3 连接标志"></a>3.1.2.3 连接标志</h5><p>连接标志字节包含一些用于指定 MQTT 连接行为的参数. 它还指出有效载荷中的字段是否存在.<br>- 图 3-4 连接标志位</p>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left">User Name Flag</td>
<td align="left">Password Flag</td>
<td align="left">Will Retain</td>
<td align="left">Will QoS</td>
<td align="left">Clean Start</td>
<td align="left">Reserved</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 8</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>服务端<strong>必须</strong>验证CONNECT报文的保留标志位(第 0 位)是否为 0 [MQTT-3.1.2-3], 如果不为0则此报文为无效报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 给出了错误处理信息.</p>
<h5 id="3-1-2-4-新开始"><a href="#3-1-2-4-新开始" class="headerlink" title="3.1.2.4 新开始"></a>3.1.2.4 新开始</h5><p>位置:连接标志字节的第1位</p>
<p>这个二进制位表明此次连接是一个新的会话还是一个已存在的会话的延续. <a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a> 定义了会话状态.</p>
<p>如果收到<code>新开始(Clean Start)</code>为1的<code>CONNECT</code>报文, 客户端和服务端必须丢弃任何已存在的会话, 并开始一个新的会话 [MQTT-3.1.2-4]. 相应的, <code>CONNACK</code>报文中的会话存在标志设置为0.</p>
<p>如果收到<code>新开始(Clean Start)</code>为0的<code>CONNECT</code>报文, 并且存在一个关联此客户标识符的会话, 服务端必须基于此会话的状态恢复与客户端的通信 [MQTT-3.1.2-5]. 如果收到<code>新开始(Clean Start)</code>为0的<code>CONNECT</code>报文, 并且不存在任何关联此客户标识符的会话, 服务端必须创建一个新的会话 [MQTT-3.1.2-6].</p>
<h5 id="3-1-2-5-遗嘱标志"><a href="#3-1-2-5-遗嘱标志" class="headerlink" title="3.1.2.5 遗嘱标志"></a>3.1.2.5 遗嘱标志</h5><p>位置:连接标志字节的第2位</p>
<p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, 表示遗嘱消息必须已存储在服务端与此客户标识符相关的会话中[MQTT-3.1.2-7]. <code>遗嘱消息(Will Message)</code>包含遗嘱属性, 遗嘱主题和遗嘱载荷字段. 遗嘱必须在网络连接被关闭、遗嘱延时间隔到期或者会话结束之后被发布, 除非服务端收到包含原因码为<code>0x00(正常关闭)</code>的<code>DISCONNECT</code>报文之后删除了<code>遗嘱消息(Will Message)</code>, 或者一个关于此客户标识符的新的网络连接在<code>遗嘱迟发时间(Will Delay Interval)</code>超时之前被创建 [MQTT-3.1.2-8].<br>- 遗嘱发布的条件, 包括但不限于:<br>- 服务端检测到了一个 I/O 错误或者网络故障<br>- 客户端在保持连接(Keep Alive)的时间内未能通讯<br>- 客户端在没有发送包含原因码0x00(正常关闭)的情况下关闭了网络连接<br>- 服务端在没有收到包含原因码0x00(正常关闭)的情况下关闭了网络连接</p>
<p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, <code>遗嘱属性(Will Property)</code>、<code>遗嘱主题(Will Topic)</code>和<code>遗嘱载荷(Will Payload)</code>字段必须存在于报文有效载荷中 [MQTT-3.1.2-9]. 一旦<code>遗嘱消息(Will Message)</code>被发布或者服务端收到包含原因码为<code>0x00(正常关闭)</code>的<code>DISCONNECT</code>报文, <code>遗嘱消息(Will Message)</code>必须从服务端的会话中删除 [MQTT-3.1.2-10].</p>
<p>服务端应该在网络连接断开并且<code>遗嘱迟发时间(Will Delay Interval)</code>到期, 或者会话结束之后立即发<code>布遗嘱消息</code>. 服务端关闭或出错的情况下, 可以在服务重新启动之后发布<code>遗嘱消息(Will Message)</code>. 这种情况下从服务端出错到遗嘱发布之间存在一定的延迟.</p>
<p>关于<code>遗嘱延时间隔(Will Delay Interval)</code>的详细信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3132-遗嘱属性" target="_blank" rel="noopener">3.1.3.2节</a>.</p>
<p>非规范评注<br>通过设置晚于<code>会话过期间隔(Session Expiry Interval)</code>的<code>遗嘱迟发时间(Will Delay Interval)</code>并发送包含原因码<code>0x04(包含遗嘱的断开连接)</code>, 客户端得以发出<code>会话过期(Session Expiry)</code>通告.</p>
<h5 id="3-1-2-6-遗嘱QoS"><a href="#3-1-2-6-遗嘱QoS" class="headerlink" title="3.1.2.6 遗嘱QoS"></a>3.1.2.6 遗嘱QoS</h5><p>位置:连接标志字节的第3、4位</p>
<p>这两个比特指定了发布<code>遗嘱消息(Will Message)</code>时的<code>服务质量(QoS)</code>.</p>
<p>如果<code>遗嘱标志(Will Flag)</code>设置为0, <code>遗嘱服务质量(Will QoS)</code>必须也设置为0(0x00) [MQTT-3.1.2-11].<br>如果<code>遗嘱标志</code>设置为1, <code>遗嘱服务质量</code> <strong>可以</strong>被设置为0(0x00), 1(0x01)或2(0x02) [MQTT-3.1.2-12]. 设置为3(0x03)的报文是无效报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 描述了错误处理信息.</p>
<h5 id="3-1-2-7-遗嘱保留"><a href="#3-1-2-7-遗嘱保留" class="headerlink" title="3.1.2.7 遗嘱保留"></a>3.1.2.7 遗嘱保留</h5><p>位置:连接标志字节的第5位</p>
<p>此位指<code>定遗嘱消息(Will Message)</code>在发布时是否会被保留.</p>
<p>如果<code>遗嘱标志</code>被设置为0, <code>遗嘱保留(Will Retain)</code>标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-13]. 如果<code>遗嘱标志</code>被设置为1时, 如果<code>遗嘱保留</code>被设置为0, 则服务端<strong>必须</strong>将<code>遗嘱消息</code>当做<code>非保留消息</code>发布 [MQTT-3.1.2-14]. 如果<code>遗嘱保留</code>被设置为1, 则服务端<strong>必须</strong>将<code>遗嘱消息</code>当做<code>保留消息</code>发布 [MQTT-3.1.2-15].</p>
<h5 id="3-1-2-8-用户名标志"><a href="#3-1-2-8-用户名标志" class="headerlink" title="3.1.2.8 用户名标志"></a>3.1.2.8 用户名标志</h5><p>位置:连接标志字节的第7位</p>
<p>如果<code>用户名标志(User Name Flag)</code>被设置为0, 有效载荷中<strong>不能</strong>包含用户名字段 [MQTT-3.1.2-16]. 如果<code>用户名标志</code>被设置为0, 有效载荷中<strong>必须</strong>包含用户名字段 [MQTT-3.1.2-17].</p>
<h5 id="3-1-2-9-密码标志"><a href="#3-1-2-9-密码标志" class="headerlink" title="3.1.2.9 密码标志"></a>3.1.2.9 密码标志</h5><p>位置:连接标志字节的第6位</p>
<p>如果<code>密码标志(Password Flag)</code>被设置为0, 有效载荷中<strong>不能</strong>包含密码字段 [MQTT-3.1.2-18]. 如果<code>密码标志</code>被设置为1, 有效载荷中<strong>必须</strong>包含密码字段 [MQTT-3.1.2-19].</p>
<pre><code>非规范评注
相比MQTT v3.1.1, 此版本协议允许在没有用户名的情况下发送密码.  这表明密码除了作为口令之外还可以有其他用途.</code></pre><h5 id="3-1-2-10-保持连接"><a href="#3-1-2-10-保持连接" class="headerlink" title="3.1.2.10 保持连接"></a>3.1.2.10 保持连接</h5><ul>
<li>图 3-5 保持连接字节</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 9</td>
<td align="left">保持连接Keep Alive MSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 10</td>
<td align="left">保持连接Keep Alive LSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><code>保持连接(Keep Alive)</code>使用双字节整数来表示以秒为单位的时间间隔. 它是指在客户端传输完成一个MQTT控制报文的时刻到发送下一个报文的时刻, 两者之间允许空闲的最大时间间隔. 客户端负责保证控制报文发送的时间间隔不超过保持连接的值. 如果没有任何其它的MQTT控制报文可以发送, 客户端<strong>必须</strong>发送一个 <code>PINGREQ</code> 报文 [MQTT-3.1.2-20].</p>
<p>如果服务端返回的<code>CONNACK</code>报文中包含服务端<code>保持连接(Server Keep Alive)</code>, 客户<strong>必须</strong>使用此值代替其发送的<code>保持连接(Keep Alive)</code> [MQTT-3.1.2-21].</p>
<p>不管保持连接的值是多少, 客户端任何时候都<strong>可以</strong>发送<code>PINGREQ</code>报文, 并且使用<code>PINGRESP</code>报文判断网络和服务端的活动状态.</p>
<p>如果保持连接的值非零, 并且服务端在1.5倍的保持连接时间内没有收到客户端的控制报文, <strong>必须</strong>断开客户端的网络连接, 并判定网络连接已断开 [MQTT-3.1.2-22].</p>
<p>客户端发送了<code>PINGREQ</code>报文之后, 如果在合理的时间内仍没有收到<code>PINGRESP</code>报文, 它应该关闭到服务端的网络连接.</p>
<p><code>保持连接(Keep Alive)</code>值为零的结果是关闭<code>保持连接(Keep Alive)</code>机制. 如果<code>保持连接(Keep Alive)</code>值为零, 客户端不必按照任何特定的时间发送MQTT控制报文.</p>
<pre><code>非规范评注
服务端可能因为其他原因断开客户端连接, 比如服务端将要关闭服务.  设置保持连接(Keep Alive)不保证客户端将一直保持连接状态. 

非规范评注
保持连接的实际值是由应用指定的, 一般是几分钟.  允许的最大值是18小时12分15秒.</code></pre><h5 id="3-1-2-11-CONNECT属性"><a href="#3-1-2-11-CONNECT属性" class="headerlink" title="3.1.2.11 CONNECT属性"></a>3.1.2.11 CONNECT属性</h5><h6 id="3-1-2-11-1-属性长度"><a href="#3-1-2-11-1-属性长度" class="headerlink" title="3.1.2.11.1 属性长度"></a>3.1.2.11.1 属性长度</h6><p><code>CONNECT</code>报文可变报头中的<code>属性(Properties)</code>长度被编码为变长字节整数.</p>
<h6 id="3-1-2-11-2-会话过期间隔"><a href="#3-1-2-11-2-会话过期间隔" class="headerlink" title="3.1.2.11.2 会话过期间隔"></a>3.1.2.11.2 会话过期间隔</h6><p>17 (0x11), <code>会话过期间隔(Session Expiry Interval)</code>标识符.<br>跟随其后的是用四字节整数表示的以秒为单位的<code>会话过期间隔(Session Expiry Interval)</code>. 包含多个<code>会话过期间隔(Session Expiry Interval)</code>将造成协议错误(Protocol Error).</p>
<p>如果<code>会话过期间隔(Session Expiry Interval)</code>值未指定, 则使用0. 如果设置为0或者未指定, 会话将在网络连接(Network Connection)关闭时结束.</p>
<p>如果<code>会话过期间隔(Session Expiry Interval)</code>为0xFFFFFFFF (UINT_MAX), 则会话永不过期.</p>
<p>如果网络连接关闭时<code>会话过期间隔(Session Expiry Interval)</code>大于0, 则客户端与服务端必须存储会话状态 [MQTT-3.1.2-23].</p>
<pre><code>非规范评注
客户端或服务端可能会因为中断运行导致会话时钟某些时间未运行.这将导致会话的删除被延迟.</code></pre><p>更多关于会话的信息参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a>. 关于会话存储的状态的详细和限制参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#411-存储会话状态" target="_blank" rel="noopener">4.1.1节</a>.</p>
<p>当会话过期时, 客户端和服务端无需以原子操作的方式删除会话状态.</p>
<pre><code>非规范评注
把新开始(Clean Start)设置为1且`会话过期间隔(Session Expiry Interval)`设置为0, 等同于在MQTT v3.1.1中把清理会话(CleanSession)设置为1. 把新开始(Clean Start)设置为0且不设置会话过期间隔(Session Expiry Interval), 等同于在MQTT v3.1.1中把清理会话标志设置为0.

非规范评注
当希望只处理连接上服务端之后才发布的消息, 客户端应该把新开始(Clean Start)设置为1且会话过期间隔(Session Expiry Interval)设置为0, 这样客户端就不会收到它连接之前被服务端所发布的消息, 并且需要每次连接上服务端时重新订阅其感兴趣的主题.

非规范评注
某些客户端使用的网络可能只能提供断断续续的连接, 这种客户端可以使用较短的会话过期间隔(Session Expiry Interval)以便在网络再次可用后重新连接到服务端时获得持续的消息交付. 如果客户端不再重新连接, 且允许会话过期, 应用消息将会丢失.

非规范评注
某个客户端设置较长的会话过期间隔(Session Expiry Interval)或设置会话不过期, 即要求服务端为其保持会话到其下一次连接上服务端之后. 只有打算在一段时间之后将会重连服务端时, 客户端才应该设置较长的会话过期间隔(Session Expiry Interval). 当客户端认定其将来不会使用本次会话时, 应该在断开时把会话过期间隔(Session Expiry Interval)设置为0.

非规范评注
客户端应当使用CONNACK报文中的会话存在(Session Present)来判定服务端是否存储了其会话.

非规范评注
客户端应当以服务端返回的会话存在(Session Present)标志来判定会话是否已过期, 而不是客户端自己实现的会话过期状态.如果客户端自己实现会话过期状态, 则需要将会话应当被删除的时间作为会话状态的一部分而存储.</code></pre><h6 id="3-1-2-11-3-接收最大值"><a href="#3-1-2-11-3-接收最大值" class="headerlink" title="3.1.2.11.3 接收最大值"></a>3.1.2.11.3 接收最大值</h6><p>33 (0x21), <code>接收最大值(Receive Maximum)</code>标识符.<br>跟随其后的是由双字节整数表示的<code>接收最大值</code>. 包含多个<code>接收最大值</code>或<code>接收最大值</code>为0将造成协议错误(Protocol Error).</p>
<p>客户端使用此值限制客户端愿意同时处理的<code>QoS等级1</code>和<code>QoS等级2</code>的发布消息最大数量. 没有机制可以限制服务端试图发送的<code>QoS为0</code>的发布消息.</p>
<p>接收最大值只将被应用在当前网络连接. 如果没有设置最大接收值, 将使用默认值65535.</p>
<p>关于接收最大值的详细使用, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">4.9节 流控</a>.</p>
<h6 id="3-1-2-11-4-最大报文长度"><a href="#3-1-2-11-4-最大报文长度" class="headerlink" title="3.1.2.11.4 最大报文长度"></a>3.1.2.11.4 最大报文长度</h6><p>39 (0x27), <code>最大报文长度(Maximum Packet Size)</code>标识符.<br>跟随其后的是由四字节整数表示的客户端愿意接收的<code>最大报文长度(Maximum Packet Size)</code>, 如果没有设置<code>最大报文长度(Maximum Packet Size)</code>, 则按照协议由固定报头中的剩余长度可编码最大值和协议报头对数据包的大小做限制.</p>
<p>包含多个<code>最大报文长度(Maximum Packet Size)</code>或者<code>最大报文长度(Maximum Packet Size)</code>值为0将造成协议错误.</p>
<pre><code>非规范评注
客户端如果选择了限制最大报文长度, 应该为最大报文长度设置一个合理的值.</code></pre><p>如<a href="https://www.zybuluo.com/khan-lau/note/1325300#214-剩余长度" target="_blank" rel="noopener">2.1.4节</a> 所述, 最大报文长度是MQTT控制报文的总长度. 客户端使用最大报文长度通知服务端其所能处理的单个报文长度限制.</p>
<p>服务端不能发送超过<code>最大报文长度(Maximum Packet Size)</code>的报文给客户端 [MQTT-3.1.2-24]. 收到长度超过限制的报文将导致协议错误, 客户端发送包含原因码<code>0x95(报文过大)</code>的<code>DISCONNECT</code>报文给服务端, 详见<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p>
<p>当报文过大而不能发送时, 服务端必须丢弃这些报文, 然后当做应用消息发送已完成处理 [MQTT-3.1.2-25].</p>
<p>共享订阅的情况下, 如果一条消息对于部分客户端来说太长而不能发送, 服务端可以选择丢弃此消息或者把消息发送给剩余能够接收此消息的客户端.</p>
<pre><code>非规范评注
服务端可以把那些没有发送就被丢弃的报文放在死信队列上, 或者执行其他诊断操作. 具体的操作超出了本规范的范围.</code></pre><h6 id="3-1-2-11-5-主题别名最大值"><a href="#3-1-2-11-5-主题别名最大值" class="headerlink" title="3.1.2.11.5 主题别名最大值"></a>3.1.2.11.5 主题别名最大值</h6><p>34 (0x22), <code>主题别名最大值(Topic Alias Maximum)</code>标识符.<br>跟随其后的是用双字节整数表示的<code>主题别名最大值(Topic Alias Maximum)</code>. 包含多个<code>主题别名最大值(Topic Alias Maximum)</code>将造成协议错误(Protocol Error). 没有设置主题别名最大值属性的情况下, 主题别名最大值默认为零.</p>
<p>此值指示了客户端能够接收的来自服务端的<code>主题别名(Topic Alias)</code>最大数量. 客户端使用此值来限制本次连接<strong>可以</strong>拥有的主题别名的数量. 服务端在一个<code>PUBLISH</code>报文中发送的主题别名<strong>不能</strong>超过客户端设置的<code>主题别名最大值(Topic Alias Maximum)</code> [MQTT-3.1.2-26]. 值为零表示本次连接客户端不接受任何<code>主题别名(Topic Alias)</code>. 如果<code>主题别名最大值(Topic Alias Maximum)</code>没有设置, 或者设置为零, 则服务端<strong>不能</strong>向此客户端发送任何<code>主题别名(Topic Alias)</code> [MQTT-3.1.2-27].</p>
<h6 id="3-1-2-11-6-请求响应信息"><a href="#3-1-2-11-6-请求响应信息" class="headerlink" title="3.1.2.11.6 请求响应信息"></a>3.1.2.11.6 请求响应信息</h6><p>25 (0x19), <code>请求响应信息(Request Response Information)</code>标识符.<br>跟随其后的是用一个字节表示的0或1. 包含多个<code>请求响应信息(Request Response Information)</code>, 或者<code>请求响应信息(Request Response Information)</code>的值既不为0也不为1会造成协议错误(Protocol Error). 如果没有<code>请求响应信息(Request Response Information)</code>, 则请求响应默认值为0.</p>
<p>客户端使用此值向服务端请求<code>CONNACK</code>报文中的响应信息(Response Information). 值为0, 表示服务端不能返回响应信息 [MQTT-3.1.2-28]. 值为1, 表示服务端可以在<code>CONNACK</code>报文中返回响应信息.</p>
<pre><code>非规范评注
即使客户端请求响应信息(Response Information), 服务端也可以选择不发送响应信息(Response Information).</code></pre><p>更多关于请求/响应信息的内容, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p>
<h6 id="3-1-2-11-7-请求问题信息"><a href="#3-1-2-11-7-请求问题信息" class="headerlink" title="3.1.2.11.7 请求问题信息"></a>3.1.2.11.7 请求问题信息</h6><p>23 (0x17), <code>请求问题信息(Request Problem Information)</code>标识符.<br>跟随其后的是用一个字节表示的0或1. 包含多个<code>请求问题信息(Request Problem Information)</code>, 或者<code>请求问题信息(Request Problem Information)</code>的值既不为0也不为1会造成协议错误(Protocol Error). 如果没有<code>请求问题信息(Request Problem Information)</code>, 则请求问题默认值为1.</p>
<p>客户端使用此值指示遇到错误时是否发送<code>原因字符串(Reason String)</code>或用<code>户属性(User Properties)</code>.</p>
<p>如果<code>请求问题信息</code>的值为0, 服务端可以选择在<code>CONNACK</code>或DISCONNECT报文中返回<code>原因字符串(Reason String)</code>或用<code>户属性(User Properties)</code>, 但不能在除<code>PUBLISH</code>, <code>CONNACK</code>或<code>DISCONNECT</code>之外的报文中发送<code>原因字符串(Reason String)</code>或用<code>户属性(User Properties)</code> [MQTT-3.1.2-29]. 如果此值为0, 并且在除<code>PUBLISH</code>, <code>CONNACK</code>或<code>DISCONNECT</code>之外的报文中收到了<code>原因字符串(Reason String)</code>或<code>用户属性(User Properties)</code>, 客户端将发送一个包含原因码<code>0x82(协议错误)</code>的<code>DISCONNECT</code>报文给服务端, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<p>如果此值为1, 服务端<strong>可以</strong>在任何被允许的报文中返回<code>原因字符串(Reason String)</code>或<code>用户属性(User Properties)</code>.</p>
<h6 id="3-1-2-11-8-用户属性"><a href="#3-1-2-11-8-用户属性" class="headerlink" title="3.1.2.11.8 用户属性"></a>3.1.2.11.8 用户属性</h6><p>38 (0x26), 用<code>户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对.</p>
<p><code>用户属性(User Property)</code>可以出现多次, 表示多个名字/值对. 相同的名字可以出现多次.</p>
<pre><code>非规范评注
CONNECT报文中的用户属性可以被用来发送客户端到服务端的连接相关的属性. 这些属性的意义本规范不做定义.</code></pre><h6 id="3-1-2-11-9-认证方法"><a href="#3-1-2-11-9-认证方法" class="headerlink" title="3.1.2.11.9 认证方法"></a>3.1.2.11.9 认证方法</h6><p>21 (0x15), <code>认证方法(Authentication Method)</code>标识符.<br>跟随其后的是一个UTF-8编码的字符串, 包含了扩展认证的<code>认证方法(Authentication Method)</code>名称. 包含多个认证方法将造成协议错误(协议错误).<br>如果没有认证方法, 则不进行扩展验证. 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p>
<p>如果客户端在<code>CONNECT</code>报文中设置了认证方法, 则客户端在收到<code>CONNACK</code>报文之前<strong>不能</strong>发送除<code>AUTH</code>或<code>DISCONNECT</code>之外的报文 [MQTT-3.1.2-30].</p>
<h6 id="3-1-2-11-10-认证数据"><a href="#3-1-2-11-10-认证数据" class="headerlink" title="3.1.2.11.10 认证数据"></a>3.1.2.11.10 认证数据</h6><p>22 (0x16), <code>认证数据(Authentication Data)</code>标识符.<br>跟随其后的是二进制的认证数据. 没有认证方法却包含了<code>认证数据(Authentication Data)</code>, 或者包含多个<code>认证数据(Authentication Data)</code>将造成协议错误(Protocol Error).</p>
<p>认证数据的内容由认证方法定义, 关于扩展认证的更多信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p>
<h5 id="3-1-2-12-可变报头非规范示例"><a href="#3-1-2-12-可变报头非规范示例" class="headerlink" title="3.1.2.12 可变报头非规范示例"></a>3.1.2.12 可变报头非规范示例</h5><ul>
<li>图 3-6 可变报头示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">协议名Protocol Name</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 1</td>
<td align="left">长度Length MSB (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">长度Length LSB (4)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left"><code>M</code></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left"><code>Q</code></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 5</td>
<td align="left"><code>T</code></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 6</td>
<td align="left"><code>T</code></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">协议版本Protocol Version</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">说明</td>
<td align="left">7</td>
<td align="left">6</td>
<td align="left">5</td>
<td align="left">4</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 7</td>
<td align="left">版本Version (5)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">连接标志Connect Flags</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 8</td>
<td align="left">密码标志Password Flag (1)遗嘱保留标志Will Retain (0)遗嘱服务质量Will QoS (01)遗嘱标志Will Flag (1)新开始Clean Start(1)保留Reserved (0)</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">保持连接Keep Alive</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 9</td>
<td align="left">保持连接Keep Alive MSB (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 10</td>
<td align="left">保持连接Keep Alive LSB (10)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">属性Properties</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 11</td>
<td align="left">长度Length (5)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 12</td>
<td align="left">会话过期间隔标识符 (17)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 13</td>
<td align="left">会话过期间隔</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 14</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 15</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="3-1-3-CONNECT载荷"><a href="#3-1-3-CONNECT载荷" class="headerlink" title="3.1.3 CONNECT载荷"></a>3.1.3 CONNECT载荷</h4><p><code>CONNECT</code>报文的载荷中包含由<code>可变报头(Variable Header)</code>中的标志确定的一个或多个以长度为前缀的字段. 这些字段若存在, 必须按照<code>客户标识符(Client Identifier)</code>、<code>遗嘱属性(Will Properties)</code>、<code>遗嘱主题(Will Topic)</code>、<code>遗嘱载荷(Will Payload)</code>、<code>用户名(User Name)</code>、<code>密码(Password)</code>的顺序出现 [MQTT-3.1.3-1].</p>
<h5 id="3-1-3-1-客户标识符"><a href="#3-1-3-1-客户标识符" class="headerlink" title="3.1.3.1 客户标识符"></a>3.1.3.1 客户标识符</h5><p>服务端使用<code>客户标识符(ClientID)</code>识别客户端. 连接服务端的每个客户端都有唯一的<code>客户标识符(ClientID)</code>. 客户端和服务端都必须使用<code>客户标识符(ClientID)</code>识别两者之间的 MQTT 会话相关的状态 [MQTT-3.1.3-2]. 更多关于会话状态的信息请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a>.</p>
<p><code>客户标识符</code> <strong>必须</strong>存在, 且作为<code>CONNECT</code>报文载荷的第一个字段出现 [MQTT-3.1.3-3].</p>
<p><code>客户标识符</code> <strong>必须</strong>被编码为<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 中所定义的UTF-8字符串 [MQTT-3.1.3-4].</p>
<p>服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的<code>客户标识符</code>, <code>客户标识符</code>只能包含这些字符:<br>“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”(大写字母、小写字母和数字) [MQTT-3.1.3-5].</p>
<p>服务端<strong>可以</strong>允许编码后超过23个字节的<code>客户标识符 (ClientID)</code>. 服务端<strong>可以</strong>允许包含不是上面列表字符的<code>客户标识符 (ClientID)</code>.</p>
<p>服务端<strong>可以</strong>允许客户端提供一个零字节的<code>客户标识符 (ClientID)</code> , 如果这样做了, 服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户标识符给那个客户端 [MQTT-3.1.3-6]. 然后它<strong>必须</strong>假设客户端提供了那个唯一的客户标识符, 正常处理这个CONNECT报文 [MQTT-3.1.3-7].</p>
<p>如果服务端拒绝了某个<code>客户标识符(ClientID)</code>, 它<strong>可以</strong>发送包含原因码<code>0x85(客户标识符无效)</code>的CONNACK报文作为对客户端的<code>CONNECT</code>报文的回应, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 之后<strong>必须</strong>关闭网络连接 [MQTT-3.1.3-8].</p>
<pre><code>非规范评注
客户端在实现时可以提供一个便于生成随机客户标识符的算法. 使用此算法时, 客户端需要注意避免创建长期孤儿会话.</code></pre><h5 id="3-1-3-2-遗嘱属性"><a href="#3-1-3-2-遗嘱属性" class="headerlink" title="3.1.3.2 遗嘱属性"></a>3.1.3.2 遗嘱属性</h5><p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, 有效载荷的下一个字段是<code>遗嘱属性(Will Properties)</code>. <code>遗嘱属性</code>字段定义了<code>遗嘱消息(Will Message)</code>将何时被发布, 以及被发布时的<code>应用消息(Application Message)</code>属性. 遗嘱属性包括属性长度和属性.</p>
<h6 id="3-1-3-2-1-属性长度"><a href="#3-1-3-2-1-属性长度" class="headerlink" title="3.1.3.2.1 属性长度"></a>3.1.3.2.1 属性长度</h6><p><code>遗嘱属性(Will Properties)</code>中的属性长度被编码为可变长字节整数.</p>
<h6 id="3-1-3-2-2-遗嘱延时间隔"><a href="#3-1-3-2-2-遗嘱延时间隔" class="headerlink" title="3.1.3.2.2 遗嘱延时间隔"></a>3.1.3.2.2 遗嘱延时间隔</h6><p>24 (0x18), <code>遗嘱延时间隔(Will Delay Interval)</code>标识符.<br>跟随其后的是由四字节整数表示的以秒为单位的<code>遗嘱延时间隔(Will Delay Interval)</code>. 包含多个遗嘱延时间隔将造成协议错误(Protocol Error). 如果没有设置遗嘱延时间隔, 遗嘱延时间隔默认值将为0, 即不用延时发布<code>遗嘱消息(Will Message)</code>.</p>
<p>服务端将在<code>遗嘱延时间隔(Will Delay Interval)</code>到期或者<code>会话(Session)</code>结束时发布客户端的<code>遗嘱消息(Will Message)</code>, 取决于两者谁先发生. 如果某个会话在遗嘱延时间隔到期之前创建了新的网络连接, 则服务端<strong>不能</strong>发送遗嘱消息 [MQTT-3.1.3-9].</p>
<pre><code>非规范评注
遗嘱时间间隔的一个用途是避免在频繁的网络连接临时断开时发布遗嘱消息, 因为客户端往往会很快重新连上网络并继续之前的会话.

非规范评注
如果某个连接到服务端的网络连接使用已存在的客户标识符, 此已存在的网络连接的遗嘱消息将会被发布, 除非新的网络连接设置了新开始(Clean Start)为0并且遗嘱延时大于0.  如果遗嘱延时为0, 遗嘱消息将在网络连接断开时发布. 如果新开始为1, 遗嘱消息也将被发布, 因为此会话已结束.</code></pre><h6 id="3-1-3-2-3-载荷格式指示"><a href="#3-1-3-2-3-载荷格式指示" class="headerlink" title="3.1.3.2.3 载荷格式指示"></a>3.1.3.2.3 载荷格式指示</h6><p>1 (0x01), <code>载荷格式指示(Payload Format Indicator)</code>标识符.</p>
<ul>
<li><p>跟随</p>
<pre><code>载荷格式指示(Payload Format Indicator )</code></pre><p>之后的可能是:</p>
<ul>
<li>0 (0x00), 表示<code>遗嘱消息(Will Message)</code>是未指定的字节, 等同于不发送载荷格式指示.</li>
<li>1 (0x01), 表示<code>遗嘱消息(Will Message)</code>是UTF-8编码的字符数据. 载荷中的UTF-8数据必须按照Unicode规范[Unicode] 和RFC 3629 [RFC3629]中的申明进行编码.</li>
</ul>
</li>
</ul>
<p>包含多个<code>载荷格式指示(Payload Format Indicator)</code>将造成协议错误(Protocol Error). 服务端可以按照格式指示对<code>遗嘱消息(Will Message)</code>进行验证, 如果验证失败发送一条包含原因码<code>0x99(载荷格式无效)</code>的<code>CONNACK</code>报文. 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<h6 id="3-1-3-2-4-消息过期间隔"><a href="#3-1-3-2-4-消息过期间隔" class="headerlink" title="3.1.3.2.4 消息过期间隔"></a>3.1.3.2.4 消息过期间隔</h6><p>2 (0x02), <code>消息过期间隔(Message Expiry Interval)</code>标识符.<br>跟随其后的是表示<code>消息过期间隔(Message Expiry Interval)</code>的四字节整数. 包含多个消息过期间隔将导致协议错误(Protocol Error).</p>
<p>如果设定了<code>消息过期间隔(Message Expiry Interval)</code>, 四字节整数描述了遗嘱消息的生命周期(秒), 并在服务端发布遗嘱消息时被当做<code>发布过期间隔(Publication Expiry Interval)</code>.</p>
<p>如果没有设定消息过期间隔, 服务端发布遗嘱消息时将不发送<code>消息过期间隔(Message Expiry Interval)</code>.</p>
<h6 id="3-1-3-2-5-内容类型"><a href="#3-1-3-2-5-内容类型" class="headerlink" title="3.1.3.2.5 内容类型"></a>3.1.3.2.5 内容类型</h6><p>3 (0x03), <code>内容类型(Content Type)</code>标识符.<br>跟随其后的是一个以UTF-8格式编码的字符串, 用来描述<code>遗嘱消息(Will Message)</code>的内容. 包含多个<code>内容类型(Content Type)</code>将造成协议错误(Protocol Error). 内容类型的值由发送应用程序和接收应用程序确定.</p>
<h6 id="3-1-3-2-6-响应主题"><a href="#3-1-3-2-6-响应主题" class="headerlink" title="3.1.3.2.6 响应主题"></a>3.1.3.2.6 响应主题</h6><p>8 (0x08), <code>响应主题(Response Topic)</code>标识符.<br>跟随其后的是一个以UTF-8格式编码的字符串, 用来表示响应消息的<code>主题名(Topic Name)</code>. 包含多个<code>响应主题(Response Topic)</code>将造成协议错误. 响应主题的存在将<code>遗嘱消息(Will Message)</code>标识为一个请求报文.</p>
<p>更多关于请求/响应的内容, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p>
<h6 id="3-1-3-2-7-对比数据"><a href="#3-1-3-2-7-对比数据" class="headerlink" title="3.1.3.2.7 对比数据"></a>3.1.3.2.7 对比数据</h6><p>9 (0x09), <code>对比数据(Correlation Data)</code>标识符.<br>跟随其后的是二进制数据. <code>对比数据</code>被请求消息发送端在收到响应消息时用来标识相应的请求. 包含多个<code>对比数据</code>将造成协议错误(Protocol Error). 如果没有设置对比数据, 则请求方(Requester)不需要任何对比数据.</p>
<p>对比数据只对<code>请求消息(Request Message)</code>的发送端和<code>响应消息(Response Message)</code>的接收端有意义.</p>
<p>更多关于请求/响应的内容, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p>
<h6 id="3-1-3-2-8-用户属性"><a href="#3-1-3-2-8-用户属性" class="headerlink" title="3.1.3.2.8 用户属性"></a>3.1.3.2.8 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是一个UTF-8字符串对. <code>用户属性(User Property)</code> <strong>可以</strong>出现多次, 表示多个名字/值对. 相同的名字<strong>可以</strong>出现多次.</p>
<p>服务端在发布遗嘱消息(Will Message)时<strong>必须</strong>维护<code>用户属性(User Properties)</code>的顺序 [MQTT-3.1.3-10].</p>
<pre><code>非规范评注
此属性旨在提供一种传递应用层名称-值标签的方法, 其含义和解释仅由负责发送和接收它们的应用程序所有.</code></pre><h5 id="3-1-3-3-遗嘱主题"><a href="#3-1-3-3-遗嘱主题" class="headerlink" title="3.1.3.3 遗嘱主题"></a>3.1.3.3 遗嘱主题</h5><p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, <code>遗嘱主题(Will Topic)</code>为载荷中下一个字段. <code>遗嘱主题(Will Topic)</code>必须为UTF-8编码的字符串, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 所定义 [MQTT-3.1.3-11].</p>
<h5 id="3-1-3-4-遗嘱载荷"><a href="#3-1-3-4-遗嘱载荷" class="headerlink" title="3.1.3.4 遗嘱载荷"></a>3.1.3.4 遗嘱载荷</h5><p>如果<code>遗嘱标志(Will Flag)</code>被设置为1, <code>遗嘱载荷(Will Payload)</code>为载荷中下一个字段. 遗嘱载荷定义了将要发布到<code>遗嘱主题(Will Topic)</code>的应用消息载荷, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a> 所定义. 此字段为二进制数据.</p>
<h5 id="3-1-3-5-用户名"><a href="#3-1-3-5-用户名" class="headerlink" title="3.1.3.5 用户名"></a>3.1.3.5 用户名</h5><p>如果<code>用户名标志(User Name Flag)</code>被设置为1, <code>用户名(User Name)</code>为载荷中下一个字段. 用户名<strong>必须</strong>是<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 定义的UTF-8 编码字符串 [MQTT-3.1.3-12]. 服务端<strong>可以</strong>将它用于身份验证和授权.</p>
<h5 id="3-1-3-6-密码"><a href="#3-1-3-6-密码" class="headerlink" title="3.1.3.6 密码"></a>3.1.3.6 密码</h5><p>如果<code>密码标志(Password Flag)</code>被设置为1, <code>密码(Password)</code>为载荷中下一个字段. 密码字段是二进制数据, 尽管被称为密码, 但<strong>可以</strong>被用来承载任何认证信息.</p>
<h4 id="3-1-4-CONNECT行为"><a href="#3-1-4-CONNECT行为" class="headerlink" title="3.1.4 CONNECT行为"></a>3.1.4 CONNECT行为</h4><ul>
<li>注意:服务端<strong>可以</strong>在同一个 TCP 端口或其他网络端点上支持多种协议(包括MQTT协议的早期版本). 如果服务端确定协议是 MQTT v5.0, 那么它按照下面的方法验证连接请求.<ul>
<li><ol>
<li>网络连接建立后, 如果服务端在合理的时间内没有收到 <code>CONNECT</code> 报文, 服务端<strong>应该</strong>关闭这个连接.</li>
</ol>
</li>
<li><ol>
<li>服务端<strong>必须</strong>按照3.1节 的要求验证<code>CONNECT</code>报文, 如果报文不符合规范, 服务端关闭网络连接 [MQTT-3.1.4-1].服务端<strong>可以</strong>在关闭网络连接之前发送包含<a href="https://www.zybuluo.com/khan-lau/note/1325300#3124-新开始" target="_blank" rel="noopener">3.1.2.4节</a>所述的0x80及以上原因码的<code>CONNACK</code>报文.</li>
</ol>
</li>
<li><ol>
<li>服务端<strong>可以</strong>检查<code>CONNECT</code>报文的内容是不是满足任何进一步的限制, <strong>应该</strong>执行身份验证和授权检查. 如果任何一项检查没通过, 服务端<strong>必须</strong>关闭网络连接 [MQTT-3.1.4-2]. 在关闭网络连接之前, 服务端<strong>可以</strong>发送一个合适的包含如<a href="https://www.zybuluo.com/khan-lau/note/1325300#32-connack--确认连接请求" target="_blank" rel="noopener">3.2节</a> 和<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述的0x80及以上原因码的<code>CONNACK</code>报文.</li>
</ol>
</li>
</ul>
</li>
<li>如果验证成功, 服务端会执行下列步骤.</li>
<li>1 如果<code>客户标识符(ClientID)</code>所代表的客户端已经连接到此服务端, 那么向原有的客户端发送一个包含原因码为<code>0x8E(会话被接管)</code>的<code>DISCONNECT</code>报文, 并且必须关闭原有的网络连接 [MQTT-3.1.4-3]. 如果原有客户端存在<code>遗嘱消息(Will Message)</code>, <code>遗嘱消息</code>按照 <a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a> 所描述的方式发布.</li>
</ul>
<pre><code>    非规范评注    如果原有网络连接包含遗嘱消息, 且遗嘱延时间隔为0, 则遗嘱消息会在此网络连接被关闭时发送.  如果原有网络连接会话过期间隔为0, 或者新网络连接新开始标志设置为1且原有网络连接包含遗嘱消息, 则遗嘱消息会被发送, 因为原有会话已结束.</code></pre><ul>
<li>2 服务端必须按照<a href="https://www.zybuluo.com/khan-lau/note/1325300#3124-新开始" target="_blank" rel="noopener">3.1.2.4节</a> 所描述的方式对新开始标志进行处理[MQTT-3.1.4-4].</li>
<li>3 服务端必须使用包含原因码为<code>0x00(成功)</code>的<code>CONNACK</code>报文对客户端的<code>CONNECT</code>报文进行确认 [MQTT-3.1.4-5].</li>
</ul>
<pre><code>    非规范评注    如果服务端被用来处理商业关键数据, 推荐对网络连接进行认证和授权. 如果认证和授权成功, 服务端可通过发送包含原因码为0x00(成功)的CONNACK报文进行响应, 否则建议服务端根本不要发送CONNACK报文, 因为这是一种潜在的对MQTT服务端的攻击, 可以被用来进行拒绝服务攻击或密码猜测攻击.</code></pre><ul>
<li>4 开始消息分发和保持连接状态监视.</li>
</ul>
<p>允许客户端在发送<code>CONNECT</code>报文之后立即发送其它的MQTT控制报文；客户端不需要等待服务端的<code>CONNACK</code>报文. 如果服务端拒绝了<code>CONNECT</code>报文, 它不能处理客户端在<code>CONNECT</code>报文之后发送的任何除<code>AUTH</code>以外的报文 [MQTT-3.1.4-6].</p>
<pre><code>非规范评注
客户端通常会等待CONNACK报文. 然而, 如果在收到CONNACK报文之前就自由的发送其它MQTT控制报文将会简化客户端的实现, 因为它不必监督连接的状态. 如果连接被拒绝了, 客户端在接收CONNACK报文之前发送的任何数据将不会被服务端所处理.

非规范评注
选择在收到CONNACK报文之前就发送MQTT控制报文的客户端将不知道服务端所存在的约束以及会话是否被使用. 

非规范评注
服务端在对某个客户端完成认证之前, 可以选择限制读取该客户端的网络数据或者关闭该客户端的网络连接.这是一种避免拒绝服务攻击的方法.</code></pre><h3 id="3-2-CONNACK-–-确认连接请求"><a href="#3-2-CONNACK-–-确认连接请求" class="headerlink" title="3.2 CONNACK – 确认连接请求"></a>3.2 CONNACK – 确认连接请求</h3><p><code>CONNACK</code>报文由服务端所发送, 作为对来自客户端的<code>CONNECT</code>报文的响应. 服务端在发送任何除<code>AUTH</code>以外的报文之前必须先发送包含原因码为0x00(成功)的<code>CONNACK</code>报文 [MQTT-3.2.0-1].服务端在一次网络连接中不能发送多个<code>CONNACK</code>报文 [MQTT-3.2.0-2].</p>
<p>如果客户端在合理的时间内没有收到服务端的<code>CONNACK</code>报文, 客户端<strong>应该</strong>关闭网络连接. 合理的时间取决于应用的类型和通信基础设施.</p>
<h4 id="3-2-1-CONNACK固定报头"><a href="#3-2-1-CONNACK固定报头" class="headerlink" title="3.2.1 CONNACK固定报头"></a>3.2.1 CONNACK固定报头</h4><p>固定报头的格式见图 3-7 的描述.</p>
<ul>
<li>图 3-7 CONNACK报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (2)</td>
<td align="left">Reserved 保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>剩余长度字段<br>用<code>变长字节整数</code>来编码, 表示可变报头的长度.</p>
<h4 id="3-2-2-CONNACK可变报头"><a href="#3-2-2-CONNACK可变报头" class="headerlink" title="3.2.2 CONNACK可变报头"></a>3.2.2 CONNACK可变报头</h4><p><code>CONNACK</code>报文的可变报头按顺序包含以下字段:<code>连接确认标志(Connect Acknowledge Flags)</code>, 连接<code>原因码(Reason Code)</code>, <code>属性(Properties)</code>. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所描述.</p>
<h5 id="3-2-2-1-连接确认标志"><a href="#3-2-2-1-连接确认标志" class="headerlink" title="3.2.2.1 连接确认标志"></a>3.2.2.1 连接确认标志</h5><p>第1个字节是<code>连接确认标志</code>, 位7-1是保留位且<strong>必须</strong>设置为0 [MQTT-3.2.2-1] .</p>
<p>第0(SP)位是<code>会话存在标志(Session Present Flag)</code>.</p>
<h6 id="3-2-2-1-1-会话存在"><a href="#3-2-2-1-1-会话存在" class="headerlink" title="3.2.2.1.1 会话存在"></a>3.2.2.1.1 会话存在</h6><p>位置:连接确认标志(Connect Acknowledge Flags)的第0位.</p>
<p><code>会话存在(Session Present)</code>标志通知客户端, 服务端是否正在使用此客户标识符之前连接的<code>会话状态(Session State)</code>. 会话存在标志使服务端和客户端在是否有已存储的会话状态上保持一致.</p>
<p>如果服务端接受一个<code>新开始(Clean Start)</code>为1的连接, 服务端在CONNACK报文中除了把原因码设置为0x00(成功)之外, 还必须把会话存在标志设置为0 [MQTT-3.2.2-2].</p>
<p>如果服务端接受一个<code>新开始(Clean Start)</code>为0的连接, 并且服务端已经保存了此<code>客户标识符(ClientID)</code>的<code>会话状态(Session State)</code>, 服务端在<code>CONNACK</code>报文中<strong>必须</strong>把会话存在标志设置为1. 否则, 服务端<strong>必须</strong>把会话存在标志设置为0. 无论如何, 服务端在<code>CONNACK</code>报文中<strong>必须</strong>把原因码设置为<code>0x00(成功)</code> [MQTT-3.2.2-3].</p>
<p>如果客户端从服务端接收到的会话存在标志值与预期的不同, 客户端做如下处理:<br>- 如果客户端没有保存的会话状态, 但收到会话存在标志为1, 客户端<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-4]. 如果希望重新开始一个新的会话, 客户端<strong>可以</strong>使用<code>新开始(Clean Start)</code>为1并重新连接服务端.<br>- 如果客户端保存了<code>会话状态</code>, 但收到的<code>会话存在标志</code>为0, 客户端若要继续此网络连接, 它<strong>必须</strong>丢弃其保存的<code>会话状态</code> [MQTT-3.2.2-5].</p>
<p>如果服务端发送的<code>CONNACK</code>报文中原因码非0, 它<strong>必须</strong>把会话存在标志设置为0 [MQTT-3.2.2-6].</p>
<h5 id="3-2-2-2-连接原因码"><a href="#3-2-2-2-连接原因码" class="headerlink" title="3.2.2.2 连接原因码"></a>3.2.2.2 连接原因码</h5><p>可变报头中第2个字节是连接<code>原因码(Reason Code)</code>.</p>
<p>连接<code>原因码(Reason Code)</code>的值如下所示. 如果服务端收到一个格式正确的<code>CONNECT</code>报文, 但服务端无法完成连接的创建, 服务端<strong>可以</strong>发送一个包含适当的连接原因码的<code>CONNACK</code>报文. 如果服务端发送了一个包含原因码大于等于128的<code>CONNACK</code>报文, 它随后<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-7].</p>
<ul>
<li>表 3-1 连接原因码</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">16进制</th>
<th align="left">原因码名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">成功</td>
<td align="left">连接被接受.</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left">0x80</td>
<td align="left">未指明的错误</td>
<td align="left">服务端不愿透露的错误, 或者没有适用的原因码.</td>
</tr>
<tr>
<td align="left">129</td>
<td align="left">0x81</td>
<td align="left">无效报文</td>
<td align="left">CONNECT报文内容不能被正确的解析.</td>
</tr>
<tr>
<td align="left">130</td>
<td align="left">0x82</td>
<td align="left">协议错误</td>
<td align="left">CONNECT报文内容不符合本规范.</td>
</tr>
<tr>
<td align="left">131</td>
<td align="left">0x83</td>
<td align="left">实现特定错误</td>
<td align="left">CONNECT有效, 但不被服务端所接受.</td>
</tr>
<tr>
<td align="left">132</td>
<td align="left">0x84</td>
<td align="left">协议版本不支持</td>
<td align="left">服务端不支持客户端所请求的MQTT协议版本.</td>
</tr>
<tr>
<td align="left">133</td>
<td align="left">0x85</td>
<td align="left">客户标识符无效</td>
<td align="left">客户标识符有效, 但未被服务端所接受.</td>
</tr>
<tr>
<td align="left">134</td>
<td align="left">0x86</td>
<td align="left">用户名密码错误</td>
<td align="left">客户端指定的用户名密码未被服务端所接受.</td>
</tr>
<tr>
<td align="left">135</td>
<td align="left">0x87</td>
<td align="left">未授权</td>
<td align="left">客户端未被授权连接.</td>
</tr>
<tr>
<td align="left">136</td>
<td align="left">0x88</td>
<td align="left">服务端不可用</td>
<td align="left">MQTT服务端不可用.</td>
</tr>
<tr>
<td align="left">137</td>
<td align="left">0x89</td>
<td align="left">服务端正忙</td>
<td align="left">服务端正忙, 请重试.</td>
</tr>
<tr>
<td align="left">138</td>
<td align="left">0x8A</td>
<td align="left">禁止</td>
<td align="left">客户端被禁止, 请联系服务端管理员.</td>
</tr>
<tr>
<td align="left">140</td>
<td align="left">0x8C</td>
<td align="left">无效的认证方法</td>
<td align="left">认证方法未被支持, 或者不匹配当前使用的认证方法.</td>
</tr>
<tr>
<td align="left">144</td>
<td align="left">0x90</td>
<td align="left">主题名无效</td>
<td align="left">遗嘱主题格式正确, 但未被服务端所接受.</td>
</tr>
<tr>
<td align="left">149</td>
<td align="left">0x95</td>
<td align="left">报文过长</td>
<td align="left">CONNECT报文超过最大允许长度.</td>
</tr>
<tr>
<td align="left">151</td>
<td align="left">0x97</td>
<td align="left">超出配额</td>
<td align="left">已超出实现限制或管理限制.</td>
</tr>
<tr>
<td align="left">153</td>
<td align="left">0x99</td>
<td align="left">载荷格式无效</td>
<td align="left">遗嘱载荷数据与载荷格式指示符不匹配.</td>
</tr>
<tr>
<td align="left">154</td>
<td align="left">0x9A</td>
<td align="left">不支持保留</td>
<td align="left">遗嘱保留标志被设置为1, 但服务端不支持保留消息.</td>
</tr>
<tr>
<td align="left">155</td>
<td align="left">0x9B</td>
<td align="left">不支持的QoS等级</td>
<td align="left">服务端不支持遗嘱中设置的QoS等级.</td>
</tr>
<tr>
<td align="left">156</td>
<td align="left">0x9C</td>
<td align="left">临时)使用其他服务端</td>
<td align="left">客户端应该临时使用其他服务端.</td>
</tr>
<tr>
<td align="left">157</td>
<td align="left">0x9D</td>
<td align="left">服务端已(永久)移动</td>
<td align="left">客户端应该永久使用其他服务端</td>
</tr>
<tr>
<td align="left">159</td>
<td align="left">0x9F</td>
<td align="left">超出连接速率限制</td>
<td align="left">超出了所能接受的连接速率限制.</td>
</tr>
</tbody></table>
<p>服务端发送的<code>CONNACK</code>报文<strong>必须</strong>设置一种原因码 [MQTT-3.2.2-8].</p>
<pre><code>非规范评注
原因码0x80(未指明的错误)可以被用作:服务器知道失败的原因但是并不希望透露给客户端, 或者没有其他适用的原因码.

出于安全考虑, 发现`CONNECT`出错时服务端可以选择不发送`CONNACK`报文而关闭网络连接.例如, 在公网中向未被授权的网络连接告知自身MQTT服务端身份并不明智.</code></pre><h5 id="3-2-2-3-CONNACK属性"><a href="#3-2-2-3-CONNACK属性" class="headerlink" title="3.2.2.3 CONNACK属性"></a>3.2.2.3 CONNACK属性</h5><h6 id="3-2-2-3-1-属性长度"><a href="#3-2-2-3-1-属性长度" class="headerlink" title="3.2.2.3.1 属性长度"></a>3.2.2.3.1 属性长度</h6><p><code>CONNACK</code>报文可变报头中的<code>属性长度</code>, 编码为<code>变长字节整数</code>.</p>
<h6 id="3-2-2-3-2-会话过期间隔"><a href="#3-2-2-3-2-会话过期间隔" class="headerlink" title="3.2.2.3.2 会话过期间隔"></a>3.2.2.3.2 会话过期间隔</h6><p>17 (0x11), <code>会话过期间隔(Session Expiry Interval)</code>标识符.<br>跟随其后的是用四字节整数表示的以秒为单位的<code>会话过期间隔(Session Expiry Interval)</code>. 包含多个<code>会话过期间隔(Session Expiry Interval)</code>将造成协议错误(Protocol Error).</p>
<p>如果<code>会话过期间隔(Session Expiry Interval)</code>值未指定, 则使用<code>CONNECT</code>报文中指定的会话过期时间间隔. 服务端使用此属性通知客户端它使用的会话过期时间间隔与客户端在<code>CONNECT</code>中发送的值不同. 更详细的关于会话过期时间的描述, 请参考 <a href="https://www.zybuluo.com/khan-lau/note/1325300#312112-会话过期间隔" target="_blank" rel="noopener">3.1.2.11.2节</a> .</p>
<h6 id="3-2-2-3-3-接收最大值"><a href="#3-2-2-3-3-接收最大值" class="headerlink" title="3.2.2.3.3 接收最大值"></a>3.2.2.3.3 接收最大值</h6><p>33 (0x21), <code>接收最大值(Receive Maximum)</code>描述符.<br>跟随其后的是由双字节整数表示的最大接收值. 包含多个接收最大值或接收最大值为0将造成协议错误(Protocol Error).</p>
<p>服务端使用此值限制服务端愿意为该客户端同时处理的QoS为1和QoS为2的发布消息最大数量. 没有机制可以限制客户端试图发送的QoS为0的发布消息.</p>
<p>如果没有设置最大接收值, 将使用默认值65535.</p>
<p>关于接收最大值的详细使用, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">4.9节</a> 流控部分.</p>
<h6 id="3-2-2-3-4-最大服务质量"><a href="#3-2-2-3-4-最大服务质量" class="headerlink" title="3.2.2.3.4 最大服务质量"></a>3.2.2.3.4 最大服务质量</h6><p>36 (0x24), <code>最大服务质量(Maximum QoS)</code>标识符.<br>跟随其后的是用一个字节表示的0或1. 包含多个<code>最大服务质量(Maximum QoS)</code>或最大服务质量既不为0也不为1将造成协议错误. 如果没有设置最大服务质量, 客户端可使用最大QoS为2.</p>
<p>如果服务端不支持Qos为1或2的<code>PUBLISH</code>报文, 服务端<strong>必须</strong>在<code>CONNACK</code>报文中发送最大服务质量以指定其支持的最大QoS值 [MQTT-3.2.2-9].即使不支持QoS为1或2的<code>PUBLISH</code>报文, 服务端也<strong>必须</strong>接受请求QoS为0、1或2的<code>SUBSCRIBE</code>报文 [MQTT-3.2.2-10].</p>
<p>如果从服务端接收到了<code>最大QoS</code>等级, 则客户端不能发送超过<code>最大QoS</code>等级所指定的QoS等级的<code>PUBLISH</code>报文 [MQTT-3.2.2-11]. 服务端接收到超过其指定的最大服务质量的<code>PUBLISH</code>报文将造成协议错误(Protocol Error). 这种情况下应使用包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>DISCONNECT</code>报文进行处理, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<p>如果服务端收到包含遗嘱的QoS超过服务端处理能力的<code>CONNECT</code>报文, 服务端<strong>必须</strong>拒绝此连接. 服务端<strong>应该</strong>使用包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>CONNACK</code>报文进行错误处理, 随后<strong>必须</strong>关闭网络连接. <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述 [MQTT-3.2.2-12].</p>
<pre><code>非规范评注
客户端不必支持QoS为1和2的PUBLISH报文.客户端只需将其发送的任何SUBSCRIBE报文中的QoS字段限制在其支持的最大服务质量以内即可.</code></pre><h6 id="3-2-2-3-5-保留可用"><a href="#3-2-2-3-5-保留可用" class="headerlink" title="3.2.2.3.5 保留可用"></a>3.2.2.3.5 保留可用</h6><p>37 (0x25), <code>保留可用(Retain Available)</code>标识符.<br>跟随其后的是一个单字节字段, 用来声明服务端是否支持<code>保留消息</code>. 值为0表示不支持<code>保留消息</code>, 为1表示支持<code>保留消息</code>. 如果没有设置保留可用字段, 表示支持<code>保留消息</code>. 包含多个保留可用字段或保留可用字段值不为0也不为1将造成协议错误(Protocol Error).</p>
<p>如果服务端收到一个包含保留标志位1的遗嘱消息的<code>CONNECT</code>报文且服务端不支持<code>保留消息</code>, 服务端<strong>必须</strong>拒绝此连接请求, 且<strong>应该</strong>发送包含原因码为<code>0x9A(不支持保留)</code>的<code>CONNACK</code>报文, 随后<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-13].</p>
<p>从服务端接收到的保留可用标志为0时, 客户端不能发送<code>保留标志</code>设置为1的<code>PUBLISH</code>报文 [MQTT-3.2.2-14]. 如果服务端收到这种<code>PUBLISH</code>报文, 将造成协议错误(Protocol Error), 此时服务端<strong>应该</strong>发送包含原因码为<code>0x9A(不支持保留)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<h6 id="3-2-2-3-6-最大报文长度"><a href="#3-2-2-3-6-最大报文长度" class="headerlink" title="3.2.2.3.6 最大报文长度"></a>3.2.2.3.6 最大报文长度</h6><p>39 (0x27), <code>最大报文长度(Maximum Packet Size)</code>标识符.<br>跟随其后的是由四字节整数表示的服务端愿意接收的<code>最大报文长度(Maximum Packet Size)</code>. 如果没有设置<code>最大报文长度</code>, 则按照协议由固定报头中的剩余长度可编码最大值和协议报头对数据包的大小做限制.</p>
<p>包含多个<code>最大报文长度(Maximum Packet Size)</code>, 或<code>最大报文长度</code>为0将造成协议错误(Protocol Error).</p>
<p>如<a href="https://www.zybuluo.com/khan-lau/note/1325300#214-剩余长度" target="_blank" rel="noopener">2.1.4节</a> 所述, 最大报文长度是MQTT控制报文的总长度. 服务端使用最大报文长度通知客户端其所能处理的单个报文长度限制.</p>
<p>客户端不能发送超过最大报文长度(Maximum Packet Size)的报文给服务端 [MQTT-3.2.2-15]. 收到长度超过限制的报文将导致协议错误, 此时服务端<strong>应该</strong>发送包含原因码<code>0x95(报文过长)</code>的DISCONNECT报文给客户端, 详见<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p>
<h6 id="3-2-2-3-7-分配客户标识符"><a href="#3-2-2-3-7-分配客户标识符" class="headerlink" title="3.2.2.3.7 分配客户标识符"></a>3.2.2.3.7 分配客户标识符</h6><p>18 (0x12), <code>分配客户标识符(Assigned Client Identifier)</code>标识符.<br>跟随其后的是UTF-8编码的<code>分配客户标识符(Assigned Client Identifier)</code>字符串. 包含多个分配客户标识符将造成协议错误(Protocol Error).</p>
<p>服务端分配客户标识符的原因是<code>CONNECT</code>报文中的客户标识符长度为0.</p>
<p>如果客户端使用长度为0的<code>客户标识符(ClientID)</code>, 服务端<strong>必须</strong>回复包<code>含分配客户标识符(Assigned Client Identifier)</code>的<code>CONNACK</code>报文. 分配客户标识符<strong>必须</strong>是没有被服务端的其他会话所使用的新<code>客户标识符</code> [MQTT-3.2.2-16].</p>
<h6 id="3-2-2-3-8-主题别名最大值"><a href="#3-2-2-3-8-主题别名最大值" class="headerlink" title="3.2.2.3.8 主题别名最大值"></a>3.2.2.3.8 主题别名最大值</h6><p>34 (0x22), <code>主题别名最大值(Topic Alias Maximum)</code>标识符.<br>跟随其后的是用双字节整数表示的<code>主题别名最大值(Topic Alias Maximum)</code>. 包含多个<code>主题别名最大值(Topic Alias Maximum)</code>将造成协议错误(Protocol Error). 没有设置主题别名最大值属性的情况下, 主题别名最大值默认为零.</p>
<p>此值指示了服务端能够接收的来自客户端的主题别名(Topic Alias)最大值.服务端使用此值来限制本次连接可以拥有的主题别名的值. 客户端在一个<code>PUBLISH</code>报文中发送的主题别名值不能超过服务端设置的<code>主题别名最大值(Topic Alias Maximum)</code> [MQTT-3.2.2-17]. 值为0表示本次连接服务端不接受任何<code>主题别名(Topic Alias)</code>. 如果<code>主题别名最大值(Topic Alias Maximum)</code>没有设置, 或者设置为0, 则客户端不能向此服务端发送任何<code>主题别名(Topic Alias)</code> [MQTT-3.2.2-18].</p>
<h6 id="3-2-2-3-9-原因字符串"><a href="#3-2-2-3-9-原因字符串" class="headerlink" title="3.2.2.3.9 原因字符串"></a>3.2.2.3.9 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不应该被客户端所解析.</p>
<p>服务端使用此值向客户端提供附加信息. 如果加上原因字符串之后的<code>CONNACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端不能发送此原因字符串 [MQTT-3.2.2-19]. 包含多个原因字符串将造成协议错误(Protocol Error).</p>
<pre><code>非规范评注
客户端对原因字符串的恰当使用包括:抛出异常时使用此字符串, 或者将此字符串写入日志.</code></pre><h6 id="3-2-2-3-10-用户属性"><a href="#3-2-2-3-10-用户属性" class="headerlink" title="3.2.2.3.10 用户属性"></a>3.2.2.3.10 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上用户属性之后的<code>CONNACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端不能发送此属性 [MQTT-3.2.2-20]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p>
<p>用户属性的内容和意义本规范不做定义. <code>CONNACK</code>报文的接收端可以选择忽略此属性.</p>
<h6 id="3-2-2-3-11-通配符订阅可用"><a href="#3-2-2-3-11-通配符订阅可用" class="headerlink" title="3.2.2.3.11 通配符订阅可用"></a>3.2.2.3.11 通配符订阅可用</h6><p>40 (0x28), <code>通配符订阅可用(Wildcard Subscription Available)</code>标识符.<br>跟随其后的是一个单字节字段, 用来声明服务器是否支持<code>通配符订阅(Wildcard Subscriptions)</code>. 值为0表示不支持<code>通配符订阅</code>, 值为1表示支持通配符订阅. 如果没有设置此值, 则表示支持<code>通配符订阅</code>. 包含多个<code>通配符订阅可用</code>属性, 或<code>通配符订阅可用</code>属性值不为0也不为1将造成协议错误(Protocol Error).</p>
<p>如果服务端在不<code>支持通配符订阅</code>(Wildcard Subscription)的情况下收到了包含<code>通配符订阅</code>的<code>SUBSCRIBE</code>报文, 将造成协议错误(Protocol Error). 此时服务端将发送包含原因码为<code>0xA2(通配符订阅不支持)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<p>服务端在支持<code>通配符订阅</code>的情况下仍然可以拒绝特定的包含<code>通配符订阅</code>的订阅请求. 这种情况下, 服务端可以发送一个包含原因码为<code>0xA2(通配符订阅不支持)</code>的<code>SUBACK</code>报文.</p>
<h6 id="3-2-2-3-12-订阅标识符可用"><a href="#3-2-2-3-12-订阅标识符可用" class="headerlink" title="3.2.2.3.12 订阅标识符可用"></a>3.2.2.3.12 订阅标识符可用</h6><p>41 (0x29), <code>订阅标识符可用(Subscription Identifier Available)</code>标识符.<br>跟随其后的是一个单字节字段, 用来声明服务端是否支持<code>订阅标识符(Subscription Identifiers)</code>. 值为0表示不支持<code>订阅标识符</code>, 值为1表示支持<code>订阅标识符</code>. 如果没有设置此值, 则表示支持<code>订阅标识符</code>. 包含多个<code>订阅标识符可用</code>属性, 或<code>订阅标识符可用</code>属性值不为0也不为1将造成协议错误(Protocol Error).</p>
<p>如果服务端在不支持<code>订阅标识符(Subscription Identifier)</code>的情况下收到了包含<code>订阅标识符</code>的<code>SUBSCRIBE</code>报文, 将造成协议错误(Protocol Error). 此时服务端将发送包含原因码为<code>0xA1(订阅标识符不支持)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<h6 id="3-2-2-3-13-共享订阅可用"><a href="#3-2-2-3-13-共享订阅可用" class="headerlink" title="3.2.2.3.13 共享订阅可用"></a>3.2.2.3.13 共享订阅可用</h6><p>42 (0x2A), <code>共享订阅可用(Shared Subscription Available)</code>标识符.<br>跟随其后的是一个单字节字段, 用来声明服务端是否支持<code>共享订阅(Shared Subscription)</code>. 值为0表示不支持<code>共享订阅</code>, 值为1表示支持<code>共享订阅</code>. 如果没有设置此值, 则表示支持<code>共享订阅</code>. 包含多个<code>共享订阅可用(Shared Subscription Available)</code>, 或<code>共享订阅可用</code>属性值不为0也不为1将造成协议错误(Protocol Error).</p>
<p>如果服务端在不支持<code>共享订阅(Shared Subscription)</code>的情况下收到了包含<code>共享订阅</code>的<code>SUBSCRIBE</code>报文, 将造成协议错误(Protocol Error). 此时服务端将发送包含原因码为<code>0x9E(共享订阅不支持)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<h6 id="3-2-2-3-14-服务端保持连接"><a href="#3-2-2-3-14-服务端保持连接" class="headerlink" title="3.2.2.3.14 服务端保持连接"></a>3.2.2.3.14 服务端保持连接</h6><p>19 (0x13), <code>服务端保持连接(Server Keep Alive)</code>标识符.<br>跟随其后的是由服务端分配的双字节整数表示的<code>保持连接(Keep Alive)</code>时间. 如果服务端发送了<code>服务端保持连接(Server Keep Alive)</code>属性, 客户端<strong>必须</strong>使用此值代替其在<code>CONNECT</code>报文中发送的<code>保持连接</code>时间值 [MQTT-3.2.2-21]. 如果服务端没有发送<code>服务端保持连接</code>属性, 服务端<strong>必须</strong>使用客户端在<code>CONNECT</code>报文中设置的<code>保持连接</code>时间值 [MQTT-3.2.2-22]. 包含多个<code>服务端保持连接</code>属性将造成协议错误(Protocol Error).</p>
<pre><code>非规范评注
服务端保持连接属性的主要作用是通知客户端它将会比客户端指定的保持连接更快的断开非活动的客户端.</code></pre><h6 id="3-2-2-3-15-响应信息"><a href="#3-2-2-3-15-响应信息" class="headerlink" title="3.2.2.3.15 响应信息"></a>3.2.2.3.15 响应信息</h6><p>26 (0x1A), <code>响应信息(Response Information)</code>标识符.<br>跟随其后的是一个以UTF-8编码的字符串, 作为<code>创建响应主题(Response Topic)</code>的基本信息. 关于客户端如何根据<code>响应信息(Response Information)</code>创建响应主题不在本规范的定义范围内. 包含多个响应信息将造成协议错误(Protocol Error).</p>
<p>如果客户端发送的<code>请求响应信息(Request Response Information)</code>值为1, 则服务端在<code>CONNACK</code>报文中发送<code>响应信息(Response Information)</code>为可选项.</p>
<pre><code>非规范评注
响应信息通常被用来传递主题订阅树的一个全局唯一分支, 此分支至少在该客户端的会话生命周期内为该客户端所保留. 请求客户端和响应客户端的授权需要使用它, 所以它通常不能仅仅是一个随机字符串. 一般把此分支作为特定客户端的订阅树根节点. 通常此信息需要正确配置, 以使得服务器能返回信息. 使用此机制时, 具体的信息一般由服务端来进行统一配置, 而非由各个客户端自己配置.</code></pre><p>更多关于请求/响应的信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a> .</p>
<h6 id="3-2-2-3-16-服务端参考"><a href="#3-2-2-3-16-服务端参考" class="headerlink" title="3.2.2.3.16 服务端参考"></a>3.2.2.3.16 服务端参考</h6><p>28 (0x1C), <code>服务端参考(Server Reference)</code>标识符.<br>跟随其后的是一个以UTF-8编码的字符串, 可以被客户端用来标识其他可用的服务端. 包含多个<code>服务端参考(Server Reference)</code>将造成协议错误(Protocol Error).</p>
<p>服务端在包含了原因码为<code>0x9C((临时)使用其他服务端)</code>或<code>0x9D(服务端已(永久)移动)</code>的<code>CONNACK</code>报文或<code>DISCONNECT</code>报文中设置服务端参考, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<p>关于如何使用服务端参考, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#411-服务端重定向" target="_blank" rel="noopener">4.11节</a> 服务端重定向信息.</p>
<h6 id="3-2-2-3-17-认证方法"><a href="#3-2-2-3-17-认证方法" class="headerlink" title="3.2.2.3.17 认证方法"></a>3.2.2.3.17 认证方法</h6><p>21 (0x15), <code>认证方法(Authentication Method)</code>标识符.<br>跟随其后的是一个以UTF-8编码的字符串, 包含了<code>认证方法(Authentication Method)</code>名. 包含多个认证方法将造成协议错误(Protocol Error). 更多关于扩展认证的信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a> .</p>
<h6 id="3-2-2-3-18-认证数据"><a href="#3-2-2-3-18-认证数据" class="headerlink" title="3.2.2.3.18 认证数据"></a>3.2.2.3.18 认证数据</h6><p>22 (0x16), <code>认证数据(Authentication Data)</code>标识符.<br>跟随其后的是包含<code>认证数据(Authentication Data)</code>的二进制数据. 此数据的内容由认证方法和已交换的<code>认证数据</code>状态定义. 包含多个<code>认证数据</code>将造成协议错误(Protocol Error). 更多关于扩展认证的信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p>
<h4 id="3-2-3-CONNACK载荷"><a href="#3-2-3-CONNACK载荷" class="headerlink" title="3.2.3 CONNACK载荷"></a>3.2.3 CONNACK载荷</h4><p><code>CONNACK</code>报文没有有效载荷.</p>
<h3 id="3-3-PUBLISH-–-发布消息"><a href="#3-3-PUBLISH-–-发布消息" class="headerlink" title="3.3 PUBLISH – 发布消息"></a>3.3 PUBLISH – 发布消息</h3><p><code>PUBLISH</code>报文是指从客户端向服务端或者服务端向客户端传输一个应用消息.</p>
<h4 id="3-3-1-PUBLISH固定报头"><a href="#3-3-1-PUBLISH固定报头" class="headerlink" title="3.3.1 PUBLISH固定报头"></a>3.3.1 PUBLISH固定报头</h4><ul>
<li>图 3-8 PUBLISH报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (3)</td>
<td align="left">DUP</td>
<td align="left">QoS等级</td>
<td align="left">RETAIN</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">byte 2 …</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="3-3-1-1-重发标志"><a href="#3-3-1-1-重发标志" class="headerlink" title="3.3.1.1 重发标志"></a>3.3.1.1 重发标志</h5><p>位置:第1个字节, 第3位.<br>如果<code>DUP标志</code>被设置为0, 表示这是客户端或服务端第一次请求发送这个<code>PUBLISH</code>报文. 如果<code>DUP标志</code>被设置为1, 表示这可能是一个早前报文请求的重发.</p>
<p>客户端或服务端请求重发一个<code>PUBLISH</code>报文时, <strong>必须</strong>将<code>DUP标志</code>设置为1 [MQTT-3.3.1-1]. 对于QoS为0的消息, <code>DUP标志</code> <strong>必须</strong>设置为0 [MQTT-3.3.1-2].</p>
<p>服务端发送<code>PUBLISH</code>报文给订阅者时, 收到(入站)的<code>PUBLISH</code>报文的<code>DUP标志</code>的值不会被传播. 发送(出站)的<code>PUBLISH</code>报文与收到(入站)的<code>PUBLISH</code>报文中的<code>DUP标志</code>是独立设置的, 它的值<strong>必须</strong>单独的根据发送(出站)的<code>PUBLISH</code>报文是否是一个重发来确定 [MQTT-3.3.1-3].</p>
<pre><code>非规范评注
接收者收到一个DUP标志位1的MQTT控制报文时, 不能假设它看到了一个这个报文之前的一个副本. 

非规范评注
需要特别指出的是, DUP标志关注的是MQTT控制报文本身, 与它包含的应用消息无关.当使用QoS 1时, 客户端可能会收到一个DUP标志为0的PUBLISH 报文, 这个报文包含一个它之前收到过的应用消息的副本, 但是用的是不同的报文标识符. 2.2.1节 提供了有关报文标识符的更多信息.</code></pre><h5 id="3-3-1-2-服务质量等级"><a href="#3-3-1-2-服务质量等级" class="headerlink" title="3.3.1.2 服务质量等级"></a>3.3.1.2 服务质量等级</h5><p>位置:第1个字节, 第2-1位.<br>这个字段表示应用消息分发的<code>服务质量(QoS)</code>等级保证. 服务质量等级在下表中列出.</p>
<ul>
<li>表 3-2 QoS定义</li>
</ul>
<table>
<thead>
<tr>
<th align="left">QoS值</th>
<th align="left">Bit 2</th>
<th align="left">Bit 1</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">最多分发一次</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">至少分发一次</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">仅分发一次</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">保留 – 不能使用</td>
</tr>
</tbody></table>
<p>如果服务端在对客户端响应的<code>CONNACK</code>报文中包含了<code>最大服务质量(Maximum QoS)</code>且服务端收到的<code>PUBLISH</code>报文的QoS大于此最大服务质量, 服务端发送包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<p><code>PUBLISH</code>报文的2个QoS比特位<strong>不能</strong>同时设置为1 [MQTT-3.3.1-4]. 如果服务端或客户端收到QoS 2个比特位都为1的无效<code>PUBLISH</code>报文, 使用包含原因码为<code>0x81(无效报文)</code>的<code>DISCONNECT</code>报文关闭网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<h5 id="3-3-1-3-保留标志"><a href="#3-3-1-3-保留标志" class="headerlink" title="3.3.1.3 保留标志"></a>3.3.1.3 保留标志</h5><p>位置:第1个字节, 第0位.</p>
<p>如果客户端发给服务端的<code>PUBLISH</code>报文的<code>保留(Retain)</code>标志被设置为1, 服务端<strong>必须</strong>存储此应用消息, 并用其替换此话题下任何已存在的消息 [MQTT-3.3.1-5], 以便它<strong>可以</strong>被分发给未来的匹配此<code>主题名(Topic Name)</code>的订阅者. 如果载荷为空, 消息可以正常被服务端所处理, 但是此话题下的任何<code>保留消息</code><strong>必须</strong>被丢弃, 并且此话题未来的订阅者将不会收到保留消息 [MQTT-3.3.1-6]. 载荷为空的保留消息将<strong>不能</strong>被存储在服务端 [MQTT-3.3.1-7].</p>
<p>如果客户端发给服务端的<code>PUBLISH</code>报文的保留标志位为0, 服务器<strong>不能</strong>把此消息存储为保留消息, 也<strong>不能</strong>丢弃或替换任何已存在的保留消息 [MQTT-3.3.1-8].</p>
<p>如果服务端发送给客户端的<code>CONNACK</code>报文中包含保留可用属性, 且属性值为0, 但收到的<code>PUBLISH</code>报文中保留标志位为1, 服务端使用包含原因码为<code>0x9A(保留不支持)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<ul>
<li><p>当一个新的</p>
<pre><code>非共享订阅(Non-shared Subscription)</code></pre><p>被创建时, 每个匹配的话题下的最新保留消息如果存在, 将根据保留消息</p>
<pre><code>订阅选项(Retain Handling Subscription Option)</code></pre><p>发送给客户端. 这些消息在发送时保留标志被设置为1. 保留消息的发送由保留消息处理订阅选项控制, 收到订阅时:</p>
<ul>
<li>如果保留消息处理属性被设置为0, 服务端<strong>必须</strong>发送主题与客户端订阅的<code>主题过滤器(Topic Filter)</code>相匹配的所有保留消息 [MQTT-3.3.1-9].</li>
<li>如果保留消息处理属性被设置为1, 如果尚不存在匹配的订阅, 服务端<strong>必须</strong>发送主题与客户端订阅的<code>主题过滤器</code>相匹配的所有保留消息.如果已存在相匹配的订阅, 服务器<strong>不能</strong>发送这些保留消息 [MQTT-3.3.1-10].</li>
<li>如果保留消息处理属性被设置为2, 服务器<strong>不能</strong>发送这些保留消息 [MQTT-3.3.1-11].</li>
</ul>
</li>
</ul>
<p><code>订阅选项(Subscription Options)</code>的定义, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3831-订阅选项" target="_blank" rel="noopener">3.8.3.1节</a> .</p>
<p>如果服务端收到<code>保留标志</code>设置为1且QoS设置为0的<code>PUBLISH</code>报文, 服务端<strong>应该</strong>把此QoS为0的消息存储为其主题下最新的<code>保留消息</code>, 但服务端<strong>可以</strong>选择在任何时间丢弃此消息. 如果发生丢弃, 该主题下将不存在任何<code>保留消息</code>.</p>
<p>如果某个主题当前的<code>保留消息</code>过期, 该主题下将不存在任何<code>保留消息</code>.</p>
<ul>
<li>服务端转发应用消息时, <code>保留标志</code>位的设置由发布保留(Retain As Published)<code>订阅选项</code>决定. <code>订阅选项</code>的定义, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3831-订阅选项" target="_blank" rel="noopener">3.8.3.1节</a> .<ul>
<li>如果发布保留(Retain As Published)订阅选项被设置为0, 服务端在转发应用消息时必须将保留标志设置为0, 而不管收到的<code>PUBLISH</code>报文中保留标志位如何设置的 [MQTT-3.3.1-12].</li>
<li>如果发布保留(Retain As Published)订阅选项被设置为1, 服务端在转发应用消息时必须将保留标志设置为与收到的<code>PUBLISH</code>消息中的保留标志位相同 [MQTT-3.3.1-13].</li>
</ul>
</li>
</ul>
<pre><code>非规范评注对于发布者不定期发送状态消息这个场景, 保留消息很有用. 新的非共享订阅者将会收到最近的状态.</code></pre><h5 id="3-3-1-4-剩余长度"><a href="#3-3-1-4-剩余长度" class="headerlink" title="3.3.1.4 剩余长度"></a>3.3.1.4 剩余长度</h5><p>等于可变报头的长度加上有效载荷的长度, 被编码为<code>变长字节整数</code>.</p>
<h4 id="3-3-2-PUBLISH可变报头"><a href="#3-3-2-PUBLISH可变报头" class="headerlink" title="3.3.2 PUBLISH可变报头"></a>3.3.2 PUBLISH可变报头</h4><p><code>PUBLISH</code>报文可变报头按顺序包含:<code>主题名(Topic Name)</code>, <code>报文标识符(Packet Identifier)</code>, <code>属性(Properties)</code>. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p>
<h5 id="3-3-2-1-主题名"><a href="#3-3-2-1-主题名" class="headerlink" title="3.3.2.1 主题名"></a>3.3.2.1 主题名</h5><p><code>主题名(Topic Name)</code>用于识别有效载荷数据应该被发布到哪一个信息通道.</p>
<p>主题名<strong>必须</strong>是<code>PUBLISH</code>报文可变报头的第一个字段. 它必须是 <a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 定义的UTF-8编码的字符串 [MQTT-3.3.2-1].</p>
<p><code>PUBLISH</code>报文中的主题名<strong>不能</strong>包含通配符 [MQTT-3.3.2-2].</p>
<p>服务端发送给订阅客户端的<code>PUBLISH</code>报文中的主题名必须<strong>匹配</strong>该订阅的主题过滤器(Topic Filter), 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> 所定义的匹配过程 [MQTT-3.3.2-3]. 然而, 由于服务端允许将主题名映射为其他名字, 主题名可能与原始<code>PUBLISH</code>报文中的主题名不同.</p>
<p>发送端可以使用<code>主题别名(Topic Alias)</code>以便减少PUBLISH报文的长度. 主题别名如<a href="https://www.zybuluo.com/khan-lau/note/1325300#33234-主题别名" target="_blank" rel="noopener">3.3.2.3.4节</a> 所述. 主题名长度为0且没有主题别名, 将造成协议错误(Protocol Error).</p>
<h5 id="3-3-2-2-报文标识符"><a href="#3-3-2-2-报文标识符" class="headerlink" title="3.3.2.2 报文标识符"></a>3.3.2.2 报文标识符</h5><p>只有当QoS等级是1或2时, <code>报文标识符(Packet Identifier)</code>字段才能出现在PUBLISH报文中. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了有关报文标识符的更多信息.</p>
<h5 id="3-3-2-3-PUBLISH属性"><a href="#3-3-2-3-PUBLISH属性" class="headerlink" title="3.3.2.3 PUBLISH属性"></a>3.3.2.3 PUBLISH属性</h5><h6 id="3-3-2-3-1-属性长度"><a href="#3-3-2-3-1-属性长度" class="headerlink" title="3.3.2.3.1 属性长度"></a>3.3.2.3.1 属性长度</h6><p><code>PUBLISH</code>报文可变报头中的属性长度被编码为变长字节整数.</p>
<h6 id="3-3-2-3-2-载荷格式指示"><a href="#3-3-2-3-2-载荷格式指示" class="headerlink" title="3.3.2.3.2 载荷格式指示"></a>3.3.2.3.2 载荷格式指示</h6><p>1 (0x01), <code>载荷格式指示(Payload Format Indicator)</code>标识符.<br>跟随其后的是单字节的载荷格式指示值, 可以是:</p>
<ul>
<li>0 (0x00), 说明载荷是未指定格式的字节, 相当于没有发送载荷格式指示.</li>
<li>1 (0x01), 说明载荷是UTF-8编码的字符数据. 载荷中的UTF-8数据必须是按照Unicode [Unicode] 的规范和RFC 3629 [RFC3629] 的重申进行编码.</li>
</ul>
<p>服务端<strong>必须</strong>把接收到的应用消息中的载荷格式指示原封不动的发给所有的订阅者 [MQTT-3.3.2-4]. 接收者<strong>可以</strong>验证载荷数据与所指示的格式一致, 如果不一致, 发送包含原因码为0x99(载荷格式无效)的<code>PUBACK</code>, <code>PUBREC</code>或<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<h6 id="3-3-2-3-3-消息过期间隔"><a href="#3-3-2-3-3-消息过期间隔" class="headerlink" title="3.3.2.3.3 消息过期间隔"></a>3.3.2.3.3 消息过期间隔</h6><p>2 (0x02), <code>消息过期间隔(Message Expiry Interval)</code>标识符.<br>跟随其后的是四字节整数表示的<code>消息过期间隔(Message Expiry Interval)</code>.</p>
<p>如果消息过期间隔存在, 四字节整数表示以秒为单位的应用消息(Application Message)生命周期. 如果<code>消息过期间隔(Message Expiry Interval)</code>已过期, 服务端还没开始向匹配的订阅者交付该消息, 则服务端<strong>必须</strong>删除该订阅者的消息副本 [MQTT-3.3.2-5].</p>
<p>如果<code>消息过期间隔</code>不存在, 应用消息不会过期.</p>
<p>服务端发送给客户端的<code>PUBLISH</code>报文中<strong>必须</strong>包含<code>消息过期间隔</code>, 值为接收时间减去消息在服务端的等待时间 [MQTT-3.3.2-6]. 关于状态存储的细节和限制, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a>.</p>
<h6 id="3-3-2-3-4-主题别名"><a href="#3-3-2-3-4-主题别名" class="headerlink" title="3.3.2.3.4 主题别名"></a>3.3.2.3.4 主题别名</h6><p>35 (0x23), <code>主题别名(Topic Alias)</code>标识符.<br>跟随其后的是表示<code>主题别名(Topic Alias)</code>值的双字节整数. 包含多个<code>主题别名</code>值将造成协议错误(Protocol Error).</p>
<p><code>主题别名</code>是一个整数, 用来代替主题名对主题进行识别. <code>主题别名</code>可以减小<code>PUBLISH</code>报文的长度, 这对某个网络连接中发送的很长且反复使用的主题名来说很有用.</p>
<p>发送端决定是否使用<code>主题别名</code>及别名值如何选取. 发送端通过在<code>PUBLISH</code>报文中包含的非0长度主题名和<code>主题别名</code>来设置<code>主题别名</code>映射. 接收端正常处理该<code>PUBLISH</code>报文, 但同样将指定的<code>主题别名</code>映射到主题名.</p>
<p>如果接收端已经设置了某个<code>主题别名</code>映射, 发送端可以发送包含<code>主题别</code>名和长度为0的主题名的<code>PUBLISH</code>报文. 接收端把此<code>PUBLISH</code>报文的主题名当做其包含的<code>主题别名</code>所映射的主题名.</p>
<p>发送端可以通过在同一个网络连接中发送另一个包含同样 <code>主题别名</code> 和不同非0长度主题名的 <code>PUBLISH</code> 报文来修改 <code>主题别名</code> 映射关系.</p>
<p><code>主题别名</code>映射仅作用于某个网络连接及其生命周期内. 接收端<strong>不能</strong>将任何<code>主题别名</code>映射从一个网络连接转发到另一个网络连接 [MQTT-3.3.2-7].</p>
<p><code>主题别名</code>不允许为0. 发送端<strong>不能</strong>发送包含<code>主题别名</code>值为0的 <code>PUBLISH</code> 报文 [MQTT-3.3.2-8].</p>
<p>客户端<strong>不能</strong>发送 <code>主题别名</code> 值大于服务端的 <code>CONNACK</code> 报文中指定的<code>主题别名</code>最大值(Topic Alias Maximum)的PUBLISH报文 [MQTT-3.3.2-9]. 客户端<strong>必须</strong>接受所有值大于0且小于等于其发送的 <code>CONNECT</code> 报文中的<code>主题别名</code>最大值的<code>主题别名</code> [MQTT-3.3.2-10].</p>
<p>服务端<strong>不能</strong>发送包含<code>主题别名</code>值大于客户端在<code>CONNECT</code>报文中指定的<code>主题别名最大值(Topic Alias Maximum)</code>的<code>PUBLISH</code>报文 [MQTT-3.3.2-11]. 服务端<strong>必须</strong>接受所有值大于0且小于等于其发送的 <code>CONNACK</code> 报文中的<code>主题别名</code>最大值的<code>主题别名</code> [MQTT-3.3.2-12].</p>
<p>客户端和服务端使用的<code>主题别名</code>映射相互独立. 因此一般来说, 客户端发送给服务端的<code>主题别名</code>值为1的<code>PUBLISH</code>报文和服务端发送给客户端的<code>主题别名</code>值为1的<code>PUBLISH</code>报文, 将被映射到不同的主题.</p>
<h6 id="3-3-2-3-5-响应主题"><a href="#3-3-2-3-5-响应主题" class="headerlink" title="3.3.2.3.5 响应主题"></a>3.3.2.3.5 响应主题</h6><p>8 (0x08), <code>响应主题(Response Topic)</code>标识符.<br>跟随其后的是一个UTF-8编码的字符串, 用作响应消息的主题名. <code>响应主题</code>必须是按照<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 所定义的UTF-8编码的字符串 [MQTT-3.3.2-13]. <code>响应主题</code>不能包含通配符 [MQTT-3.3.2-14]. 包含多个<code>响应主题</code>将造成协议错误(Protocol Error). <code>响应主题</code>的存在将消息标识为请求报文.</p>
<p>更多关于请求/响应的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p>
<p>服务端在收到应用消息时必须将响应主题原封不动的发送给所有的订阅者 [MQTT-3.3.2-15].</p>
<pre><code>非规范评注
包含响应主题的应用消息接收端使用响应主题作为主题名, 发送作为响应消息的PUBLISH报文. 如果请求消息中包含对比数据, 接收端应当在发送作为对此请求消息进行响应的PUBLISH报文中包含此对比数据.</code></pre><h6 id="3-3-2-3-6-对比数据"><a href="#3-3-2-3-6-对比数据" class="headerlink" title="3.3.2.3.6 对比数据"></a>3.3.2.3.6 对比数据</h6><p>9 (0x09), <code>对比数据(Correlation Data)</code>标识符.<br>跟随其后的是二进制数据. <code>对比数据</code>被请求消息发送端在收到响应消息时用来标识相应的请求. 包含多个<code>对比数据</code>将造成协议错误(Protocol Error). 如果没有设置<code>对比数据</code>, 则请求方(Requester)不需要任何<code>对比数据</code>.</p>
<p>服务端在收到应用消息时<strong>必须</strong>原封不动的把 <code>对比数据</code> 发送给所有的订阅者 [MQTT-3.3.2-16]. <code>对比数据</code> 只对 <code>请求消息(Request Message)</code> 的发送端和 <code>响应消息(Response Message)</code> 的接收端有意义.</p>
<pre><code>非规范评注
接收端收到包含响应主题和对比数据的应用消息时, 发送以响应主题为主题名的PUBLISH报文作为响应消息.  客户端在响应消息中应将对比数据作为PUBLISH报文的一部分原封不动的发送出去.

非规范评注
如果对客户端响应消息中的对比数据所做的任何更改会造成应用程序错误, 则应当对对比数据进行加密/哈希, 以便接收端能检测到对比数据是否被更改.</code></pre><p>更多关于请求/响应的信息, 请参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#410-请求响应" target="_blank" rel="noopener">4.10节</a>.</p>
<h6 id="3-3-2-3-7-用户属性"><a href="#3-3-2-3-7-用户属性" class="headerlink" title="3.3.2.3.7 用户属性"></a>3.3.2.3.7 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>.<br>跟随其后的是UTF-8字符串对. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p>
<p>服务端在转发应用消息到客户端时必须原封不动的把所有的<code>用户属性</code>放在<code>PUBLISH</code>报文中 [MQTT-3.3.2-17]. 服务端在转发应用消息时必须保持所有<code>用户属性</code>的先后顺序 [MQTT-3.3.2-18].</p>
<pre><code>非规范评注
此属性旨在提供一种传递应用层名称-值标签的方法, 其含义和解释仅由负责发送和接收它们的应用程序所有.</code></pre><h6 id="3-3-2-3-8-订阅标识符"><a href="#3-3-2-3-8-订阅标识符" class="headerlink" title="3.3.2.3.8 订阅标识符"></a>3.3.2.3.8 订阅标识符</h6><p>11 (0x0B), <code>订阅标识符(Subscription Identifier)</code>标识符.<br>跟随其后的是一个变长字节整数表示的<code>订阅标识符</code>.</p>
<p><code>订阅标识符</code>取值范围从1到268,435,455. <code>订阅标识符</code>的值为0将造成协议错误. 如果某条发布消息匹配了多个订阅, 则将包含多个<code>订阅标识符</code>. 这种情况下他们的顺序并不重要.</p>
<h6 id="3-3-2-3-9-内容类型"><a href="#3-3-2-3-9-内容类型" class="headerlink" title="3.3.2.3.9 内容类型"></a>3.3.2.3.9 内容类型</h6><p>3 (0x03), <code>内容类型(Content Type)</code>标识符.<br>跟随其后的是一个以UTF-8格式编码的字符串, 用来描述应用消息的内容. <code>内容类型</code> 必须是UTF-8编码的字符串, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 所定义 [MQTT-3.3.2-19].<br>包含多个<code>内容类型</code>将造成协议错误(Protocol Error). <code>内容类型</code>的值由发送应用程序和接收应用程序确定.</p>
<p>服务端必须把收到的应用消息中的<code>内容类型</code>原封不动的发送给所有的订阅者 [MQTT-3.3.2-20].</p>
<pre><code>非规范评注
UTF-8编码字符串可以使用一个MIME`内容类型`字符串来描述应用消息的内容. 由于发送程序和接收程序负责内容类型字符串的定义和解释, 因此MQTT服务端只确保`内容类型`是有效的UTF-8编码的字符串, 不会做其他方面的验证.

非规范评注
图 3-9 是一个PUBLISH示例报文, 其中主题名为a/b, 报文标识符为10, 没有属性.</code></pre><ul>
<li>图 3-9 PUBLISH报文可变报头非规范示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主题名</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 1</td>
<td align="left">长度Length MSB (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">长度Length LSB (3)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left"><code>a</code>(0x61)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left"><code>/</code>(0x2F)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 5</td>
<td align="left"><code>b</code>(0x62)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">报文标识符</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 6</td>
<td align="left">报文标识符MSB (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 7</td>
<td align="left">报文标识符LSB (10)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">属性长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 15</td>
<td align="left">无属性</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="3-3-3-PUBLISH载荷"><a href="#3-3-3-PUBLISH载荷" class="headerlink" title="3.3.3 PUBLISH载荷"></a>3.3.3 PUBLISH载荷</h4><p>载荷包含将被发布的应用消息. 载荷的内容和格式由应用程序指定. 有效载荷的长度这样计算:用固定报头中的剩余长度字段的值减去可变报头的长度. 包含零长度有效载荷的<code>PUBLISH</code>报文是合法的.</p>
<h4 id="3-3-4-PUBLISH行为"><a href="#3-3-4-PUBLISH行为" class="headerlink" title="3.3.4 PUBLISH行为"></a>3.3.4 PUBLISH行为</h4><p><code>PUBLISH</code>报文的接收端<strong>必须</strong>按照<code>PUBLISH</code>报文中的<code>QoS等级</code>发送响应报文 [MQTT-3.3.4-1].</p>
<p>表 3-3 PUBLISH报文的预期响应</p>
<table>
<thead>
<tr>
<th align="left">服务质量等级</th>
<th align="left">预期响应</th>
</tr>
</thead>
<tbody><tr>
<td align="left">QoS 0</td>
<td align="left">无响应</td>
</tr>
<tr>
<td align="left">QoS 1</td>
<td align="left">PUBACK报文</td>
</tr>
<tr>
<td align="left">QoS 2</td>
<td align="left">PUBREC报文</td>
</tr>
</tbody></table>
<p>客户端使用<code>PUBLISH</code>报文发送应用消息给服务端, 目的是分发到其他订阅匹配的客户端.</p>
<p>服务端使用<code>PUBLISH</code>报文发送应用消息给每一个订阅匹配的客户端. <code>PUBLISH</code>报文包含<code>SUBSCRIBE</code>报文中承载的订阅标识符–如果存在的话.</p>
<p>客户端使用带通配符的主题过滤器请求订阅时, 客户端的订阅可能会重叠, 因此发布的消息可能会匹配多个主题过滤器. 这种情况下, 服务端<strong>必须</strong>按照所有匹配的订阅中最大的QoS等级把消息发送给客户端 [MQTT-3.3.4-2]. 此外, 服务端<strong>可以</strong>为每一个匹配的订阅按照订阅时的QoS等级, 把消息副本分发给客户端.</p>
<p>如果客户端收到一个未经请求的应用消息(没有匹配任何订阅), 且<code>QoS</code>大于客户端指定的<code>最大服务质量(Maximum QoS)</code>, 客户端使用包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>DISCONNECT</code>报文断开连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<p>如果客户端在这些重叠的订阅中指定了订阅标识符, 服务端在发布这些订阅相匹配的消息时<strong>必须</strong>包含这些订阅标识符 [MQTT-3.3.4-3]. 如果服务端对这些重叠的订阅只发送一条相匹配的消息, 服务端<strong>必须</strong>在<code>PUBLISH</code>报文中包含所有的相匹配的订阅标识符(如果存在), 但没有顺序要求 [MQTT-3.3.4-4]. 如果服务端对这些重叠的订阅<strong>必须</strong>分别发送相匹配的消息, 则每个<code>PUBLISH</code>报文中含与订阅相匹配的订阅标识符(如果存在) [MQTT-3.3.4-5].</p>
<p>可能存在客户端对同一个发布消息做了多次订阅, 并且这些订阅中有多个订阅使用了相同的订阅标识符, 这种情况下<code>PUBLISH</code>报文将携带多个相同的订阅标识符.</p>
<p><code>PUBLISH</code>报文中若包含服务端收到的 <code>SUBSCRIBE</code> 报文以外的订阅标识符, 将造成协议错误(Protocol Error). 从客户端发送给服务端的 <code>PUBLISH</code> 报文<strong>不能</strong>包含订阅标识符 [MQTT-3.3.4-6].</p>
<p>对于共享订阅, 发送给某个客户端的 <code>PUBLISH</code> 报文中将只包含该客户端的 <code>SUBSCRIBE</code> 报文中发送的订阅标识符.</p>
<p>收到<code>PUBLISH</code>报文时, 接收端的行为取决于报文的QoS等级, 如 <a href="https://www.zybuluo.com/khan-lau/note/1325300#43-服务质量等级和协议流程" target="_blank" rel="noopener">4.3节</a> 所述.</p>
<p>如果<code>PUBLISH</code>报文包含<code>主题别名</code>, 接收端按照以下方式进行处理:<br>- 1 <code>主题别名</code>为0或大于<code>最大主题别名(Maximum Topic Alias)</code>, 将造成协议错误(Protocol Error), 接收端使用包含原因码为<code>0x94(主题别名无效)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<ul>
<li>2 如果接收端已创建此<code>主题别名</code>的映射,<ul>
<li>a 如果报文包含的主题名长度为0, 接收端使用<code>主题别名</code>对应的主题名处理此报文</li>
<li>b 如果报文包含的主题名长度不为0, 接收端使用此主题名处理此报文, 并更新此<code>主题别名</code>映射到此主题名</li>
</ul>
</li>
<li>3 如果接收端还没有创建此<code>主题别名</code>的映射,<ul>
<li>a 如果报文包含的主题名长度为0, 将造成协议错误, 接收端使用包含原因码为<code>0x82(协议错误)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</li>
<li>b 如果报文包含的主题名长度不为0, 接收端使用此主题名处理此报文, 并为此报文中的<code>主题别名</code>和主题名创建映射关系</li>
</ul>
</li>
</ul>
<pre><code>    非规范评注    如果服务端向客户端分发应用消息时使用了不同的协议级别(比如MQTT v3.1.1)-- 不支持属性或本规范提供的其他功能, 应用消息中的某些信息将丢失, 依赖于这些信息的应用程序可能无法正常工作.</code></pre><p>客户端在收到服务端的<code>PUBACK</code>, <code>PUBCOMP</code>或包含原因码大于等于128的<code>PUBREC</code>报文之前, <strong>不能</strong>发送数量超过服务端的<code>接收最大值(Receive Maximum)</code>的QoS为1和2的<code>PUBLISH</code>报文 [MQTT-3.3.4-7]. 服务端在发送<code>PUBACK</code>或<code>PUBCOMP</code>响应之前, 如果收到数量超过客户端的接收最大值的QoS为1和2的<code>PUBLISH</code>报文, 服务端使用包含原因码为<code>0x93(超出接收最大值)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 更多关于流量控制的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">4.9节</a>.</p>
<p>客户端不能延迟发送任何报文, 除了<code>PUBLISH</code>报文–如果已发送且没有收到确认的<code>PUBLISH</code>报文数量已达到服务端的接收最大值(Receive Maximum) [MQTT-3.3.4-8].接收最大值只应用于当前网络连接.</p>
<pre><code>非规范评注
客户端可以选择发送少于服务端接收最大值的未经确认的PUBLISH报文, 尽管它可以发送更多数量的报文.

非规范评注
客户端可以选择暂停发送QoS为0的报文, 当其暂停发送了QoS为1和2的PUBLISH报文.

非规范评注
如果客户端在收到CONNACK之前发送QoS为1或QoS为2的PUBLISH报文, 客户端有可能被服务器断开连接, 因为它发送了超过服务端接收最大值数量的发布报文.</code></pre><p>服务端在接收到客户端的<code>PUBACK</code>, <code>PUBCOMP</code>或包含原因码大于等于128的<code>PUBREC</code>报文之前, 不能发送数量超过客户端的<code>接收最大值(Receive Maximum)</code>的QoS为1和2的<code>PUBLISH</code>报文 [MQTT-3.3.4-9]. 客户端在发送<code>PUBACK</code>或<code>PUBCOMP</code>响应之前, 如果收到数量超过服务端的接收最大值的QoS为1和2的<code>PUBLISH</code>报文, 客户端使用包含原因码为<code>0x93(超出接收最大值)</code>的<code>DISCONNECT</code>报文断开网络连接, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 更多关于流量控制的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">4.9节</a> .</p>
<p>服务端不能延迟发送任何报文, 除了<code>PUBLISH</code>报文–如果已发送且没有收到确认的<code>PUBLISH</code>报文数量已到达客户端的<code>接收最大值(Receive Maximum)</code> [MQTT-3.3.4-10].</p>
<pre><code>非规范评注
服务端可以选择发送少于客户端接收最大值的未经确认的PUBLISH报文, 尽管它可以发送更多数量的报文.

非规范评注
服务端可以选择暂停发送QoS为0的报文, 当其暂停发送了QoS为1和2的PUBLISH报文.</code></pre><h3 id="3-4-PUBACK-–-发布确认"><a href="#3-4-PUBACK-–-发布确认" class="headerlink" title="3.4 PUBACK – 发布确认"></a>3.4 PUBACK – 发布确认</h3><p><code>PUBACK</code>报文是对<code>QoS 1</code>等级的<code>PUBLISH</code>报文的响应.</p>
<h4 id="3-4-1-PUBACK固定报头"><a href="#3-4-1-PUBACK固定报头" class="headerlink" title="3.4.1 PUBACK固定报头"></a>3.4.1 PUBACK固定报头</h4><ul>
<li>图 3-10 PUBACK报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (4)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>剩余长度字段<br>表示可变报头的长度, 用<code>变长字节整数</code>编码.</p>
<h4 id="3-4-2-PUBACK可变报头"><a href="#3-4-2-PUBACK可变报头" class="headerlink" title="3.4.2 PUBACK可变报头"></a>3.4.2 PUBACK可变报头</h4><p>PUBACK可变报头按顺序包含以下字段:所确认的<code>PUBLISH</code>报文标识符, <code>PUBACK</code>原因码, 属性长度, 属性(Properties). 属性编码规则如2.22节 所述.</p>
<p>图 3 11 – PUBACK报文可变报头</p>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">报文标识符MSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">报文标识符LSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left">PUBACK原因码</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left">属性长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="3-4-2-1-PUBACK原因码"><a href="#3-4-2-1-PUBACK原因码" class="headerlink" title="3.4.2.1 PUBACK原因码"></a>3.4.2.1 PUBACK原因码</h5><p>PUBACK可变报头第3字节是<code>原因码(Reason Code)</code>.剩余长度为2, 则表示使用原因码<code>0x00(成功)</code>.</p>
<ul>
<li>表 3-4 PUBACK原因码</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">16进制</th>
<th align="left">原因码名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">成功</td>
<td align="left">消息被接收.QoS为1的消息已发布.</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">0x10</td>
<td align="left">无匹配的订阅者</td>
<td align="left">消息被接收, 但没有订阅者.只有服务端会发送此原因码.如果服务端得知没有匹 配的订阅者, 服务端可以使用此原因码代替<code>0x00(成功)</code>.</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left">0x80</td>
<td align="left">未指明的错误</td>
<td align="left">接收端不接受此消息, 且不愿意透露错误原因或没有适用的原因码.</td>
</tr>
<tr>
<td align="left">131</td>
<td align="left">0x83</td>
<td align="left">实现特定错误</td>
<td align="left"><code>PUBLISH</code>报文有效, 但不被接收端所接受.</td>
</tr>
<tr>
<td align="left">135</td>
<td align="left">0x87</td>
<td align="left">未授权</td>
<td align="left"><code>PUBLISH</code>报文未授权.</td>
</tr>
<tr>
<td align="left">144</td>
<td align="left">0x90</td>
<td align="left">主题名无效</td>
<td align="left">主题名格式正确, 但未被客户端或服务端所接受.</td>
</tr>
<tr>
<td align="left">145</td>
<td align="left">0x91</td>
<td align="left">报文标识符被占用</td>
<td align="left">报文标识符正被占用.可能表明客户端和服务端之间的会话状态不匹配.</td>
</tr>
<tr>
<td align="left">151</td>
<td align="left">0x97</td>
<td align="left">超出配额</td>
<td align="left">已超出实现限制或管理限制.</td>
</tr>
<tr>
<td align="left">153</td>
<td align="left">0x99</td>
<td align="left">载荷格式无效</td>
<td align="left">载荷格式与载荷格式指示符不匹配.</td>
</tr>
</tbody></table>
<p>服务端或客户端发送<code>PUBACK</code>报文时必须设置其中一种<code>PUBACK</code>原因码 [MQTT-3.4.2-1]. 当原因码为<code>0x00(成功)</code>且没有<code>属性(Properties)</code>时, 原因码和属性长度可以被省略. 在这种情况下, <code>PUBACK</code>剩余长度为2.</p>
<h5 id="3-4-2-2-PUBACK属性"><a href="#3-4-2-2-PUBACK属性" class="headerlink" title="3.4.2.2 PUBACK属性"></a>3.4.2.2 PUBACK属性</h5><h6 id="3-4-2-2-1-属性长度"><a href="#3-4-2-2-1-属性长度" class="headerlink" title="3.4.2.2.1 属性长度"></a>3.4.2.2.1 属性长度</h6><p><code>PUBACK</code>可变报头中属性长度被编码为<code>变长字节整数</code>. 如果剩余长度小于4字节, 则没有属性长度.</p>
<h6 id="3-4-2-2-2-原因字符串"><a href="#3-4-2-2-2-原因字符串" class="headerlink" title="3.4.2.2.2 原因字符串"></a>3.4.2.2.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不能被接收端所解析.</p>
<p>发送端使用此值向接收端提供附加信息. 如果加上<code>原因字符串</code>之后的<code>PUBACK</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端<strong>不能</strong>发送此<code>原因字符串</code> [MQTT-3.4.2-2]. 包含多个<code>原因字符串</code>将造成协议错误(Protocol Error).</p>
<h6 id="3-4-2-2-3-用户属性"><a href="#3-4-2-2-3-用户属性" class="headerlink" title="3.4.2.2.3 用户属性"></a>3.4.2.2.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于提供包括诊断信息在内的附加信息. 如果加上用户属性之后的PUBACK报文长度超出了接收端指定的最大报文长度(Maximum Packet Size), 则发送端<strong>不能</strong>发送此属性 [MQTT-3.4.2-3]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字<strong>可以</strong>多次出现.</p>
<h4 id="3-4-3-PUBACK载荷"><a href="#3-4-3-PUBACK载荷" class="headerlink" title="3.4.3 PUBACK载荷"></a>3.4.3 PUBACK载荷</h4><p><code>PUBACK</code>报文没有有效载荷.</p>
<h4 id="3-4-4-PUBACK行为"><a href="#3-4-4-PUBACK行为" class="headerlink" title="3.4.4 PUBACK行为"></a>3.4.4 PUBACK行为</h4><p>描述见4.3.2节.</p>
<h3 id="3-5-PUBREC-–-发布已接收-QoS-2-第一步"><a href="#3-5-PUBREC-–-发布已接收-QoS-2-第一步" class="headerlink" title="3.5 PUBREC – 发布已接收(QoS 2, 第一步)"></a>3.5 PUBREC – 发布已接收(QoS 2, 第一步)</h3><p><code>PUBREC</code>报文是对<code>QoS 2</code>等级的<code>PUBLISH</code>报文的响应. 它是<code>QoS 2</code>等级协议交换的第二个报文.</p>
<h4 id="3-5-1-PUBREC固定报头"><a href="#3-5-1-PUBREC固定报头" class="headerlink" title="3.5.1 PUBREC固定报头"></a>3.5.1 PUBREC固定报头</h4><p>图 3-12 PUBREC报文固定报头</p>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (5)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>剩余长度字段<br>表示可变报头的长度, 用变长字节整数编码.</p>
<h4 id="3-5-2-PUBREC可变报头"><a href="#3-5-2-PUBREC可变报头" class="headerlink" title="3.5.2 PUBREC可变报头"></a>3.5.2 PUBREC可变报头</h4><p>PUBREC可变报头按顺序包含以下字段:所确认的<code>PUBLISH</code> <code>报文标识符(Packet Identifier)</code>, <code>PUBREC</code> <code>原因码(Reason Code)</code>, <code>属性(Properties)</code>. 属性的编码规则, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p>
<ul>
<li>图 3-13 PUBREC报文可变报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">报文标识符MSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">报文标识符LSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left">PUBREC原因码</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left">属性长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="3-5-2-1-PUBREC原因码"><a href="#3-5-2-1-PUBREC原因码" class="headerlink" title="3.5.2.1 PUBREC原因码"></a>3.5.2.1 PUBREC原因码</h5><p>PUBREC可变报头第3字节是<code>原因码(Reason Code)</code>. 如果剩余长度为2, 则表示使用原因码<code>0x00(成功)</code>.</p>
<ul>
<li>表 3-5 PUBREC原因码</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">16进制</th>
<th align="left">原因码名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">成功</td>
<td align="left">消息被接收.QoS为2的消息已发布.</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">0x10</td>
<td align="left">无匹配的订阅者</td>
<td align="left">消息被接收, 但没有订阅者.只有服务端会发送此原因码.如果服务端得知没有匹配的订阅者, 服务端可以使用此原因码代替<code>0x00(成功)</code>.</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left">0x80</td>
<td align="left">未指明的错误</td>
<td align="left">接收端不接受此消息, 且不愿意透露错误原因或没有适用的原因码.</td>
</tr>
<tr>
<td align="left">135</td>
<td align="left">0x87</td>
<td align="left">未授权</td>
<td align="left"><code>PUBLISH</code>报文未授权.</td>
</tr>
<tr>
<td align="left">144</td>
<td align="left">0x90</td>
<td align="left">主题名无效</td>
<td align="left">主题名格式正确, 但未被客户端或服务端所接受.</td>
</tr>
<tr>
<td align="left">145</td>
<td align="left">0x91</td>
<td align="left">报文标识符被占用</td>
<td align="left">报文标识符正被占用.可能表明客户端和服务端之间的会话状态不匹配.</td>
</tr>
<tr>
<td align="left">151</td>
<td align="left">0x97</td>
<td align="left">超出配额</td>
<td align="left">已超出实现限制或管理限制.</td>
</tr>
<tr>
<td align="left">153</td>
<td align="left">0x99</td>
<td align="left">载荷格式无效</td>
<td align="left">载荷格式与载荷格式指示符不匹配.</td>
</tr>
</tbody></table>
<p>服务端或客户端发送<code>PUBREC</code>报文时<strong>必须</strong>设置其中一种原因码 [MQTT-3.5.2-1]. 当原因码为<code>0x00(成功)</code>且没有<code>属性(Properties)</code>时, 原因码和属性长度<strong>可以</strong>被省略. 在这种情况下, <code>PUBREC</code>剩余长度为2.</p>
<h5 id="3-5-2-2-PUBREC属性"><a href="#3-5-2-2-PUBREC属性" class="headerlink" title="3.5.2.2 PUBREC属性"></a>3.5.2.2 PUBREC属性</h5><h6 id="3-5-2-2-1-属性长度"><a href="#3-5-2-2-1-属性长度" class="headerlink" title="3.5.2.2.1 属性长度"></a>3.5.2.2.1 属性长度</h6><p>PUBREC可变报头的属性长度被编码为<code>变长字节整数</code>. 如果剩余长度小于4, 则表示没有属性长度字段.</p>
<h6 id="3-5-2-2-2-原因字符串"><a href="#3-5-2-2-2-原因字符串" class="headerlink" title="3.5.2.2.2 原因字符串"></a>3.5.2.2.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不应该被接收端所解析.</p>
<p>发送端使用此值向接收端提供附加信息. 如果加上原因字符串之后的<code>PUBREC</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端不能发送此属性 [MQTT-3.5.2-2]. 包含多个原因字符串将造成协议错误(Protocol Error).</p>
<h6 id="3-5-2-2-3-用户属性"><a href="#3-5-2-2-3-用户属性" class="headerlink" title="3.5.2.2.3 用户属性"></a>3.5.2.2.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于提供包括诊断信息在内的附加信息. 如果加上用户属性之后的<code>PUBREC</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端<strong>不能</strong>发送此属性 [MQTT-3.5.2-3].<code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字<strong>可以</strong>多次出现.</p>
<h4 id="3-5-3-PUBREC载荷"><a href="#3-5-3-PUBREC载荷" class="headerlink" title="3.5.3 PUBREC载荷"></a>3.5.3 PUBREC载荷</h4><p>PUBREC报文没有有效载荷.</p>
<h4 id="3-5-4-PUBREC行为"><a href="#3-5-4-PUBREC行为" class="headerlink" title="3.5.4 PUBREC行为"></a>3.5.4 PUBREC行为</h4><p>描述见4.3.3节.</p>
<h3 id="3-6-PUBREL-–-发布释放-QoS-2-第二步"><a href="#3-6-PUBREL-–-发布释放-QoS-2-第二步" class="headerlink" title="3.6 PUBREL – 发布释放(QoS 2, 第二步)"></a>3.6 PUBREL – 发布释放(QoS 2, 第二步)</h3><p>PUBREL报文是对<code>PUBREC</code>报文的响应. 它是 <code>QoS 2</code> 等级协议交换的第三个报文.</p>
<h4 id="3-6-1-PUBREL固定报头"><a href="#3-6-1-PUBREL固定报头" class="headerlink" title="3.6.1 PUBREL固定报头"></a>3.6.1 PUBREL固定报头</h4><ul>
<li>图 3-14 PUBREL报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (6)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>PUBREL固定报头的第3, 2, 1, 0位是保留位, 必须被设置为0, 0, 1, 0. 服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接 [MQTT-3.6.1-1].</p>
<p>剩余长度字段<br>表示可变报头的长度, 被编码为<code>变长字节整数</code>.</p>
<h4 id="3-6-2-PUBREL可变报头"><a href="#3-6-2-PUBREL可变报头" class="headerlink" title="3.6.2 PUBREL可变报头"></a>3.6.2 PUBREL可变报头</h4><p>PUBREL报文的可变报头按顺序包含以下字段:所确认的<code>PUBREC</code>报文标识符, <code>PUBREL</code>原因码, <code>属性(Properties)</code>. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p>
<ul>
<li>图 3-15 PUBREL报文可变报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">报文标识符MSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">报文标识符LSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left">PUBREL原因码</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left">属性长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="3-6-2-1-PUBREL原因码"><a href="#3-6-2-1-PUBREL原因码" class="headerlink" title="3.6.2.1 PUBREL原因码"></a>3.6.2.1 PUBREL原因码</h5><p>可变报头第3字节是PUBREL原因码. 如果剩余长度为2, 则表示使用原因码0x00 (成功).</p>
<p>表 3-6 PUBREL原因码</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">16进制</th>
<th align="left">原因码名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">成功</td>
<td align="left">消息已释放.</td>
</tr>
<tr>
<td align="left">146</td>
<td align="left">0x92</td>
<td align="left">报文标识符未发现</td>
<td align="left">未知的报文标识符. 会话恢复阶段这并非错误, 但其他时间这表明服务端和客户端的会话状态不匹配.</td>
</tr>
</tbody></table>
<p>客户端或服务端发送<code>PUBREL</code>报文时必须设置其中一种<code>PUBREL</code>原因码 [MQTT-3.6.2-1]. 当原因码为<code>0x00(成功)</code>且没有<code>属性(Properties)</code>时, 原因码和属性长度可以被省略. 在这种情况下, <code>PUBREL</code>剩余长度为2.</p>
<h5 id="3-6-2-2-PUBREL属性"><a href="#3-6-2-2-PUBREL属性" class="headerlink" title="3.6.2.2 PUBREL属性"></a>3.6.2.2 PUBREL属性</h5><h6 id="3-6-2-2-1-属性长度"><a href="#3-6-2-2-1-属性长度" class="headerlink" title="3.6.2.2.1 属性长度"></a>3.6.2.2.1 属性长度</h6><p>PUBREL报文可变报头中的属性长度被编码为<code>变长字节整数</code>. 如果剩余长度小于4, 则表示没有属性长度字段.</p>
<h6 id="3-6-2-2-2-原因字符串"><a href="#3-6-2-2-2-原因字符串" class="headerlink" title="3.6.2.2.2 原因字符串"></a>3.6.2.2.2 原因字符串</h6><p>31 (0x1F),<code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不应该被接收端所解析.</p>
<p>发送端使用此值向接收端提供附加信息. 如果加上原因字符串之后的<code>PUBREL</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端不能发送此原因字符串 [MQTT-3.6.2-2]. 包含多个原因字符串将造成协议错误(Protocol Error).</p>
<h6 id="3-6-2-2-3-用户属性"><a href="#3-6-2-2-3-用户属性" class="headerlink" title="3.6.2.2.3 用户属性"></a>3.6.2.2.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于提供包括诊断信息或关于PUBREL的信息. 如果加上用户属性之后的PUBREL报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端不能发送此属性 [MQTT-3.6.2-3]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p>
<h4 id="3-6-3-PUBREL载荷"><a href="#3-6-3-PUBREL载荷" class="headerlink" title="3.6.3 PUBREL载荷"></a>3.6.3 PUBREL载荷</h4><p>PUBREL报文没有有效载荷.</p>
<h4 id="3-6-4-PUBREL行为"><a href="#3-6-4-PUBREL行为" class="headerlink" title="3.6.4 PUBREL行为"></a>3.6.4 PUBREL行为</h4><p>描述见4.3.3节 .</p>
<h3 id="3-7-PUBCOMP-–-发布完成-QoS-2-第三步"><a href="#3-7-PUBCOMP-–-发布完成-QoS-2-第三步" class="headerlink" title="3.7 PUBCOMP – 发布完成(QoS 2, 第三步)"></a>3.7 PUBCOMP – 发布完成(QoS 2, 第三步)</h3><p>PUBCOMP报文是对<code>PUBREL</code>报文的响应. 它是<code>QoS 2</code>等级协议交换的第四个也是最后一个报文.</p>
<h4 id="3-7-1-PUBCOMP固定报头"><a href="#3-7-1-PUBCOMP固定报头" class="headerlink" title="3.7.1 PUBCOMP固定报头"></a>3.7.1 PUBCOMP固定报头</h4><ul>
<li>图 3-16 PUBCOMP报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (7)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>剩余长度字段<br>表示可变报头的长度, 编码为<code>变长字节整数</code>.</p>
<h4 id="3-7-2-PUBCOMP可变报头"><a href="#3-7-2-PUBCOMP可变报头" class="headerlink" title="3.7.2 PUBCOMP可变报头"></a>3.7.2 PUBCOMP可变报头</h4><p>PUBCOMP报文可变报头按顺序包含以下字段:所确认的<code>PUBREL</code>报文标识符, <code>PUBCOMP</code>原因码, <code>属性</code>. <code>属性(Properties)</code>编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p>
<ul>
<li>图 3-17 PUBCOMP报文可变报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">报文标识符MSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">报文标识符LSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left">PUBCOMP原因码</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left">属性长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="3-7-2-1-PUBCOMP原因码"><a href="#3-7-2-1-PUBCOMP原因码" class="headerlink" title="3.7.2.1 PUBCOMP原因码"></a>3.7.2.1 PUBCOMP原因码</h5><p>可变报头第3字节是PUBCOMP原因码. 如果剩余长度为2, 则表示使用原因码<code>0x00(成功)</code>.</p>
<ul>
<li>表 3 7 – PUBCOMP原因码</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">16进制</th>
<th align="left">原因码名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">成功</td>
<td align="left">报文标识符已释放.<code>QoS 2</code>消息已完成发布.</td>
</tr>
<tr>
<td align="left">146</td>
<td align="left">0x92</td>
<td align="left">报文标识符未发现</td>
<td align="left">未知的报文标识符. 会话恢复阶段这并非错误, 但其他时间这表明服务端和客户端的会话状态不匹配.</td>
</tr>
</tbody></table>
<p>服务端或客户端发送<code>PUBCOMP</code>报文时必须设置一种<code>PUBCOMP</code>原因码 [MQTT-3.7.2-1]. 当原因码为0x00(成功)且没有<code>属性(Properties)</code>时, 原因码和属性长度可以被省略. 在这种情况下, <code>PUBCOMP</code>剩余长度为2.</p>
<h5 id="3-7-2-2-PUBCOMP属性"><a href="#3-7-2-2-PUBCOMP属性" class="headerlink" title="3.7.2.2 PUBCOMP属性"></a>3.7.2.2 PUBCOMP属性</h5><h6 id="3-7-2-2-1-属性长度"><a href="#3-7-2-2-1-属性长度" class="headerlink" title="3.7.2.2.1 属性长度"></a>3.7.2.2.1 属性长度</h6><p>PUBCOMP报文可变报头中的属性长度被编码为<code>变长字节整数</code>. 如果剩余长度小于4, 则表示没有属性长度字段.</p>
<h6 id="3-7-2-2-2-原因字符串"><a href="#3-7-2-2-2-原因字符串" class="headerlink" title="3.7.2.2.2 原因字符串"></a>3.7.2.2.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, 不应该被接收端所解析.</p>
<p>发送端使用此值向接收端提供附加信息. 如果加上原因字符串之后的<code>PUBCOMP</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端<strong>不能</strong>发送此原因字符串 [MQTT-3.7.2-2]. 包含多个原因字符串将造成协议错误(Protocol Error).</p>
<h6 id="3-7-2-2-3-用户属性"><a href="#3-7-2-2-3-用户属性" class="headerlink" title="3.7.2.2.3 用户属性"></a>3.7.2.2.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于提供诊断信息或关于其他信息. 如果加上用户属性之后的<code>PUBCOMP</code>报文长度超出了接收端指定的<code>最大报文长度(Maximum Packet Size)</code>, 则发送端<strong>不能</strong>发送此属性 [MQTT-3.7.2-3]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字<strong>可以</strong>多次出现.</p>
<h4 id="3-7-3-PUBCOMP载荷"><a href="#3-7-3-PUBCOMP载荷" class="headerlink" title="3.7.3 PUBCOMP载荷"></a>3.7.3 PUBCOMP载荷</h4><p>PUBCOMP报文没有有效载荷.</p>
<h4 id="3-7-4-PUBCOMP行为"><a href="#3-7-4-PUBCOMP行为" class="headerlink" title="3.7.4 PUBCOMP行为"></a>3.7.4 PUBCOMP行为</h4><p>描述见4.3.3节.</p>
<h3 id="3-8-SUBSCRIBE-订阅请求"><a href="#3-8-SUBSCRIBE-订阅请求" class="headerlink" title="3.8 SUBSCRIBE - 订阅请求"></a>3.8 SUBSCRIBE - 订阅请求</h3><p>客户端向服务端发送<code>SUBSCRIBE</code>报文用于创建一个或多个订阅. 每个订阅(Subscription)注册客户端所感兴趣的一个或多个主题. 服务端向客户端发送<code>PUBLISH</code>报文以转发被发布到符合这些订阅主题的应用消息. <code>SUBSCRIBE</code>报文同样(为每个订阅)指定了服务端可以向其发送的应用消息<code>最大QoS等级</code>.</p>
<h4 id="3-8-1-SUBSCRIBE固定报头"><a href="#3-8-1-SUBSCRIBE固定报头" class="headerlink" title="3.8.1 SUBSCRIBE固定报头"></a>3.8.1 SUBSCRIBE固定报头</h4><ul>
<li>图 3-18 SUBSCRIBE报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (8)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><code>SUBSCRIBE</code>报文固定报头第3, 2, 1, 0比特位是保留位, <strong>必须</strong>被设置为0, 0, 1, 0. 服务端<strong>必须</strong>将其他的任何值都当做是不合法的并关闭网络连接 [MQTT-3.8.1-1].</p>
<p>剩余长度字段<br>表示可变报头的长度加上有效载荷的长度, 被编码为<code>变长字节整数</code>.</p>
<h4 id="3-8-2-SUBSCRIBE可变报头"><a href="#3-8-2-SUBSCRIBE可变报头" class="headerlink" title="3.8.2 SUBSCRIBE可变报头"></a>3.8.2 SUBSCRIBE可变报头</h4><p>SUBSCRIBE报文可变报头按顺序包含以下字段:<code>报文标识符(Packet Identifier)</code>, <code>属性(Properties)</code>. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了更多关于报文标识符的信息. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p>
<pre><code>非规范示例
图 3-19 展示了一个包含报文标识符为10, 且没有属性的SUBSCRIBE可变报头.</code></pre><ul>
<li>图 3-19 SUBSCRIBE可变报头示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">报文标识符MSB(0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">报文标识符LSB(10)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left">属性长度(0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h5 id="3-8-2-1-SUBSCRIBE属性"><a href="#3-8-2-1-SUBSCRIBE属性" class="headerlink" title="3.8.2.1 SUBSCRIBE属性"></a>3.8.2.1 SUBSCRIBE属性</h5><h6 id="3-8-2-1-1-属性长度"><a href="#3-8-2-1-1-属性长度" class="headerlink" title="3.8.2.1.1 属性长度"></a>3.8.2.1.1 属性长度</h6><p>SUBSCRIBE报文可变报头中的属性长度被编码为<code>变长字节整数</code>.</p>
<h6 id="3-8-2-1-2-订阅标识符"><a href="#3-8-2-1-2-订阅标识符" class="headerlink" title="3.8.2.1.2 订阅标识符"></a>3.8.2.1.2 订阅标识符</h6><p>11 (0x0B), <code>订阅标识符(Subscription Identifier)</code>标识符.<br>跟随其后的是一个变长字节整数表示<code>订阅标识符</code>. <code>订阅标识符</code>取值范围从1到268,435,455. <code>订阅标识符</code>的值为0或包含多个<code>订阅标识符</code>将造成协议错误(Protocol Error).</p>
<p><code>订阅标识符</code>与<code>SUBSCRIBE</code>报文所创建或修改的订阅(Subscription)相关联. 如果包含<code>订阅标识符</code>, 它将与订阅一起被存储. 如果未指定此属性, 则订阅被存储时将不包含<code>订阅标识符</code>.</p>
<p>更多关于<code>订阅标识符</code>的处理信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3831-订阅选项" target="_blank" rel="noopener">3.8.3.1节</a> .</p>
<h6 id="3-8-2-1-3-用户属性"><a href="#3-8-2-1-3-用户属性" class="headerlink" title="3.8.2.1.3 用户属性"></a>3.8.2.1.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对.</p>
<p><code>用户属性</code>允许出现多次, 以表示多个名字/值对. 同样的名字允许出现多次.</p>
<pre><code>非规范评注
SUBSCRIBE报文的用户属性可以被客户端用来向服务端发送订阅相关的属性.本规范不定义这些属性的意义.</code></pre><h4 id="3-8-3-SUBSCRIBE载荷"><a href="#3-8-3-SUBSCRIBE载荷" class="headerlink" title="3.8.3 SUBSCRIBE载荷"></a>3.8.3 SUBSCRIBE载荷</h4><p><code>SUBSCRIBE</code>报文的载荷包含一列主题过滤器, 指明客户端希望订阅的主题. 主题过滤器必须为UTF-8 编码的字符串 [MQTT-3.8.3-1]. 每个主题过滤器之后跟着一个<code>订阅选项(Subscription Options)</code>字节.</p>
<p>载荷必须包含至少一个主题过滤器/订阅选项对 [MQTT-3.8.3-2]. 不包含载荷的<code>SUBSCRIBE</code>报文将造成协议错误(Protocol Error). 错误处理信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p>
<h5 id="3-8-3-1-订阅选项"><a href="#3-8-3-1-订阅选项" class="headerlink" title="3.8.3.1 订阅选项"></a>3.8.3.1 订阅选项</h5><p>订阅选项的第0和1比特代表<code>最大服务质量</code>字段. 此字段给出服务端可以向此客户端发送的应用消息的<code>最大QoS等级</code>. 最大服务质量字段为3将造成协议错误(Protocol Error).</p>
<p>订阅选项的第2比特表示非本地(No Local)选项. 值为1, 表示应用消息不能被转发给发布此消息的客户标识符 [MQTT-3.8.3-3]. 共享订阅时把非本地选项设为1将造成协议错误(Protocol Error) [MQTT-3.8.3-4].</p>
<p>订阅选项的第3比特表示<code>发布保留(Retain As Published)</code>选项. 值为1, 表示向此订阅转发应用消息时保持消息被发布时设置的<code>保留(RETAIN)</code>标志. 值为0, 表示向此订阅转发应用消息时把保留标志设置为0. 当订阅建立之后, 发送保留消息时保留标志设置为1.</p>
<p>订阅选项的第4和5比特表示保留操作(Retain Handling)选项. 此选项指示当订阅建立时, 是否发送保留消息. 此选项不影响之后的任何保留消息的发送. 如果没有匹配主题过滤器的保留消息, 则此选项所有值的行为都一样. 值可以设置为:</p>
<ul>
<li>0 = 订阅建立时发送保留消息</li>
<li>1 = 订阅建立时, 若该订阅当前不存在则发送保留消息</li>
<li>2 = 订阅建立时不要发送保留消息<br>保留操作的值设置为3将造成协议错误(Protocol Error).</li>
</ul>
<p>订阅选项的第6和7比特为将来所保留. 服务端必须把此保留位非0的<code>SUBSCRIBE</code>报文当做无效报文 [MQTT-3.8.3-5].</p>
<pre><code>非规范评注
非本地(No Local)和发布保留(Retain As Published)订阅选项在客户端把消息发送给其他服务端的情况下, 可以被用来实现桥接.

非规范评注
已存在订阅的情况下不发送保留消息是很有用的, 比如重连完成时客户端不确定订阅是否在之前的会话连接中被创建.

非规范评注
不发送保存的保留消息给新创建的订阅是很有用的, 比如客户端希望接收变更通知且不需要知道最初的状态.

非规范评注
对于某个指示其不支持保留消息的服务端, 发布保留和保留处理选项的所有有效值都将得到同样的结果:订阅时不发送任何保留消息, 且所有消息的保留标志都会被设置为0.</code></pre><ul>
<li>图 3 20 – SUBSCRIBE报文载荷格式</li>
</ul>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主题过滤器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 1</td>
<td align="left">长度Length MSB (0)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">长度Length LSB (3)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 3..N</td>
<td align="left">主题过滤器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">订阅选项</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">保留位</td>
<td align="left">保留处理</td>
<td align="left">RAP</td>
<td align="left">NL</td>
<td align="left">QOS</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte N+1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
</tbody></table>
<p><code>RAP</code>指发布保留(Retain as Published).<br><code>NL</code>指非本地(No Local).</p>
<pre><code>非规范示例
图 3-21 展示了SUBSCRIBE载荷示例, 包含2个主题过滤器:第一个为“a/b” , QoS为1；第二个为“c/d” QoS为2.</code></pre><ul>
<li>图 3-21 载荷字节格式非规范示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主题过滤器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 1</td>
<td align="left">长度Length MSB (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">长度Length LSB (3)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left"><code>a</code>(0x61)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left"><code>/</code>(0x2F)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 5</td>
<td align="left"><code>b</code>(0x62)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">订阅选项</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 6</td>
<td align="left">订阅选项 (1)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">主题过滤器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 7</td>
<td align="left">长度Length MSB (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 8</td>
<td align="left">长度Length LSB (3)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 9</td>
<td align="left"><code>a</code>(0x61)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 10</td>
<td align="left"><code>/</code>(0x2F)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 11</td>
<td align="left"><code>b</code>(0x62)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">订阅选项</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 12</td>
<td align="left">订阅选项 (2)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="3-8-4-SUBSCRIBE行为"><a href="#3-8-4-SUBSCRIBE行为" class="headerlink" title="3.8.4 SUBSCRIBE行为"></a>3.8.4 SUBSCRIBE行为</h4><p>当服务端收到来自客户端的<code>SUBSCRIBE</code>报文时, <strong>必须</strong>使用<code>SUBACK</code>报文作为相应 [MQTT-3.8.4-1]. <code>SUBACK</code>报文<strong>必须</strong>和待确认的<code>SUBSCRIBE</code>报文有相同的报文标识符 [MQTT-3.8.4-2].</p>
<p>允许服务端在发送<code>SUBACK</code>报文之前就开始发送与订阅相匹配的<code>PUBLISH</code>报文.</p>
<p>如果服务端收到的<code>SUBSCRIBE</code>报文中的一个主题过滤器与当前会话的一个<code>非共享订阅(Non-shared Subscription)</code>相同, 那么<strong>必须</strong>使用新的订阅替换现存的订阅 [MQTT-3.8.4-3]. 新订阅的主题过滤器与之前的订阅相同, 但其订阅选项可能不同. 如果保留处理选项为0, 任何匹配该主题过滤器的保留消息<strong>必须</strong>被重发, 但替换订阅<strong>不能</strong>造成应用消息的丢失 [MQTT-3.8.4-4].</p>
<p>如果服务端收到的<code>非共享主题过滤器(Non-shared Topic Filter)</code>不同于当前会话的任何主题过滤器, 一个新的非共享订阅将被创建. 如果保留处理选项不为2, 所有相匹配的保留消息将发送给客户端.</p>
<p>如果服务端收到的主题过滤器与服务端已存在的某个<code>共享订阅(Shared Subscription)</code>主题过滤器相同, 则将此会话添加到该<code>共享订阅</code>中. 不发送任何保留消息.</p>
<p>如果服务端收到的<code>共享订阅主题过滤器(Shared Subscription Topic Filter)</code>与任何已存在的<code>共享订阅主题过滤器</code>都不同, 一个新的共享订阅将被创建. 将此会话作为订阅者添加到该共享订阅. 不发送任何保留消息.</p>
<p>更多关于共享订阅的细节, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#48-订阅" target="_blank" rel="noopener">4.8节</a>.</p>
<p>如果服务端收到的<code>SUBSCRIBE</code>报文包含多个主题过滤器, 服务端<strong>必须</strong>当做收到一系列多个<code>SUBSCRIBE</code>报文来处理–除了将它们的响应组合为单个<code>SUBACK</code>响应 [MQTT-3.8.4-5].</p>
<p>服务端发送给客户端的SUBACK报文<strong>必须</strong>为每一个主题过滤器/订阅选项对包含一个原因码 [MQTT-3.8.4-6]. 此原因码<strong>必须</strong>说明为该订阅授予的<code>最大QoS等级</code>, 或指示订阅失败 [MQTT-3.8.4-7]. 服务端可能授予了低于订阅者所请求的<code>最大QoS等级</code>. 响应该订阅的应用消息<code>QoS等级</code><strong>必须</strong>为该消息发布时的<code>QoS等级</code>和服务端授予的<code>最大QoS等级</code>二者最小值 [MQTT-3.8.4-8]. 在原始消息发布的<code>QoS等级</code>为1, 且授予的<code>最大QoS等级</code>为0的情况下, 服务端允许发送重复的消息副本给订阅者(？).</p>
<pre><code>非规范评注
如果订阅客户端的某个主题过滤器已被授予的最大QoS等级为1, 那么匹配此过滤器的QoS等级为0的应用消息按照QoS等级为0分发给此客户端.这意味着客户端最多只能收到该消息的一个副本.另一方面, 发布到相同主题的QoS等级为2的消息, 其QoS等级被服务端降级为1以便分发给该客户端. 因此该客户端可能收到此消息的多个副本. 

非规范评注
如果订阅客户端被授予的最大QoS等级为0, 那么按照QoS等级为2发布的应用消息在繁忙时可能会丢失, 但服务端不应该发送重复的消息副本. 发布到相同主题的QoS等级为1的消息, 分发给该客户端时可能会丢失或重复.

非规范评注
使用QoS等级2订阅某个主题过滤器, 等于是说:我想要按照消息被发布时的QoS等级接收匹配此过滤器的消息. 这意味着发布者负责决定消息可以被发布的最大QoS等级, 但订阅端可以要求服务端降低该消息的QoS到更适合它的等级.</code></pre><p>订阅标识符是服务端的会话状态的一部分, 并将在收到<code>PUBLISH</code>报文时返回给客户端. 当服务端收到客户端的<code>UNSUBSCRIBE</code>报文时, 服务端将此会话标识符从服务端的会话状态中移除:当服务端收到客户端的<code>UNSUBSCRIBE</code>报文, 当服务端收到客户端对同样主题过滤器的<code>SUBSCRIBE</code>报文但订阅标识符不同或没有订阅标识符, 或者当服务端在<code>CONNACK</code>报文中将会话存在标志设置为0.</p>
<p>订阅标识符不构成客户端的会话状态的一部分. 在一个有用的实现中, 客户端将订阅标识符与其他客户端状态相关联, 此客户端状态将被移除:当客户端取消订阅, 当客户端以不同的订阅标识符或没有订阅标识符订阅同样的主题过滤器, 或者当客户端收到的<code>CONNACK</code>报文中会话存在标志被设置为0.</p>
<p>服务端在重传的<code>PUBLISH</code>报文中无需使用同一组订阅标识符. 客户端可以通过发送包含与当前会话已存在的主题过滤器的<code>SUBSCRIBE</code>报文进行重新订阅. 如果客户端在<code>PUBLISH</code>报文初传之后重新订阅并使用了不同的订阅标识符, 允许服务端在任何重传中使用初传所包含的订阅标识符, 或者在重传中使用此新的订阅标识符. 不允许服务端在发送了包含新的订阅标识符的<code>PUBLISH</code>报文之后再次使用旧的订阅标识符.</p>
<pre><code>非规范评注
使用场景, 用以阐述订阅标识符:
• 客户端实现指示某条发布消息匹配多个订阅的编程接口, 客户端实现每次订阅时生成新的订阅标识符. 如果返回的发布消息包含多个订阅标识符, 则该发布消息匹配多个订阅.

• 客户端实现允许订阅者将消息定向到其相关联的订阅的回调, 客户端实现生成映射到唯一回调的订阅标识符. 收到某条发布消息时, 使用订阅标识符决定触发哪一个回调.

• 客户端实现在发布消息时返回程序用于订阅的主题字符串, 为此客户端生成一个唯一标识了该主题过滤器的标识符. 收到某条发布消息时, 客户端实现使用此标识符查找原始主题过滤器, 并将主题过滤器返回给其应用程序.

• 网关(Gateway)将从服务端收到的发布消息转发给向该网关做了订阅的客户端, 网关实现维护其收到的每个唯一的订阅过滤器到其收到的一组客户标识符--订阅标识符对的映射, 网关对它转发给服务端的每个主题过滤器生成一个唯一的标识符. 收到某条发布消息时, 网关使用从服务端收到的订阅标识符查找对应的客户标识符--订阅标识符对, 并把它们加入发送给客户端的PUBLISH报文中. 如果上游服务端因为消息匹配了多个订阅而发送了多个PUBLISH报文, 则此行为将反映到客户端.</code></pre><p>3.9 SUBACK – 订阅确认<br>服务端发送SUBACK报文给客户端, 用于确认它已收到并且正在处理<code>SUBSCRIBE</code>报文.</p>
<p><code>SUBACK</code>报文包含一个原因码列表, 用于指定授予的<code>最大QoS等级</code>或<code>SUBSCRIBE</code>报文所请求的每个订阅发生的错误.</p>
<h4 id="3-9-1-SUBACK固定报头"><a href="#3-9-1-SUBACK固定报头" class="headerlink" title="3.9.1 SUBACK固定报头"></a>3.9.1 SUBACK固定报头</h4><ul>
<li>图 3-22 SUBACK报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (9)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>剩余长度字段<br>可变报头长度加上有效载荷长度, 编码为<code>变长字节整数</code>.</p>
<h4 id="3-9-2-SUBACK可变报头"><a href="#3-9-2-SUBACK可变报头" class="headerlink" title="3.9.2 SUBACK可变报头"></a>3.9.2 SUBACK可变报头</h4><p>SUBACK报文可变报头按顺序包含以下字段: 所确认的<code>SUBSCRIBE</code>报文标识符, <code>属性(Properties)</code>.</p>
<h5 id="3-9-2-1-SUBACK属性"><a href="#3-9-2-1-SUBACK属性" class="headerlink" title="3.9.2.1 SUBACK属性"></a>3.9.2.1 SUBACK属性</h5><h6 id="3-9-2-1-1-属性长度"><a href="#3-9-2-1-1-属性长度" class="headerlink" title="3.9.2.1.1 属性长度"></a>3.9.2.1.1 属性长度</h6><p>SUBACK可变报头中的属性长度被编码为<code>变长字节整数</code>.</p>
<h6 id="3-9-2-1-2-原因字符串"><a href="#3-9-2-1-2-原因字符串" class="headerlink" title="3.9.2.1.2 原因字符串"></a>3.9.2.1.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, <strong>不应该</strong>被客户端所解析.</p>
<p>服务端使用此值向客户端提供附加信息. 如果加上原因字符串之后的<code>SUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此原因字符串 [MQTT-3.9.2-1]. 包含多个原因字符串将造成协议错误(Protocol Error).</p>
<h6 id="3-9-2-1-3-用户属性"><a href="#3-9-2-1-3-用户属性" class="headerlink" title="3.9.2.1.3 用户属性"></a>3.9.2.1.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对.此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上用户属性之后的SUBACK报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此属性 [MQTT-3.9.2-2]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p>
<ul>
<li>图 3-23 SUBACK报文可变报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">报文标识符MSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">报文标识符LSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="3-9-3-SUBACK载荷"><a href="#3-9-3-SUBACK载荷" class="headerlink" title="3.9.3 SUBACK载荷"></a>3.9.3 SUBACK载荷</h4><p>有效载荷包含一个原因码列表. 每个原因码对应SUBSCRIBE报文中的一个被确认的主题过滤器. SUBACK报文中的原因码顺序必须与SUBSCRIBE报文中的主题过滤器顺序相匹配 [MQTT-3.9.3-1].</p>
<ul>
<li>表 3-8 订阅原因码</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">16进制</th>
<th align="left">原因码名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">授予QoS等级0</td>
<td align="left">订阅被接受且最大QoS等级为0.可能低于所请求的QoS等级.</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0x01</td>
<td align="left">授予QoS等级1</td>
<td align="left">订阅被接受且最大QoS等级为1.可能低于所请求的QoS等级.</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">0x02</td>
<td align="left">授予QoS等级2</td>
<td align="left">订阅被接受且任何QoS等级都将被发送给此订阅.</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left">0x80</td>
<td align="left">未指明错误</td>
<td align="left">订阅未被接受, 且服务端不愿意透露原因或没有适用的原因码.</td>
</tr>
<tr>
<td align="left">131</td>
<td align="left">0x83</td>
<td align="left">实现特定错误</td>
<td align="left">SUBSCRIBE有效但不被服务端所接受.</td>
</tr>
<tr>
<td align="left">135</td>
<td align="left">0x87</td>
<td align="left">未授权</td>
<td align="left">客户端未被授权做此订阅.</td>
</tr>
<tr>
<td align="left">143</td>
<td align="left">0x8F</td>
<td align="left">主题过滤器无效</td>
<td align="left">主题过滤器格式正确, 但不被允许.</td>
</tr>
<tr>
<td align="left">145</td>
<td align="left">0x91</td>
<td align="left">报文标识符已占用</td>
<td align="left">指定的报文标识符正在被使用中.</td>
</tr>
<tr>
<td align="left">151</td>
<td align="left">0x97</td>
<td align="left">超出配额</td>
<td align="left">已超出实现限制或管理限制.</td>
</tr>
<tr>
<td align="left">158</td>
<td align="left">0x9E</td>
<td align="left">共享订阅不支持</td>
<td align="left">服务端不支持此客户端进行共享订阅.</td>
</tr>
<tr>
<td align="left">161</td>
<td align="left">0xA1</td>
<td align="left">订阅标识符不支持</td>
<td align="left">服务端不支持订阅标识符；订阅标识符不被接受.</td>
</tr>
<tr>
<td align="left">162</td>
<td align="left">0xA2</td>
<td align="left">通配符订阅不支持</td>
<td align="left">服务端不支持通配符订阅；订阅未被接受.</td>
</tr>
</tbody></table>
<p>服务端发送SUBACK报文时必须对收到的每一个主题过滤器设置一种原因码 [MQTT-3.9.3-2].</p>
<pre><code>非规范评注
对于SUBSCRIBE报文中的每个主题过滤器, 总有一个对应的原因码. 如果原因码不是针对某个特定的主题过滤器(比如0x91(报文标识符已占用)), 则对每个主题过滤器都使用此原因码.</code></pre><h3 id="3-10-UNSUBSCRIBE-–-取消订阅请求"><a href="#3-10-UNSUBSCRIBE-–-取消订阅请求" class="headerlink" title="3.10 UNSUBSCRIBE – 取消订阅请求"></a>3.10 UNSUBSCRIBE – 取消订阅请求</h3><p>客户端发送UNSUBSCRIBE报文给服务端, 用于取消订阅主题.</p>
<h4 id="3-10-1-UNSUBSCRIBE固定报头"><a href="#3-10-1-UNSUBSCRIBE固定报头" class="headerlink" title="3.10.1 UNSUBSCRIBE固定报头"></a>3.10.1 UNSUBSCRIBE固定报头</h4><p>图 3-28 – UNSUBSCRIBE报文固定报头</p>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (10)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>UNSUBSCRIBE固定报头的第3, 2, 1, 0位是保留位且<strong>必须</strong>分别设置为0, 0, 1, 0. 服务端<strong>必须</strong>认为任何其它的值都是不合法的并关闭网络连接 [MQTT-3.10.1-1].</p>
<p>剩余长度字段<br>等于可变报头长度(2字节)加上有效载荷长度, 编码为<code>变长字节整数</code>.</p>
<h4 id="3-10-2-UNSUBSCRIBE可变报头"><a href="#3-10-2-UNSUBSCRIBE可变报头" class="headerlink" title="3.10.2 UNSUBSCRIBE可变报头"></a>3.10.2 UNSUBSCRIBE可变报头</h4><p>UNSUBSCRIBE报文可变报头按顺序包含以下字段:<code>报文标识符</code>和<code>属性(Properties)</code>. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了有关报文标识符的更多信息. 属性的编码规则, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p>
<h4 id="3-10-2-1-UNSUBSCRIBE属性"><a href="#3-10-2-1-UNSUBSCRIBE属性" class="headerlink" title="3.10.2.1 UNSUBSCRIBE属性"></a>3.10.2.1 UNSUBSCRIBE属性</h4><h6 id="3-10-2-1-1-属性长度"><a href="#3-10-2-1-1-属性长度" class="headerlink" title="3.10.2.1.1 属性长度"></a>3.10.2.1.1 属性长度</h6><p>SUBSCRIBE可变报头中属性的长度被编码为<code>变长字节整数</code>.</p>
<h6 id="3-10-2-1-2-用户属性"><a href="#3-10-2-1-2-用户属性" class="headerlink" title="3.10.2.1.2 用户属性"></a>3.10.2.1.2 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是一个UTF-8字符串对.</p>
<p>用户属性允许出现多次, 以表示多个名字/值对. 相同的名字可以出现多次.</p>
<pre><code>非规范评注
UNSUBSCRIBE报文中的用户属性可以被客户端用来向服务端发送订阅相关的属性. 本规范不定义这些属性的意义.</code></pre><h4 id="3-10-3-UNSUBSCRIBE载荷"><a href="#3-10-3-UNSUBSCRIBE载荷" class="headerlink" title="3.10.3 UNSUBSCRIBE载荷"></a>3.10.3 UNSUBSCRIBE载荷</h4><p>UNSUBSCRIBE报文有效载荷包含一列客户端希望取消订阅的主题过滤器. <code>UNSUBSCRIBE</code>报文中的<code>主题过滤器</code><strong>必须</strong>为<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> 所述的UTF-8编码字符串 [MQTT-3.10.3-1], 且连续填充.</p>
<p><code>UNSUBSCRIBE</code>报文有效载荷<strong>必须</strong>包含至少一个<code>主题过滤器</code> [MQTT-3.10.3-2]. 不包含有效载荷的<code>UNSUBSCRIBE</code>报文将造成协议错误(Protocol Error). 错误处理信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>.</p>
<pre><code>非规范示例
图 3-30 展示了UNSUBSCRIBE报文的载荷示例, 包括两个主题过滤器 “a/b”和“c/d”.</code></pre><p>图 3-30 - 载荷字节格式非规范示例</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主题过滤器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 1</td>
<td align="left">长度Length MSB (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">长度Length LSB (3)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left"><code>a</code>(0x61)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left"><code>/</code>(0x2F)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 5</td>
<td align="left"><code>b</code>(0x62)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">主题过滤器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 6</td>
<td align="left">长度Length MSB (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 7</td>
<td align="left">长度Length LSB (3)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 8</td>
<td align="left"><code>c</code>(0x61)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 9</td>
<td align="left"><code>/</code>(0x2F)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 10</td>
<td align="left"><code>d</code>(0x62)</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="3-10-4-UNSUBSCRIBE行为"><a href="#3-10-4-UNSUBSCRIBE行为" class="headerlink" title="3.10.4 UNSUBSCRIBE行为"></a>3.10.4 UNSUBSCRIBE行为</h4><p>服务端<strong>必须</strong>对客户端的<code>UNSUBSCRIBE</code>报文中提供的主题过滤器(不管是否包含通配符)逐个字符与当前持有的主题过滤器集进行比较. 如果任何过滤器完全匹配, 则<strong>必须</strong>删除其拥有的订阅 [MQTT-3.10.4-1], 否则不会进行额外的处理.</p>
<p>当服务端收到<code>UNSUBSCRIBE</code>报文:</p>
<ul>
<li></li>
<li><p>它<strong>必须</strong>停止添加为了交付给客户端的与主题过滤器相匹配的任何新消息 [MQTT-3.10.4-2].</p>
</li>
<li><p>它必须完成任何已经开始发送给客户端的、与主题过滤器相匹配的、QoS等级为1或2的消息 [MQTT-3.10.4-3].</p>
</li>
<li><p>它<strong>可以</strong>继续交付任何为交付给客户端而缓存的消息.</p>
</li>
</ul>
<p>服务端必须发送<code>UNSUBACK</code>报文以响应客户端的<code>UNSUBSCRIBE</code>请求 [MQTT-3.10.4-4]. <code>UNSUBACK</code>报文<strong>必须</strong>包含和<code>UNSUBSCRIBE</code>报文相同的报文标识符. 即使没有删除任何主题订阅, 服务端也<strong>必须</strong>发送一个<code>UNSUBACK</code>响应 [MQTT-3.10.4-5].</p>
<p>如果服务端收到的<code>UNSUBSCRIBE</code>报文包含多个主题过滤器, 服务端<strong>必须</strong>当做收到一系列多个<code>UNSUBSCRIBE</code>报文来处理–除了将它们的响应组合为单个<code>SUBACK</code>响应 [MQTT-3.10.4-6].</p>
<p>如果某个主题过滤器代表一个共享订阅, 此会话将被从该共享订阅中删除. 如果此会话是该共享订阅所关联的唯一会话, 该共享订阅被删除. 共享订阅的处理, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">4.8.2节</a>.</p>
<h3 id="3-11-UNSUBACK-–-取消订阅确认"><a href="#3-11-UNSUBACK-–-取消订阅确认" class="headerlink" title="3.11 UNSUBACK – 取消订阅确认"></a>3.11 UNSUBACK – 取消订阅确认</h3><p>服务端发送UNSUBACK报文给客户端用于确认收到<code>UNSUBSCRIBE</code>报文.</p>
<h4 id="3-11-1-UNSUBACK固定报头"><a href="#3-11-1-UNSUBACK固定报头" class="headerlink" title="3.11.1 UNSUBACK固定报头"></a>3.11.1 UNSUBACK固定报头</h4><ul>
<li>图 3-31 UNSUBACK报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (11)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>剩余长度字段<br>等于可变报头的长度加上有效载荷的长度, 编码为<code>变长字节整数</code>.</p>
<h4 id="3-11-2-UNSUBACK可变报头"><a href="#3-11-2-UNSUBACK可变报头" class="headerlink" title="3.11.2 UNSUBACK可变报头"></a>3.11.2 UNSUBACK可变报头</h4><p>UNSUBACK报文可变报头按顺序包含以下字段:所确认的<code>UNSUBSCRIBE</code>报文标识符和属性( Properties). 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p>
<ul>
<li>图 3-32 UNSUBACK报文可变报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">报文标识符MSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">报文标识符LSB</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="3-11-2-1-UNSUBACK属性"><a href="#3-11-2-1-UNSUBACK属性" class="headerlink" title="3.11.2.1 UNSUBACK属性"></a>3.11.2.1 UNSUBACK属性</h5><h6 id="3-11-2-1-1-属性长度"><a href="#3-11-2-1-1-属性长度" class="headerlink" title="3.11.2.1.1 属性长度"></a>3.11.2.1.1 属性长度</h6><p>UNSUBACK报文可变报头中的属性的长度被编码为<code>变长字节整数</code>.</p>
<h6 id="3-11-2-1-2-原因字符串"><a href="#3-11-2-1-2-原因字符串" class="headerlink" title="3.11.2.1.2 原因字符串"></a>3.11.2.1.2 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码的字符串, 表示此次响应相关的原因. 此<code>原因字符串(Reason String)</code>是为诊断而设计的可读字符串, <strong>不应该</strong>被客户端所解析.</p>
<p>服务端使用此值向客户端提供附加信息. 如果加上原因字符串之后的<code>UNSUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此原因字符串 [MQTT-3.11.2-1]. 包含多个原因字符串将造成协议错误(Protocol Error).</p>
<h6 id="3-11-2-1-3-用户属性"><a href="#3-11-2-1-3-用户属性" class="headerlink" title="3.11.2.1.3 用户属性"></a>3.11.2.1.3 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上用户属性之后的<code>UNSUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此属性 [MQTT-3.11.2-2]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p>
<h4 id="3-11-3-UNSUBACK载荷"><a href="#3-11-3-UNSUBACK载荷" class="headerlink" title="3.11.3 UNSUBACK载荷"></a>3.11.3 UNSUBACK载荷</h4><p>有效载荷包含一个原因码列表. 每个原因码对应<code>UNSUBSCRIBE</code>报文中的一个被确认的主题过滤器. <code>UNSUBACK</code>报文中的原因码顺序<strong>必须</strong>与<code>UNSUBSCRIBE</code>报文中的主题过滤器顺序相匹配 [MQTT-3.11.3-1].</p>
<p>单字节无符号取消订阅原因码的值如下所示. 服务端发送<code>UNSUBACK</code>报文时对于每个收到的主题过滤器, <strong>必须</strong>使用一个取消订阅原因码 [MQTT-3.11.3-2].</p>
<ul>
<li>表 3-9 取消订阅原因码</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">16进制</th>
<th align="left">原因码名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">成功</td>
<td align="left">订阅已被删除.</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">0x11</td>
<td align="left">订阅未发现</td>
<td align="left">没有该客户端匹配的主题过滤器被使用.</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left">0x80</td>
<td align="left">未指定错误</td>
<td align="left">取消订阅不能被完成且服务端不愿意透露原因或没有其他适用的原因码.</td>
</tr>
<tr>
<td align="left">131</td>
<td align="left">0x83</td>
<td align="left">实现指定错误</td>
<td align="left">UNSUBSCRIBE报文有效, 但服务端不接受.</td>
</tr>
<tr>
<td align="left">135</td>
<td align="left">0x87</td>
<td align="left">未授权</td>
<td align="left">客户端未被授权进行取消订阅.</td>
</tr>
<tr>
<td align="left">143</td>
<td align="left">0x8F</td>
<td align="left">主题过滤器无效</td>
<td align="left">主题过滤器格式正确, 但不被允许.</td>
</tr>
<tr>
<td align="left">145</td>
<td align="left">0x91</td>
<td align="left">报文标识符已占用</td>
<td align="left">指定的报文标识符正在被使用中.</td>
</tr>
</tbody></table>
<pre><code>非规范评注
对于UNSUBSCRIBE报文中的每个主题过滤器, 总有一个对应的原因码. 如果原因码不是针对某个特定的主题过滤器(比如0x91(报文标识符已占用)), 则对每个主题过滤器都使用此原因码.</code></pre><h3 id="3-12-PINGREQ-–-PING请求"><a href="#3-12-PINGREQ-–-PING请求" class="headerlink" title="3.12 PINGREQ – PING请求"></a>3.12 PINGREQ – PING请求</h3><p>客户端发送<code>PINGREQ</code>报文给服务端, 可被用于:</p>
<ul>
<li>在没有任何其他MQTT控制报文从客户端发给服务端时, 告知服务端客户端还活着.</li>
<li>请求服务端发送响应以确认服务端还活着.</li>
<li>使用网络已确认网络连接没有断开.</li>
</ul>
<p>此报文被用在<code>保持连接(Keep Alive)</code>的处理中. 详细信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#31210-保持连接" target="_blank" rel="noopener">3.1.2.10节</a>.</p>
<h4 id="3-12-1-PINGREQ固定报头"><a href="#3-12-1-PINGREQ固定报头" class="headerlink" title="3.12.1 PINGREQ固定报头"></a>3.12.1 PINGREQ固定报头</h4><ul>
<li>图 3-33 PINGREQ报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (12)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="3-12-2-PINGREQ可变报头"><a href="#3-12-2-PINGREQ可变报头" class="headerlink" title="3.12.2 PINGREQ可变报头"></a>3.12.2 PINGREQ可变报头</h4><p>PINGREQ报文没有可变报头.</p>
<h4 id="3-12-3-PINGREQ载荷"><a href="#3-12-3-PINGREQ载荷" class="headerlink" title="3.12.3 PINGREQ载荷"></a>3.12.3 PINGREQ载荷</h4><p>PINGREQ报文没有有效载荷</p>
<h4 id="3-12-4-PINGREQ行为"><a href="#3-12-4-PINGREQ行为" class="headerlink" title="3.12.4 PINGREQ行为"></a>3.12.4 PINGREQ行为</h4><p>服务端<strong>必须</strong>发送<code>PINGRESP</code>报文响应客户端的<code>PINGREQ</code>报文 [MQTT-3.12.4-1].</p>
<h3 id="3-13-PINGRESP-–-PING响应"><a href="#3-13-PINGRESP-–-PING响应" class="headerlink" title="3.13 PINGRESP – PING响应"></a>3.13 PINGRESP – PING响应</h3><p>服务端发送PINGRESP报文响应客户端的<code>PINGREQ</code>报文.表示服务端还活着.</p>
<p>此报文被用在<code>保持连接(Keep Alive)</code>的处理中.详细信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#31210-保持连接" target="_blank" rel="noopener">3.1.2.10节</a>.</p>
<h4 id="3-13-1-PINGRESP固定报头"><a href="#3-13-1-PINGRESP固定报头" class="headerlink" title="3.13.1 PINGRESP固定报头"></a>3.13.1 PINGRESP固定报头</h4><ul>
<li>图 3-34 – PINGRESP报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (13)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="3-13-2-PINGRESP可变报头"><a href="#3-13-2-PINGRESP可变报头" class="headerlink" title="3.13.2 PINGRESP可变报头"></a>3.13.2 PINGRESP可变报头</h4><p>PINGRESP报文没有可变报头.</p>
<h4 id="3-13-3-PINGRESP载荷"><a href="#3-13-3-PINGRESP载荷" class="headerlink" title="3.13.3 PINGRESP载荷"></a>3.13.3 PINGRESP载荷</h4><p>PINGRESP报文没有有效载荷.</p>
<h4 id="3-13-4-PINGRESP行为"><a href="#3-13-4-PINGRESP行为" class="headerlink" title="3.13.4 PINGRESP行为"></a>3.13.4 PINGRESP行为</h4><p>客户端收到此报文时不做任何处理.</p>
<h3 id="3-14-DISCONNECT-–-断开通知"><a href="#3-14-DISCONNECT-–-断开通知" class="headerlink" title="3.14 DISCONNECT – 断开通知"></a>3.14 DISCONNECT – 断开通知</h3><p><code>DISCONNECT</code>报文是客户端发给服务端的最后一个MQTT控制报文. 表示客户端为什么断开网络连接的原因. 客户端和服务端在关闭网络连接之前可以发送一个<code>DISCONNECT</code>报文. 如果在客户端没有首先发送包含原因码为<code>0x00(正常断开)</code> <code>DISCONNECT</code>报文并且连接包含遗嘱消息的情况下, 遗嘱消息会被发布. 更多细节, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a>.</p>
<p>服务端不能发送<code>DISCONNECT</code>报文, 直到它发送了包含原因码小于0x80的<code>CONNACK</code>报文之后 [MQTT-3.14.0-1].</p>
<h4 id="3-14-1-DISCONNECT固定报头"><a href="#3-14-1-DISCONNECT固定报头" class="headerlink" title="3.14.1 DISCONNECT固定报头"></a>3.14.1 DISCONNECT固定报头</h4><ul>
<li>图 3-35 DISCONNECT报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (14)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>服务端或客户端<strong>必须</strong>验证所有的保留位都被设置为0, 如果他们不为0, 发送包含原因码为<code>0x81(无效报文)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述 [MQTT-3.14.1-1].</p>
<p>剩余长度字段<br>等于可变报头的长度, 编码为<code>变长字节整数</code>.</p>
<h4 id="3-14-2-DISCONNECT可变报头"><a href="#3-14-2-DISCONNECT可变报头" class="headerlink" title="3.14.2 DISCONNECT可变报头"></a>3.14.2 DISCONNECT可变报头</h4><p>DISCONNECT报文的可变报头按顺序包含以下字段:<code>断开原因码</code>, <code>属性(Properties)</code>. 属性的编码规则如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p>
<h4 id="3-14-2-1-断开原因码"><a href="#3-14-2-1-断开原因码" class="headerlink" title="3.14.2.1 断开原因码"></a>3.14.2.1 断开原因码</h4><p>可变报头的第1个字节是断开原因码. 如果剩余长度小于1, 则表示使用原因码<code>0x00(正常断开)</code>.</p>
<p>单字节无符号断开原因码字段如下所示.</p>
<ul>
<li>表 3-10 断开原因值</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">16进制</th>
<th align="left">原因码名称</th>
<th align="left">发送端</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">正常断开</td>
<td align="left">客户端或服务端</td>
<td align="left">正常关闭连接.不发送遗嘱.</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">0x04</td>
<td align="left">包含遗嘱消息的断开</td>
<td align="left">客户端</td>
<td align="left">客户端希望断开但也需要服务端发布它的遗嘱消息.</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left">0x80</td>
<td align="left">未指定错误</td>
<td align="left">客户端或服务端</td>
<td align="left">连接被关闭, 但发送端不愿意透露原因, 或者没有其他适用的原因码.</td>
</tr>
<tr>
<td align="left">129</td>
<td align="left">0x81</td>
<td align="left">无效的报文</td>
<td align="left">客户端或服务端</td>
<td align="left">收到的报文不符合本规范.</td>
</tr>
<tr>
<td align="left">130</td>
<td align="left">0x82</td>
<td align="left">协议错误</td>
<td align="left">客户端或服务端</td>
<td align="left">收到意外的或无序的报文.</td>
</tr>
<tr>
<td align="left">131</td>
<td align="left">0x83</td>
<td align="left">实现指定错误</td>
<td align="left">客户端或服务端</td>
<td align="left">收到的报文有效, 但根据实现无法进行处理.</td>
</tr>
<tr>
<td align="left">135</td>
<td align="left">0x87</td>
<td align="left">未授权</td>
<td align="left">服务端</td>
<td align="left">请求没有被授权</td>
</tr>
<tr>
<td align="left">137</td>
<td align="left">0x89</td>
<td align="left">服务端正忙</td>
<td align="left">服务端</td>
<td align="left">服务端正忙且不能继续处理此客户端的请求.</td>
</tr>
<tr>
<td align="left">139</td>
<td align="left">0x8B</td>
<td align="left">服务正关闭</td>
<td align="left">服务端</td>
<td align="left">服务正在关闭.</td>
</tr>
<tr>
<td align="left">141</td>
<td align="left">0x8D</td>
<td align="left">保持连接超时</td>
<td align="left">服务端</td>
<td align="left">连接因为在超过1.5倍的保持连接时间内没有收到任何报文而关闭.</td>
</tr>
<tr>
<td align="left">142</td>
<td align="left">0x8E</td>
<td align="left">会话被接管</td>
<td align="left">服务端</td>
<td align="left">另一个使用了相同的客户标识符的连接已建立, 导致此连接关闭.</td>
</tr>
<tr>
<td align="left">143</td>
<td align="left">0x8F</td>
<td align="left">主题过滤器无效</td>
<td align="left">服务端</td>
<td align="left">主题过滤器格式正确, 但不被服务端所接受.</td>
</tr>
<tr>
<td align="left">144</td>
<td align="left">0x90</td>
<td align="left">主题名无效</td>
<td align="left">客户端或服务端</td>
<td align="left">主题名格式正确, 但不被客户端或服务端所接受.</td>
</tr>
<tr>
<td align="left">147</td>
<td align="left">0x93</td>
<td align="left">超出接收最大值</td>
<td align="left">客户端或服务端</td>
<td align="left">客户端或服务端收到了数量超过接收最大值的未发送PUBACK或PUBCOMP的发布消息.</td>
</tr>
<tr>
<td align="left">148</td>
<td align="left">0x94</td>
<td align="left">主题别名无效</td>
<td align="left">客户端或服务端</td>
<td align="left">客户端或服务端收到的PUBLISH报文包含的主题别名大于其在CONNECT或CONNACK中发送的主题别名最大值.</td>
</tr>
<tr>
<td align="left">149</td>
<td align="left">0x95</td>
<td align="left">报文过大</td>
<td align="left">客户端或服务端</td>
<td align="left">报文长度大于此客户端或服务端的最大报文长度.</td>
</tr>
<tr>
<td align="left">150</td>
<td align="left">0x96</td>
<td align="left">消息速率过高</td>
<td align="left">客户端或服务端</td>
<td align="left">收到的数据速率太高.</td>
</tr>
<tr>
<td align="left">151</td>
<td align="left">0x97</td>
<td align="left">超出配额</td>
<td align="left">客户端或服务端</td>
<td align="left">已超出实现限制或管理限制.</td>
</tr>
<tr>
<td align="left">152</td>
<td align="left">0x98</td>
<td align="left">管理操作</td>
<td align="left">客户端或服务端</td>
<td align="left">连接因为管理操作被关闭.</td>
</tr>
<tr>
<td align="left">153</td>
<td align="left">0x99</td>
<td align="left">载荷格式无效</td>
<td align="left">客户端或服务端</td>
<td align="left">载荷格式与指定的载荷格式指示符不匹配.</td>
</tr>
<tr>
<td align="left">154</td>
<td align="left">0x9A</td>
<td align="left">不支持保留</td>
<td align="left">服务端</td>
<td align="left">服务端不支持保留消息.</td>
</tr>
<tr>
<td align="left">155</td>
<td align="left">0x9B</td>
<td align="left">不支持的QoS等级</td>
<td align="left">服务端</td>
<td align="left">客户端指定的QoS等级大于CONNACK报文中指定的最大QoS等级.</td>
</tr>
<tr>
<td align="left">156</td>
<td align="left">0x9C</td>
<td align="left">(临时)使用其他服务端</td>
<td align="left">服务端</td>
<td align="left">客户端应该临时使用其他服务端.</td>
</tr>
<tr>
<td align="left">157</td>
<td align="left">0x9D</td>
<td align="left">服务端已(永久)移动</td>
<td align="left">服务端</td>
<td align="left">服务端已移动且客户端应该永久使用其他服务端.</td>
</tr>
<tr>
<td align="left">158</td>
<td align="left">0x9E</td>
<td align="left">不支持共享订阅</td>
<td align="left">服务端</td>
<td align="left">服务端不支持共享订阅.</td>
</tr>
<tr>
<td align="left">159</td>
<td align="left">0x9F</td>
<td align="left">超出连接速率限制</td>
<td align="left">服务端</td>
<td align="left">此连接因为连接速率过高而被关闭.</td>
</tr>
<tr>
<td align="left">160</td>
<td align="left">0xA0</td>
<td align="left">最大连接时间</td>
<td align="left">服务端</td>
<td align="left">超出为此连接授予的最大连接时间.</td>
</tr>
<tr>
<td align="left">161</td>
<td align="left">0xA1</td>
<td align="left">不支持订阅标识符</td>
<td align="left">服务端</td>
<td align="left">服务端不支持订阅标识符；订阅未被接受.</td>
</tr>
<tr>
<td align="left">162</td>
<td align="left">0xA2</td>
<td align="left">不支持通配符订阅</td>
<td align="left">服务端</td>
<td align="left">服务端不支持通配符订阅；订阅未被接受.</td>
</tr>
</tbody></table>
<p>客户端或服务端发送<code>DISCONNECT</code>报文时必须使用一种<code>DISCONNECT</code>原因码 [MQTT-3.14.2-1]. 如果原因码为<code>0x00(正常断开)</code>且没有属性, 原因码和属性长度可以被省略. 这种情况下<code>DISCONNECT</code>报文剩余长度为0.</p>
<pre><code>非规范评注
DISCONNECT报文用于指示断开的原因, 例如没有确认报文(比如QoS等级0的发布消息)或当客户端或服务端不能继续处理连接.

非规范评注
客户端可以使用这些信息来决定是否重新连接, 以及在重新尝试之前应该等待多长时间.</code></pre><h5 id="3-14-2-2-DISCONNECT属性"><a href="#3-14-2-2-DISCONNECT属性" class="headerlink" title="3.14.2.2 DISCONNECT属性"></a>3.14.2.2 DISCONNECT属性</h5><h6 id="3-14-2-2-1-属性长度"><a href="#3-14-2-2-1-属性长度" class="headerlink" title="3.14.2.2.1 属性长度"></a>3.14.2.2.1 属性长度</h6><p>DISCONNECT报文可变报头中的<code>属性(Properties)</code>的长度被编码为<code>变长字节整数</code>. 如果剩余长度小于2, 属性长度使用0.</p>
<h6 id="3-14-2-2-2-会话过期间隔"><a href="#3-14-2-2-2-会话过期间隔" class="headerlink" title="3.14.2.2.2 会话过期间隔"></a>3.14.2.2.2 会话过期间隔</h6><p>17 (0x11), <code>会话过期间隔(Session Expiry Interval)</code>标识符.<br>跟随其后的是用四字节整数表示的以秒为单位的<code>会话过期间隔(Session Expiry Interval)</code>. 包含多个<code>会话过期间隔</code>将造成协议错误(Protocol Error).</p>
<p>如果没有设置<code>会话过期间隔</code>, 则使用<code>CONNECT</code>报文中的<code>会话过期间隔</code>.</p>
<p><code>会话过期间隔</code><strong>不能</strong>由服务端的<code>DISCONNECT</code>报文发送 [MQTT-3.14.2-2].</p>
<p>如果<code>CONNECT</code>报文中的会话过期间隔为0, 则客户端在<code>DISCONNECT</code>报文中设置非0<code>会话过期间</code>隔将造成协议错误(Protocol Error). 如果服务端收到这种非0<code>会话过期间隔</code>, 则不会将其视为有效的<code>DISCONNECT</code>报文. 服务端使用包含原因码为<code>0x82(协议错误)</code>的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<h6 id="3-14-2-2-3-原因字符串"><a href="#3-14-2-2-3-原因字符串" class="headerlink" title="3.14.2.2.3 原因字符串"></a>3.14.2.2.3 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码字符串表示断开原因. 此原因字符串是为诊断而设计的可读字符串, <strong>不应该</strong>被接收端所解析.</p>
<p>如果此属性使得<code>DISCONNECT</code>报文的长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性 [MQTT-3.14.2-3]. 包含多个原因字符串将造成协议错误(Protocol Error).</p>
<h6 id="3-14-2-2-4-用户属性"><a href="#3-14-2-2-4-用户属性" class="headerlink" title="3.14.2.2.4 用户属性"></a>3.14.2.2.4 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)标识符</code>.<br>跟随其后的是UTF-8字符串对. 此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上<code>用户属性</code>之后的<code>DISCONNECT</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性 [MQTT-3.14.2-4]. <code>用户属性</code>允许出现多次, 以表示多个名字/值对, 且相同的名字<strong>可以</strong>多次出现.</p>
<h6 id="3-14-2-2-5-服务端参考"><a href="#3-14-2-2-5-服务端参考" class="headerlink" title="3.14.2.2.5 服务端参考"></a>3.14.2.2.5 服务端参考</h6><p>28 (0x1C), <code>服务端参考(Server Reference)</code>标识符.<br>跟随其后的是一个UTF-8编码字符串, 客户端可以使用它来识别其他要使用的服务端. 包含多个服务端参考将造成协议错误(Protocol Error).</p>
<p>服务端发送包含一个服务端参考和原因码 <code>0x9C((临时)使用其他服务端)</code> 或 <code>0x9D(服务端已(永久)移动)</code> 的 <code>DISCONNECT</code> 报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.</p>
<p>关于如何使用服务端参考, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#411-服务端重定向" target="_blank" rel="noopener">4.11节</a> 服务端重定向.</p>
<ul>
<li>图 3-24 DISCONNECT报文可变报头非规范示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">说明</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">断开原因码</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 1</td>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">属性</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">长度Length(5)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 3</td>
<td align="left">会话过期间隔标识符 (17)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">byte 4</td>
<td align="left">会话过期间隔 (0)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 5</td>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 6</td>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 7</td>
<td align="left"></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="3-14-3-DISCONNECT载荷"><a href="#3-14-3-DISCONNECT载荷" class="headerlink" title="3.14.3 DISCONNECT载荷"></a>3.14.3 DISCONNECT载荷</h4><p>DISCONNECT报文没有有效载荷.</p>
<h4 id="3-14-4-DISCONNECT行为"><a href="#3-14-4-DISCONNECT行为" class="headerlink" title="3.14.4 DISCONNECT行为"></a>3.14.4 DISCONNECT行为</h4><p>发送端发送完DISCONNECT报文之后:</p>
<ul>
<li></li>
<li><p><strong>不能</strong>再在此网络连接上发送任何MQTT控制报文 [MQTT-3.14.4-1].</p>
</li>
<li><p><strong>必须</strong>关闭网络连接 [MQTT-3.14.4-2].</p>
</li>
</ul>
<p>接收到包含原因码为0x00(成功)的DISCONNECT时, 服务端:</p>
<ul>
<li></li>
<li><p><strong>必须</strong>丢弃任何与当前连接相关的遗嘱消息, 而不发布它 [MQTT-3.14.4-3], 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#3125-遗嘱标志" target="_blank" rel="noopener">3.1.2.5节</a> 所述.</p>
</li>
</ul>
<p>接收到DISCONNECT报文时, 接收端:<br>- <strong>应该</strong>关闭网络连接</p>
<h3 id="3-15-AUTH-–-认证交换"><a href="#3-15-AUTH-–-认证交换" class="headerlink" title="3.15 AUTH – 认证交换"></a>3.15 AUTH – 认证交换</h3><p><code>AUTH</code>报文被从客户端发送给服务端, 或从服务端发送给客户端, 作为扩展认证交换的一部分, 比如质询/响应认证. 如果<code>CONNECT</code>报文不包含相同的认证方法, 则客户端或服务端发送<code>AUTH</code>报文将造成协议错误(Protocol Error).</p>
<h4 id="3-15-1-AUTH固定报头"><a href="#3-15-1-AUTH固定报头" class="headerlink" title="3.15.1 AUTH固定报头"></a>3.15.1 AUTH固定报头</h4><ul>
<li>图 3-35 AUTH报文固定报头</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Bit</th>
<th align="left">7</th>
<th align="left">6</th>
<th align="left">5</th>
<th align="left">4</th>
<th align="left">3</th>
<th align="left">2</th>
<th align="left">1</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte 1</td>
<td align="left">MQTT控制报文类型 (15)</td>
<td align="left">保留位</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">byte 2</td>
<td align="left">剩余长度</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>AUTH报文固定报头第3, 2, 1, 0位是保留位, <strong>必须</strong>全设置为0. 客户端或服务端<strong>必须</strong>把其他值当做无效值并关闭网络连接 [MQTT-3.15.1-1].</p>
<p>剩余长度字段<br>等于可变报头的长度, 编码为<code>变长字节整数</code>.</p>
<h4 id="3-15-2-AUTH可变报头"><a href="#3-15-2-AUTH可变报头" class="headerlink" title="3.15.2 AUTH可变报头"></a>3.15.2 AUTH可变报头</h4><p>AUTH报文可变报头按顺序包含以下字段:认证原因码(Authentication Reason Code), 属性(Properties). 属性的编码规则, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#222-属性" target="_blank" rel="noopener">2.2.2节</a> 所述.</p>
<h5 id="3-15-2-1-认证原因码"><a href="#3-15-2-1-认证原因码" class="headerlink" title="3.15.2.1 认证原因码"></a>3.15.2.1 认证原因码</h5><p>可变报头第0字节是<code>认证原因码(Authenticate Reason Code)</code>. 单字节无符号认证原因码字段的值如下所示. <code>AUTH</code> 报文的发送端<strong>必须</strong>使用一种认证原因码 [MQTT-3.15.2-1].</p>
<ul>
<li>表 3-11 认证原因码</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">16进制</th>
<th align="left">原因码名称</th>
<th align="left">发送端</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">成功</td>
<td align="left">服务端</td>
<td align="left">认证成功.</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">0x18</td>
<td align="left">继续认证</td>
<td align="left">服务端或客户端</td>
<td align="left">继续下一步认证.</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">0x19</td>
<td align="left">重新认证</td>
<td align="left">客户端</td>
<td align="left">开始重新认证.</td>
</tr>
</tbody></table>
<p>如果原因码为<code>0x00(成功)</code>并且没有属性字段, 则可以省略原因码和属性长度. 这种情况下, <code>AUTH</code>报文剩余长度为0.</p>
<h5 id="3-15-2-2-AUTH属性"><a href="#3-15-2-2-AUTH属性" class="headerlink" title="3.15.2.2 AUTH属性"></a>3.15.2.2 AUTH属性</h5><h6 id="3-15-2-2-1-属性长度"><a href="#3-15-2-2-1-属性长度" class="headerlink" title="3.15.2.2.1 属性长度"></a>3.15.2.2.1 属性长度</h6><p>AUTH报文可变报头中的属性的长度被编码为<code>变长字节整数</code>.</p>
<h6 id="3-15-2-2-2-认证方法"><a href="#3-15-2-2-2-认证方法" class="headerlink" title="3.15.2.2.2 认证方法"></a>3.15.2.2.2 认证方法</h6><p>21 (0x15), <code>认证方法(Authentication Method)</code>标识符.<br>跟随其后的是一个UTF-8编码字符串, 包含<code>认证方法名称</code>. 省略<code>认证方法</code>或者包含多个<code>认证方法</code>都将造成协议错误(Protocol Error). 更多关于扩展认证的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p>
<h6 id="3-15-2-2-3-认证数据"><a href="#3-15-2-2-3-认证数据" class="headerlink" title="3.15.2.2.3 认证数据"></a>3.15.2.2.3 认证数据</h6><p>22 (0x16), <code>认证数据(Authentication Data)</code>标识符.<br>跟随其后的是二进制数据, 包含<code>认证数据</code>. 包含多个<code>认证数据</code>将造成协议错误(Protocol Error). 此数据的内容由认证方法定义. 更多关于扩展认证的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p>
<h6 id="3-15-2-2-4-原因字符串"><a href="#3-15-2-2-4-原因字符串" class="headerlink" title="3.15.2.2.4 原因字符串"></a>3.15.2.2.4 原因字符串</h6><p>31 (0x1F), <code>原因字符串(Reason String)</code>标识符.<br>跟随其后的是UTF-8编码字符串, 表示断开原因. 此<code>原因字符串</code>是为诊断而设计的可读字符串, 不应该被接收端所解析.</p>
<p>如果加上原因字符串之后的<code>AUTH</code>报文长度超出了接收端所指定的最大报文长度, 则发送端不能发送此属性 [MQTT-3.15.2-2]. 包含多个<code>原因字符串</code>将造成协议错误(Protocol Error).</p>
<h6 id="3-15-2-2-5-用户属性"><a href="#3-15-2-2-5-用户属性" class="headerlink" title="3.15.2.2.5 用户属性"></a>3.15.2.2.5 用户属性</h6><p>38 (0x26), <code>用户属性(User Property)</code>标识符.<br>跟随其后的是UTF-8字符串对. 此属性可用于向客户端提供包括诊断信息在内的附加信息. 如果加上用户属性之后的<code>AUTH</code>报文长度超出了接收端指定的最大报文长度, 则服务端不能发送此属性 [MQTT-3.15.2-3]. <code>用户属性(User Property)</code>允许出现多次, 以表示多个名字/值对, 且相同的名字可以多次出现.</p>
<h4 id="3-15-3-AUTH载荷"><a href="#3-15-3-AUTH载荷" class="headerlink" title="3.15.3 AUTH载荷"></a>3.15.3 AUTH载荷</h4><p>AUTH报文没有有效载荷.</p>
<h4 id="3-15-4-AUTH行为"><a href="#3-15-4-AUTH行为" class="headerlink" title="3.15.4 AUTH行为"></a>3.15.4 AUTH行为</h4><p>更多关于扩展认证的信息, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a>.</p>
<h2 id="4-操作行为"><a href="#4-操作行为" class="headerlink" title="4 操作行为"></a>4 操作行为</h2><h3 id="4-1-会话状态"><a href="#4-1-会话状态" class="headerlink" title="4.1 会话状态"></a>4.1 会话状态</h3><p>为实现<code>QoS等级1</code>和<code>QoS等级2</code>协议流, 客户端和服务端需要将状态与客户标识符相关联, 这被称为会话状态. 服务端还将订阅信息存储为会话状态的一部分.</p>
<p>会话可以跨越一系列的网络连接. 它持续到最新的<code>网络连接(Network Connections)</code>加上<code>会话过期间隔(Session Expiry Interval)</code>.</p>
<p>客户端的会话状态包括:</p>
<ul>
<li>已发送给服务端, 但是还没有完成确认的<code>QoS等级1</code>和<code>QoS等级2</code>的消息.</li>
<li>从服务端收到的, 但是还没有完成确认的<code>QoS等级2</code>消息.</li>
</ul>
<p>服务端的会话状态包括:</p>
<ul>
<li>会话是否存在, 即使会话状态其余部分为空.</li>
<li>客户端订阅信息, 包括任何订阅标识符.</li>
<li>已发送给客户端, 但是还没有完成确认的<code>QoS等级1</code>和<code>QoS等级2</code>的消息.</li>
<li>等待传输给客户端的<code>QoS等级0</code>(可选), <code>QoS等级1</code>和<code>QoS等级2</code>的消息.</li>
<li>从客户端收到的, 但是还没有完成确认的<code>QoS等级2</code>消息. 遗嘱小子和遗嘱延时间隔.</li>
<li>如果会话当前未连接, 会话结束时间和会话状态将被丢弃.</li>
</ul>
<p>保留消息不是会话状态的一部分, 会话结束时不被删除.</p>
<h4 id="4-1-1-存储会话状态"><a href="#4-1-1-存储会话状态" class="headerlink" title="4.1.1 存储会话状态"></a>4.1.1 存储会话状态</h4><p>当网络连接打开时, 客户端和服务端不能丢弃会话状态 [MQTT-4.1.0-1]. 当网络连接被关闭并且会话过期间隔已过时, 服务端必须丢弃会话状态 [MQTT-4.1.0-2].</p>
<pre><code>非规范评注
客户端和服务端实现的存储容量必然是有限的, 还可能要受管理策略的限制. 已存储的会话状态可能因为管理操作(比如某个预定义条件的自动响应)而被丢弃.它造成的后果就是会话终止. 这些操作可能是因为资源受限或其他操作原因引发的. 硬件或软件故障可能导致客户端或服务端存储的会话状态丢失或损坏. 需要谨慎的评估客户端和服务端的存储能力, 以确保存储空间充足.</code></pre><h4 id="4-1-2-会话状态非规范示例"><a href="#4-1-2-会话状态非规范示例" class="headerlink" title="4.1.2 会话状态非规范示例"></a>4.1.2 会话状态非规范示例</h4><p>例如, 想要收集电表读数的用户可能会决定使用<code>QoS等级1</code>的消息, 因为他们不能接受数据在网络传输途中丢失, 但是, 他们可能认为客户端和服务端的数据可以存储在内存(易失性存储器)中, 因为(他们觉得)电力供应是非常可靠的, 不会有太大的数据丢失风险.</p>
<p>与之相反, 停车计费支付应用的提供商可能决定任何情况下都不能让数据支付消息丢失, 因此他们要求在通过网络传输之前将所有的数据写入到非易失性存储器中(如硬盘).</p>
<h3 id="4-2-网络连接"><a href="#4-2-网络连接" class="headerlink" title="4.2 网络连接"></a>4.2 网络连接</h3><p>MQTT协议要求基础传输层能够提供有序的、可靠的、双向传输(从客户端到服务端和从服务端到客户端)字节流. 此规范不要求任何指定的传输协议. 客户端或服务端可以支持这里列出的任何传输协议, 或者满足 本节 要求的任何其他传输协议.</p>
<p>客户端或服务端必须支持使用一个或多个提供有序的、可靠的、双向传输(从客户端到服务端和从服务端到客户端)字节流传输的底层传输协议 [MQTT-4.2-1].</p>
<pre><code>非规范评注
MQTT v5.0使用的传输层协议是 [RFC0793] 定义的TCP/IP协议.下面的协议也支持:
• TLS [RFC5246]
• WebSocket [RFC6455] 

非规范评注
TCP端口8883和1883已在IANA注册, 分别用于MQTT的TLS和非TLS通信.

非规范评注
无连接的网络传输, 如用户数据包协议 (UDP) 本身不适合, 因为它们可能丢失或重新排列数据. </code></pre><h3 id="4-3-服务质量等级和协议流程"><a href="#4-3-服务质量等级和协议流程" class="headerlink" title="4.3 服务质量等级和协议流程"></a>4.3 服务质量等级和协议流程</h3><p>MQTT按照后面章节定义的<code>服务质量(QoS)等级</code>分发应用消息. 分发协议是对称的, 在下面的描述中, 客户端和服务端既可以是发送端也可以是接收端. 分发协议关注的是从单个发送者到单个接收者的应用消息. 服务端分发应用消息给多个客户端时, 每个客户端独立处理. 分发给客户端的出站应用消息和入站应用消息的QoS等级可能是不同的.</p>
<h4 id="4-3-1-QoS-0-最多分发一次"><a href="#4-3-1-QoS-0-最多分发一次" class="headerlink" title="4.3.1 QoS 0:最多分发一次"></a>4.3.1 QoS 0:最多分发一次</h4><p>消息的分发依赖于底层网络的能力. 接收端不会发送响应, 发送端也不会重试. 消息可能送达一次也可能根本没送达.</p>
<p>对于<code>QoS等级0</code>的分发协议, 发送端<br>- 必须发送QoS等于0, DUP等于0的<code>PUBLISH</code>报文 [MQTT-4.3.1-1].</p>
<p>对于QoS等级0的分发协议, 接收端<br>- 接受<code>PUBLISH</code>报文时同时接受消息的所有权.</p>
<ul>
<li>图 4-1 QoS等级0协议流程图, 非规范示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left">发送端动作</th>
<th align="left">控制报文</th>
<th align="left">接收端动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PUBLISH报文QoS 0, DUP=0</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">———-&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">分发应用消息给适当的后续接收者(们)</td>
</tr>
</tbody></table>
<h4 id="4-3-2-QoS-1-至少分发一次"><a href="#4-3-2-QoS-1-至少分发一次" class="headerlink" title="4.3.2 QoS 1:至少分发一次"></a>4.3.2 QoS 1:至少分发一次</h4><p>服务质量等级1确保消息至少送达一次. <code>QoS等级1</code>的<code>PUBLISH</code>报文的可变报头中包含一个报文标识符, 需要PUBACK 报文确认. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了有关报文标识符的更多信息.</p>
<p>对于<code>QoS等级1</code>的分发协议, 发送端</p>
<ul>
<li></li>
<li><p>每次发送新的应用消息都必须分配一个未使用的报文标识符 [MQTT-4.3.2-1].</p>
</li>
<li><p>发送的<code>PUBLISH</code>报文必须包含报文标识符且QoS等于1, DUP等于0 [MQTT-4.3.2-2].</p>
</li>
<li><p>必须将这个<code>PUBLISH</code>报文看作是未确认的 , 直到从接收端那收到对应的<code>PUBACK</code>报文. <a href="https://www.zybuluo.com/khan-lau/note/1325300#44-消息分发重试" target="_blank" rel="noopener">4.4节</a> 有一个关于未确认消息的讨论 [MQTT-4.3.2-3].</p>
</li>
</ul>
<p>一旦发送端收到<code>PUBACK</code>报文, 这个报文标识符就可以重用.</p>
<p>注意:允许发送端在等待确认时使用不同的报文标识符发送后续的<code>PUBLISH</code>报文.</p>
<p>对于QoS等级1的分发协议, 接收端</p>
<ul>
<li></li>
<li><p>响应的<code>PUBACK</code>报文必须包含一个报文标识符, 这个标识符来自接收到的、已经接受所有权的<code>PUBLISH</code>报文 [MQTT-4.3.2-4].</p>
</li>
<li><p>发送了<code>PUBACK</code>报文之后, 接收端必须将任何包含相同报文标识符的入站<code>PUBLISH</code>报文当做一个新的消息, 并忽略它的DUP标志的值 [MQTT-4.3.2-5].</p>
</li>
<li><p>图 4-2 QoS等级1协议流程图, 非规范示例</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">发送端动作</th>
<th align="left">控制报文</th>
<th align="left">接收端动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储消息</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">发送PUBLISH报文QoS=1, DUP=0, 带报文标识符</td>
<td align="left">———-&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">开始应用消息的后续分发1</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">&lt;———-</td>
<td align="left">发送<code>PUBACK</code>报文, 带报文标识符</td>
</tr>
<tr>
<td align="left">丢弃消息</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>不要求接收端在发送 <code>PUBACK</code> 之前完整分发应用消息. 原来的发送端收到 <code>PUBACK</code> 报文之后, 应用消息的所有权就会转移给这个接收端.</p>
<h4 id="4-3-3-QoS-2-仅分发一次"><a href="#4-3-3-QoS-2-仅分发一次" class="headerlink" title="4.3.3 QoS 2:仅分发一次"></a>4.3.3 QoS 2:仅分发一次</h4><p>这是最高等级的服务质量, 消息丢失和重复都是不可接受的. 使用这个服务质量等级会有额外的开销.</p>
<p>QoS等2消息可变报头中有报文标识符. <a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">2.2.1节</a> 提供了有关报文标识符的更多信息. <code>QoS等级2</code>的<code>PUBLISH</code>报文的接收端使用一个两部确认过程来确认收到.</p>
<p>对于QoS等级2的分发协议, 发送端</p>
<ul>
<li><strong>必须</strong>给要发送的新应用消息分配一个未使用的报文标识符 [MQTT-4.3.3-1].</li>
<li>发送端<code>PUBLISH</code>报文<strong>必须</strong>包含报文标识符且报文的QoS等于2, DUP等于0 [MQTT-4.3.3-2].</li>
<li><strong>必须</strong>将这个<code>PUBLISH</code>报文看作是未确认的 , 直到从接收端那收到对应的<code>PUBREC</code>报文 [MQTT-4.3.3-3]. <a href="https://www.zybuluo.com/khan-lau/note/1325300#44-消息分发重试" target="_blank" rel="noopener">4.4节</a> 有一个关于未确认消息的讨论.</li>
<li>收到发送端发送的包含原因码小于0x80的<code>PUBREC</code>报文后必须发送一个<code>PUBREL</code>报文.PUBREL报文必须包含与原始<code>PUBLISH</code>报文相同的报文标识符 [MQTT-4.3.3-4].</li>
<li><strong>必须</strong>将这个<code>PUBREL</code>报文看作是未确认的 , 直到从接收端那收到对应的<code>PUBCOMP</code>报文 [MQTT-4.3.3-5].</li>
<li>一旦发送了对应的<code>PUBREL</code>报文就<strong>不能</strong>重发这个<code>PUBLISH</code>报文 [MQTT-4.3.3-6].</li>
<li>如果<code>PUBLISH</code>报文已发送, <strong>不能</strong>应用消息过期属性 [MQTT-4.3.3-7].</li>
</ul>
<p>一旦发送端收到包含原因码大于0x80的<code>PUBCOMP</code>报文, 这个报文标识符就可以重用.</p>
<p>注意:允许发送端在等待确认时使用不同的报文标识符发送后续的<code>PUBLISH</code>报文, 受制于4.9节 描述的流量控制.</p>
<p>对于<code>QoS等级2</code>的分发协议, 接收端</p>
<ul>
<li>响应的<code>PUBREC</code>报文<strong>必须</strong>包含报文标识符, 这个标识符来自接收到的、已经接受所有权的<code>PUBLISH</code>报文 [MQTT-4.3.3-8].</li>
<li>如果接收端发送了包含原因码大于等于0x80的<code>PUBREC</code>报文, 它<strong>必须</strong>将后续包含相同报文标识符的<code>PUBLISH</code>报文当做是新的应用消息 [MQTT-4.3.3-9].</li>
<li>在收到对应的<code>PUBREL</code>报文之前, 接收端<strong>必须</strong>发送<code>PUBREC</code>报文确认任何后续的具有相同报文标识符的<code>PUBLISH</code>报文. 在这种情况下, 它<strong>不能</strong>重复分发消息给任何后续的接收者 [MQTT-4.3.3-10].</li>
<li><strong>必须</strong>发送包含与<code>PUBREL</code>相同报文标识符的<code>PUBCOMP</code>报文作为对<code>PUBREL</code>报文的响应 [MQTT-4.3.3-11].</li>
<li>发送PUBCOMP报文之后, 接收端<strong>必须</strong>将后续包含相同报文标识符的<code>PUBLISH</code>报文当做是新的应用消息 [MQTT-4.3.3-12].</li>
<li><strong>必须</strong>继续<code>QoS等级2</code>确认序列, 即使它已经应用了消息过期属性 [MQTT-4.3.3-13].</li>
</ul>
<h3 id="4-4-消息分发重试"><a href="#4-4-消息分发重试" class="headerlink" title="4.4 消息分发重试"></a>4.4 消息分发重试</h3><p>客户端以<code>新开始(Clean Start)</code>标志为0且会话存在的情况下重连时, 客户端和服务端都必须使用原始报文标识符重新发送任何未被确认的 <code>PUBLISH</code> 报文(当QoS &gt; 0)和<code>PUBREL</code>报文. 这是唯一要求客户端或服务端重发消息的情况. 客户端和服务端<strong>不能</strong>在其他任何时间重发消息 [MQTT-4.4.0-1].</p>
<p>如果收到包含原因码大于等于0x80的<code>PUBACK</code>或<code>PUBREC</code>, 则对应的<code>PUBLISH</code>报文被看作已确认, 且<strong>不能</strong>被重传 [MQTT-4.4.0-2].</p>
<ul>
<li>图 4-3 QoS等级2协议流程图, 非规范示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left">发送端动作</th>
<th align="left">控制报文</th>
<th align="left">接收端行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储消息</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">发送<code>PUBLISH</code>报文QoS=2, DUP=0, 带报文标识符</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">———-&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">存储报文标识符, 然后启动应用消息的向前分发1</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">发送PUBREC报文, 带报文标识符和原因码</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">&lt;———-</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">丢弃消息, 存储PUBREC中的报文标识符</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">发送PUBREL报文, 带报文标识符</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">———-&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">丢弃报文标识符</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">发送PUBCOMP报文, 带报文标识符</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">&lt;———-</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">丢弃已保存的状态</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>1 不要求接收端在发送<code>PUBREC</code>和<code>PUBCOMP</code>之前完整分发应用消息. 原始发送端收到<code>PUBREC</code>报文之后, 应用消息的所有权就会转移给这个接收端. 然而, 接收端需要在接受所有权之前执行对所有可能导致转发失败(例如超出配额、权限等)的条件的检查. 接收端在<code>PUBREC</code>中使用适当的原因码指示所有权接受成功或失败.</p>
<h3 id="4-5-消息收到"><a href="#4-5-消息收到" class="headerlink" title="4.5 消息收到"></a>4.5 消息收到</h3><p>当服务端接受入站应用消息的所有权时, 它<strong>必须</strong>将消息添加到订阅匹配的客户端的会话状态中 [MQTT-4.5.0-1]. 匹配规则定义见 <a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> .</p>
<p>正常情况下, 客户端收到的消息是对他们创建的订阅的响应. 客户端也可能收到不是与它的订阅精确匹配的消息. 如果服务端自动给客户端分配了一个订阅, 可能发生这种情况. <code>UNSUBSCRIBE</code>操作正在被处理时也可能收到消息. 客户端<strong>必须</strong>按照可用的服务质量(QoS)规则确认它收到的任何<code>PUBLISH</code>报文, 不管它是否选择处理其包含的应用消息 [MQTT-4.5.0-2].</p>
<h3 id="4-6-消息排序"><a href="#4-6-消息排序" class="headerlink" title="4.6 消息排序"></a>4.6 消息排序</h3><p>实现 <a href="https://www.zybuluo.com/khan-lau/note/1325300#43-服务质量等级和协议流程" target="_blank" rel="noopener">4.3节</a> 定义的协议流程时, 客户端<strong>必须</strong>遵循下列规则</p>
<ul>
<li>重发任何之前的<code>PUBLISH</code>报文时, <strong>必须</strong>按原始<code>PUBLISH</code>报文的发送顺序重发(适用于QoS等级1和QoS等级2 消息) [MQTT-4.6.0-1].</li>
<li><strong>必须</strong>按照对应的<code>PUBLISH</code>报文的顺序发送<code>PUBACK</code>报文(<code>QoS等级1</code>消息) [MQTT-4.6.0-2].</li>
<li><strong>必须</strong>按照对应的<code>PUBLISH</code>报文的顺序发送<code>PUBREC</code>报文(<code>QoS等级2</code>消息) [MQTT-4.6.0-3].</li>
<li><strong>必须</strong>按照对应的<code>PUBREC</code>报文的顺序发送<code>PUBREL</code>报文(<code>QoS等级2</code>消息) [MQTT-4.6.0-4].</li>
</ul>
<p>一个<code>有序主题(Ordered Topic)</code>是一个主题, 在这个主题中, 客户端<strong>可以</strong>确定从同一个客户端接收的相同QoS等级的消息的顺序与他们发布的顺序一致. 当服务端处理发布到有序主题的消息时, 它<strong>必须</strong>按照消息从任何给定客户端接收的顺序发送<code>PUBLISH</code>报文给消费端(对于同一主题和QoS等级) [MQTT-4.6.0-5]. 这是上面列出的规则的补充.</p>
<p>默认情况下, 服务端转发非共享订阅的消息时, <strong>必须</strong>将每个主题都视为有序主题 [MQTT-4.6.0-6]. 服务端<strong>可以</strong>提供管理或其他机制来允许一个或多个主题不被当作有序主题.</p>
<pre><code>非规范评注
上面列出的规则确保, 使用QoS等级1发布和订阅的消息流, 订阅者按照消息发布时的顺序收到每条消息的最终副本, 但是消息可能会重复, 这可能导致在它的后继消息之后收到某个已经收到消息的重发版本. 例如, 发布者按顺序1, 2, 3, 4发送消息, 订阅者收到的顺序可能是1, 2, 3, 2, 3, 4.

如果客户端和服务端能保证任何时刻最多有一条消息在 传输中(in-flight)(在某条消息被确认前不发送后面的那条消息), 那么, 不会有QoS等级1的消息会在它的任何后续消息之后收到. 例如, 订阅者收到的顺序可能是 1, 2, 3, 3, 4, 而不是 1, 2, 3, 2, 3, 4. 关于如何使用Receive Maximum的详细信息, 参考[4.9节](#49-流控) 流控.</code></pre><h3 id="4-7-主题名和主题过滤器"><a href="#4-7-主题名和主题过滤器" class="headerlink" title="4.7 主题名和主题过滤器"></a>4.7 主题名和主题过滤器</h3><h4 id="4-7-1-主题通配符"><a href="#4-7-1-主题通配符" class="headerlink" title="4.7.1 主题通配符"></a>4.7.1 主题通配符</h4><p><code>主题层级(topic level)</code>分隔符用于将结构化引入主题名. 如果存在分隔符, 它将主题名分割为多个<code>主题层级 topic level</code>.<br>订阅的主题过滤器可以包含特殊的通配符, 允许客户端一次订阅多个主题.<br>主题过滤器中<strong>可以</strong>使用通配符, 但是主题名<strong>不能</strong>使用通配符 [MQTT-4.7.0-1].</p>
<h5 id="4-7-1-1-主题层级分隔符"><a href="#4-7-1-1-主题层级分隔符" class="headerlink" title="4.7.1.1 主题层级分隔符"></a>4.7.1.1 主题层级分隔符</h5><p><code>斜杠(’/’ U+002F)</code>用于分割主题的每个层级, 为主题名提供一个分层结构. 当客户端订阅指定的主题过滤器包含两种通配符时, 主题层级分隔符就很有用了. 主题层级分隔符可以出现在主题过滤器或主题名字的任何位置. 相邻的主题层次分隔符表示一个零长度的主题层级.</p>
<h5 id="4-7-1-2-多层通配符"><a href="#4-7-1-2-多层通配符" class="headerlink" title="4.7.1.2 多层通配符"></a>4.7.1.2 多层通配符</h5><p><code>数字符号(‘#’ U+0023)</code>是用于匹配主题中任意层级的通配符. 多层通配符表示它的父级和任意数量的子层级. 多层通配符<strong>必须</strong>单独指定, 或者跟在主题层级分隔符后面. 不管哪种情况, 它都<strong>必须</strong>是主题过滤器的最后一个字符 [MQTT-4.7.1-1].</p>
<pre><code>非规范评注
例如, 如果客户端订阅主题 “sport/tennis/player1/#”, 它会收到使用下列主题名发布的消息:
• “sport/tennis/player1”
• “sport/tennis/player1/ranking
• “sport/tennis/player1/score/wimbledon”

非规范评注
• “sport/#”也匹配单独的“sport”主题名, 因为#包括它的父级.
• “#”是有效的, 会收到所有的应用消息.
• “sport/tennis/#”也是有效的.
• “sport/tennis#”是无效的.
• “sport/tennis/#/ranking”是无效的.</code></pre><h5 id="4-7-1-3-单层通配符"><a href="#4-7-1-3-单层通配符" class="headerlink" title="4.7.1.3 单层通配符"></a>4.7.1.3 单层通配符</h5><p><code>加号(‘+’ U+002B)</code>是只能用于单个主题层级匹配的通配符.</p>
<p>在主题过滤器的任意层级都可以使用单层通配符, 包括第一个和最后一个层级. 在使用它时, 它<strong>必须</strong>占据过滤器的整个层级 [MQTT-4.7.1-2]. <strong>可以</strong>在主题过滤器中的多个层级中使用它, 也<strong>可以</strong>和多层通配符一起使用.</p>
<pre><code>非规范评注
例如, “sport/tennis/+”匹配“sport/tennis/player1”和“sport/tennis/player2”, 但是不匹配“sport/tennis/player1/ranking”.同时, 由于单层通配符只能匹配一个层级, “sport/+”不匹配“sport”但是却匹配“sport/”.
• “+”是有效的.
• “+/tennis/#”是有效的.
• “sport+”是无效的.
• “sport/+/player1”是有效的.
• “/finance”匹配“+/+”和“/+”, 但是不匹配“+”.</code></pre><h4 id="4-7-2-以-开头的主题"><a href="#4-7-2-以-开头的主题" class="headerlink" title="4.7.2 以$开头的主题"></a>4.7.2 以$开头的主题</h4><p>服务端<strong>不能</strong>将<code>$字符</code>开头的主题名匹配通配符(#或+)开头的主题过滤器 [MQTT-4.7.2-1]. 服务端应该阻止客户端使用这种主题名与其他客户端交换消息. 服务端实现<strong>可以</strong>将<code>$开头</code>的主题名用作其他目的.</p>
<pre><code>非规范评注
• $SYS/被广泛用作包含服务端特定信息或控制接口的主题的前缀.
    • 应用不能使用$字符开头的主题.

非规范评注
• 订阅“#”的客户端不会收到任何发布到以$开头主题的消息.
    • 订阅“+/monitor/Clients”的客户端不会收到任何发布到“$SYS/monitor/Clients”的消息.
• 订阅“$SYS/#”的客户端会收到发布到以“$SYS/”开头主题的消息.
• 订阅“$SYS/monitor/+”的客户端会收到发布到“$SYS/monitor/Clients”主题的消息.
• 如果客户端想同时接受以“$SYS/”开头主题的消息和不以$开头主题的消息, 它需要同时订阅“#”和“$SYS/#”.</code></pre><h4 id="4-7-3-主题语义和用法"><a href="#4-7-3-主题语义和用法" class="headerlink" title="4.7.3 主题语义和用法"></a>4.7.3 主题语义和用法</h4><p>下列规则应用于主题名和主题过滤器:</p>
<ul>
<li>所有的主题名和主题过滤器<strong>必须</strong>至少包含一个字符 [MQTT-4.7.3-1].</li>
<li>主题名和主题过滤器是大小写敏感的.</li>
<li>主题名和主题过滤器可以包含空格字符.</li>
<li>主题名或主题过滤器以前置或后置斜杠‘/’区分.</li>
<li>只包含斜杠‘/’的主题名或主题过滤器是合法的.</li>
<li>主题名和主题过滤器<strong>不能</strong>包含空字符(Unicode U+0000) [Unicode] [MQTT-4.7.3-2].</li>
<li>主题名和主题过滤器是UTF-8编码字符串, 它们<strong>不能</strong>超过65,535字节 [MQTT-4.7.3-3]. 见<a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">1.5.4节</a> .</li>
</ul>
<p>除了<strong>不能</strong>超过UTF-8编码字符串的长度限制之外, 主题名或主题过滤器的层级数量没有其它限制.</p>
<p>匹配订阅时, 服务端<strong>不能</strong>对主题名或主题过滤器执行任何规范化(normalization)处理, <strong>不能</strong>修改或替换任何未识别的字符 [MQTT-4.7.3-4]. 主题过滤器中的每个非通配符层级需要逐字符匹配主题名中对应的层级才算匹配成功.</p>
<pre><code>非规范评注
使用UTF-8编码规则意味着, 主题过滤器和主题名的比较可以通过比较编码后的UTF-8字节或解码后的Unicode字符. 

非规范评注
• “ACCOUNTS”和“Accounts”是不同的主题名.
• “Accounts payable”是合法的主题名.
• “/finance”和“finance”是不同的主题名.</code></pre><p>如果订阅的主题过滤器与消息的主题名匹配, 应用消息会被发送给每一个匹配的客户端订阅. 主题资源<strong>可以</strong>是管理员在服务端预先定义好的, 也<strong>可以</strong>是服务端收到第一个订阅或使用那个主题名的应用消息时动态添加的. 服务端也<strong>可以</strong>使用一个安全组件有选择地授权客户端使用某个主题资源.</p>
<h3 id="4-8-订阅"><a href="#4-8-订阅" class="headerlink" title="4.8 订阅"></a>4.8 订阅</h3><p>MQTT提供两种订阅方式, 共享和非共享.</p>
<pre><code>非规范评注
在早期的MQTT版本中, 所有的订阅都是非共享的.</code></pre><h4 id="4-8-1-非共享订阅"><a href="#4-8-1-非共享订阅" class="headerlink" title="4.8.1 非共享订阅"></a>4.8.1 非共享订阅</h4><p><code>非共享订阅</code>只与创建它的会话相关联. 每个<code>订阅(Subscription)</code>包含一个指示用于在此会话上分发消息的主题过滤器和订阅选项. 服务端负责收集与过滤器相匹配的消息, 并在此会话的连接上发送这些消息.</p>
<p>一个会话<strong>不能</strong>有多个包含相同主题过滤器的<code>非共享订阅</code>, 因此主题过滤器可以用作标识此会话的订阅的关键词.</p>
<p>如果有多个客户端, 每个客户端都拥有对某个相同主题的<code>非共享订阅</code>, 则每个客户端都将获得在该主题上发布的应用消息的副本. 这意味着<code>非共享订阅</code><strong>不能</strong>被用于多个消费客户端的应用消息负载均衡, 因为在这种情况下, 每条消息都将被传递给每一个订阅的客户端.</p>
<h4 id="4-8-2-共享订阅"><a href="#4-8-2-共享订阅" class="headerlink" title="4.8.2 共享订阅"></a>4.8.2 共享订阅</h4><p><code>共享订阅</code>可以与多个订阅会话相关联. 与<code>非共享订阅</code>一样, 它包含一个主题过滤器和订阅选项. 但是, 与此主题过滤器相匹配的发布消息仅被发布到其中一个订阅会话. <code>共享订阅</code>在多个消费客户端并行共享处理发布消息时是很有用的.</p>
<p>使用特殊样式的主题过滤器来表示<code>共享订阅</code>. 过滤器格式如下:<br><code>$share/{ShareName}/{filter}</code></p>
<ul>
<li><code>$share</code>是字符串字面量, 用来把主题过滤器标记为共享订阅主题过滤器.</li>
<li><code>{ShareName}</code>是字符串, 不包含<code>&quot;/&quot;</code>, <code>&quot;+&quot;</code>或<code>&quot;#&quot;</code>.</li>
<li><code>{filter}</code>该字符串的剩余部分与<code>非共享订阅</code>中的主题过滤器具有相同的语法和语义.参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a>.</li>
</ul>
<p><code>共享订阅</code>主题过滤器<strong>必须</strong>以<code>$share/</code>开始, 且<strong>必须</strong>包含至少一个字符长度的共享名(ShareName) [MQTT-4.8.2-1]. 共享名不能包含字符<code>&quot;/&quot;</code>, <code>&quot;+&quot;</code>或<code>&quot;#&quot;</code>, 但<strong>必须</strong>跟在<code>&quot;/&quot;</code>字符后面.此<code>&quot;/&quot;</code>字符后面<strong>必须</strong>跟随一个主题过滤器 [MQTT-4.8.2-2] , 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> 所述.</p>
<pre><code>非规范评注
共享订阅在MQTT服务端的范围内定义, 而不是在会话中定义. 共享订阅的主题过滤器包含共享名, 因此服务端可以有多个包含相同{过滤器}组件的共享订阅. 通常, 应用程序使用共享名表示共享同一个订阅的一组订阅会话.

示例:
• 共享订阅 &quot;$share/consumer1/sport/tennis/+&quot; 和 &quot;$share/consumer2/sport/tennis/+&quot; 是不同的共享订阅, 因此可以被关联到不同的会话组. 它们都与非共享订阅主题 &quot;sport/tennis/+&quot; 相匹配.

如果一条消息被发布到匹配主题 &quot;sport/tennis/+&quot; , 则消息的副本仅发送给所有订阅 &quot;$share/consumer1/sport/tennis/+&quot; 的会话中的一个会话, 也仅发送给所有订阅 &quot;$share/consumer2/sport/tennis/+&quot; 的会话中的一个会话. 更多的副本将发送给所有对 &quot;sport/tennis/+&quot; 进行非共享订阅的客户端.

• 共享订阅 &quot;$share/consumer1//finance&quot; 匹配非共享订阅主题 &quot;/finance&quot;.

注意,  &quot;$share/consumer1//finance&quot; 和 &quot;$share/consumer1/sport/tennis/+&quot; 是不同的共享订阅, 尽管它们有相同的共享名. 它们可能在某种程度上是相关的, 但拥有相同的共享名并不意味着它们之间有某种关系.</code></pre><p>通过<code>SUBSCRIBE</code>请求中的<code>共享订阅</code>主题过滤器创建<code>共享订阅</code>. 只有一个会话订阅了某个<code>共享订阅</code>时, <code>共享订阅</code>行为如同<code>非共享订阅</code>, 除了:</p>
<ul>
<li>匹配发布消息时, 不考虑<code>&quot;$share&quot;</code>和<code>{共享名}</code>部分.</li>
<li>第一次订阅时, <code>保留消息</code>不发送给此会话.其他匹配的<code>发布消息</code>将发送给此会话.</li>
</ul>
<p>一旦某个<code>共享订阅</code>存在, 其他会话就有可能订阅了相同的<code>共享订阅</code>主题过滤器. 新的会话作为额外的订阅者关联到此<code>共享订阅</code>. 保留消息不发送给此新的订阅者. 后续每条与此<code>共享订阅</code>相匹配的应用消息被发送到该<code>共享订阅</code>关联的其中一个会话.</p>
<p>会话可以通过发送包含某<code>共享订阅</code>主题过滤器的<code>UNSUBSCRIBE</code>报文来显式的将其从<code>共享订阅</code>中分离. 会话终止时, 也将从<code>共享订阅</code>中分离.</p>
<p><code>共享订阅</code>持续到至少有一个与其相关的会话(即, 会话已经对此<code>共享订阅</code>主题过滤器发布了成功的<code>SUBSCRIBE</code>请求, 且尚未完成相应的<code>UNSUBSCRIBE</code>). 当初始创建此<code>共享订阅</code>的会话取消订阅时, 除非没有其他的相关会话, 否则<code>共享订阅</code>仍然存在. <code>共享订阅</code>在没有被任何会话订阅时结束, 且任何相关的未分发的消息都被删除.</p>
<p>共享订阅注释<br>- 如果有不止一个会话订阅了某个<code>共享订阅</code>, 服务端在消息的基础上自由的选择使用哪个会话, 以及使用什么标准来进行该选择.</p>
<ul>
<li>允许不同的订阅客户端在其<code>SUBSCRIBE</code>报文中请求不同的QoS等级. 服务端决定授予每个客户端的<code>最大QoS等级</code>, 并且允许向不同的订阅者授予不同的<code>最大QoS等级</code>. 向客户端发送应用消息时, 服务端<strong>必须</strong>考虑授予客户端的<code>QoS等级</code> [MQTT-4.8.2-3], 与向订阅者发送消息相同.</li>
<li>如果服务端正在向其选中的订阅客户端发送<code>QoS等级2</code>的消息, 并且在分发完成之前网络中断, 服务端<strong>必须</strong>在客户端重新连接时完成向该客户端的消息分发 [MQTT-4.8.2-4], 如4.3.3节 所述. 如果客户端的会话在客户端重连之前终止, 服务端<strong>不能</strong>把此消息发送给其他订阅的客户端 [MQTT-4.8.2-5].</li>
<li>如果服务端正在向其选中的订阅客户端发送<code>QoS等级1</code>的消息, 并且服务端在收到此客户端的确认报文之前网络中断, 服务端<strong>可以</strong>等客户端重新连接之后将消息重传给客户端. 如果客户端的会话在客户端重连之前终止, 服务端<strong>应该</strong>把此应用消息发送给与此<code>共享订阅</code>相关的另一个客户端. 服务端<strong>可以</strong>在第一个客户端断开连接时就尝试将消息发送给另一个客户端.</li>
<li>如果客户端对来自服务端的<code>PUBLISH</code>报文使用包含原因码大于等于0x80的<code>PUBACK</code>或<code>PUBREC</code>报文进行响应, 服务端<strong>必须</strong>丢弃应用消息而不尝试将其发送给任何其他订阅者 [MQTT-4.8.2-6].</li>
<li>允许客户端向已订阅的<code>共享订阅</code>第二次发送<code>SUBSCRIBE</code>请求. 比如, 它可以通过这样改变其订阅请求的<code>QoS等级</code>, 或者因为它不确定以前的连接关闭之前订阅是否已完成. 这不会增加<code>共享订阅</code>关联的会话个数, 因此会话将在其第一次发送<code>UNSUBSCRIBE</code>之后脱离此<code>共享订阅</code>.</li>
<li>每个<code>共享订阅</code>都是独立于其他<code>共享订阅</code>的. 有可能两个<code>共享订阅</code>包含了重叠的过滤器. 在这种情况下, 与两个<code>共享订阅</code>都相匹配的消息都将被它们单独处理. 如果某个客户端既有<code>共享订阅</code>也有<code>非共享订阅</code>, 且某个消息与它们都相匹配, 客户端将由于存在<code>非共享订阅</code>而接收此消息的副本, 此消息的第二个副本将分发给此<code>共享订阅</code>的某个订阅者, 因此可能导致两份副本都被发送给此客户端.</li>
</ul>
<h3 id="4-9-流控"><a href="#4-9-流控" class="headerlink" title="4.9 流控"></a>4.9 流控</h3><p>客户端和服务端使用接收最大值来控制接收未被确认的<code>PUBLISH</code>报文数量, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#312114-最大报文长度" target="_blank" rel="noopener">3.1.2.11.4节</a> 和<a href="https://www.zybuluo.com/khan-lau/note/1325300#32232-会话过期间隔" target="_blank" rel="noopener">3.2.2.3.2节</a> 所述. 接收最大值创建了一个发送配额, 用于限制可以在没收到<code>PUBACK</code>(QoS等级1)或<code>PUBCOMP</code>(QoS等级2)的情况下发送的QoS等级大于0的<code>PUBLISH</code>报文数量. <code>PUBACK</code>和<code>PUBCOMP</code>按照下述方式补充配额.</p>
<p>客户端或服务端<strong>必须</strong>将其初始发送配额设置为不超过接收最大值的非0值 [MQTT-4.9.0-1].</p>
<p>每当客户端或服务端发送了一个QoS等级大于0的<code>PUBLISH</code>报文, 它就会减少发送配额. 如果发送配额减为0, 客户端或服务端<strong>不能</strong>再发送任何QoS等级大于0的<code>PUBLISH</code>报文 [MQTT-4.9.0-2]. 它<strong>可以</strong>继续发送QoS为0的<code>PUBLISH</code>报文, 也<strong>可以</strong>选择暂停发送这些报文. 即使配额为0, 客户端和服务端也<strong>必须</strong>继续处理和响应其他MQTT控制报文 [MQTT-4.9.0-3].</p>
<p>发送配额增加1:</p>
<ul>
<li>每当收到一个<code>PUBACK</code>报文或<code>PUBCOMP</code>报文, 不管<code>PUBACK</code>或<code>PUBCOMP</code>报文是否包含错误码.</li>
<li>每次收到一个包含返回码大于等于0x80的<code>PUBREC</code>报文.</li>
</ul>
<p>如果发送配额已到达初始发送配额, 则不继续增加. 在初始发送配额之上尝试增加配额可能是由建立新的网络连接后重新发送<code>PUBREL</code>数据包引起的.</p>
<p>关于客户端和服务端在超出最大接收值的允许的情况下发送<code>PUBLISH</code>报文的描述, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">3.3.4节</a>.</p>
<p>发送配额和接收最大值的保留不跨越网络连接, 每次建立新的网络连接时按照上面的描述进行初始化. 它们不是会话状态的一部分.</p>
<h3 id="4-10-请求-响应"><a href="#4-10-请求-响应" class="headerlink" title="4.10 请求/响应"></a>4.10 请求/响应</h3><p>有些应用程序或标准可能希望通过MQTT协议运行请求/响应交互.此版本MQTT协议包含三个可用于此目的的属性:</p>
<ul>
<li>响应主题, 在<a href="https://www.zybuluo.com/khan-lau/note/1325300#33235-响应主题" target="_blank" rel="noopener">3.3.2.3.5节</a> 中描述</li>
<li>对比数据, 在<a href="https://www.zybuluo.com/khan-lau/note/1325300#33236-对比数据" target="_blank" rel="noopener">3.3.2.3.6节</a> 中描述</li>
<li>请求响应信息, 在<a href="https://www.zybuluo.com/khan-lau/note/1325300#312117-请求问题信息" target="_blank" rel="noopener">3.1.2.11.7节</a> 中描述</li>
<li>响应信息, 在<a href="https://www.zybuluo.com/khan-lau/note/1325300#322315-响应信息" target="_blank" rel="noopener">3.2.2.3.15节</a> 中描述<br>以下非规范部分描述了如何使用这些属性.</li>
</ul>
<p>客户端通过发布一个包含响应主题的应用消息来发送请求消息, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#33235-响应主题" target="_blank" rel="noopener">3.3.2.3.5节</a> 所述. 请求消息可以包含对比数据属性, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#33236-对比数据" target="_blank" rel="noopener">3.3.2.3.6节</a> 所述.</p>
<h4 id="4-10-1-基本请求响应-非规范"><a href="#4-10-1-基本请求响应-非规范" class="headerlink" title="4.10.1 基本请求响应(非规范)"></a>4.10.1 基本请求响应(非规范)</h4><p>请求/响应交互过程如下:</p>
<ol>
<li>MQTT客户端(请求方)向主题发布请求消息. 请求消息是具有响应主题的应用消息.</li>
<li>另一个MQTT客户端(响应方)订阅了与请求消息发布时使用的主题名相匹配的主题过滤器. 结果, 它收到请求消息. 可能有多个响应方订阅了此主题名, 也可能没有响应方.</li>
<li>响应方根据请求消息采取适当的操作, 然后往请求消息中携带的响应主题属性中的主题名发布响应消息.</li>
<li>典型用法, 请求放订阅了响应主题, 从而接收到响应信息.但是, 其他某些客户端可能会订阅响应主题, 因此它们也将接收和处理响应消息. 与请求消息一样, 可能有多个客户端订阅了响应消息的发送主题, 也可能没有.</li>
</ol>
<p>如果请求消息包含对比数据属性, 则响应方将此属性拷贝到响应消息中, 由响应消息的接收端用来将响应消息与原始请求相关联. 响应消息不包含响应主题属性.</p>
<p>MQTT服务端转发请求消息中的响应主题和对比数据属性, 和响应消息中的对比数据属性. 服务端像处理其他应用程序消息一样处理请求消息和响应消息.</p>
<p>请求放通常在发布请求消息之前订阅响应主题. 如果响应消息发送时没有任何订阅者订阅了响应主题, 则响应消息将不会传递给任何客户端.</p>
<p>请求消息和响应消息可以具有任何<code>QoS等级</code>, 并且响应方可以使用具有非0会话过期间隔的会话. 通常使用<code>QoS等级0</code>发送请求消息, 并且只有在应答者正连接时才发送请求消息. 但这不是必须的.</p>
<p>响应者可以使用<code>共享订阅</code>来允许响应客户端池. 注意, 使用<code>共享订阅</code>时, 不保证消息在客户端之间的分发顺序.</p>
<p>请求方有责任确保它具有发布消息到请求消息的主题、并订阅响应主题属性中主题名的必要权限. 响应方有责任确保它具有订阅请求主题和发布到响应主题的权限. 虽然主题授权不属于本规范, 但建议服务端实施此类授权.</p>
<h4 id="4-10-2-确定响应主题值-非规范"><a href="#4-10-2-确定响应主题值-非规范" class="headerlink" title="4.10.2 确定响应主题值(非规范)"></a>4.10.2 确定响应主题值(非规范)</h4><p>请求方可以通过包括本地配置在内的任何方式来确定作为他们的响应主题的主题名. 为避免不同请求方之间的冲突, 由请求方客户端使用的响应主题最好对于该客户端是唯一的. 由于请求方和响应方通常都需要对这些主题进行授权, 因此使用随机主题名称将会对授权造成挑战.</p>
<p>为了解决此问题, 本规范在<code>CONNACK</code>报文中定义了一个名为响应信息的属性. 服务端可以使用此属性指导客户端如何选择使用的响应主题. 此机制对于服务端和客户端都是可选的. 连接时, 客户端通过设置<code>CONNECT</code>报文中的请求响应信息属性来请求服务端发送响应信息. 这会导致服务端在<code>CONNACK</code>报文中插入响应信息属性(UTF-8编码的字符串).</p>
<p>本规范不定义响应信息的内容, 但它可以被用来传递主题树的全局唯一部分, 该部分至少在其会话的整个生命周期内保留给该客户端. 使用这种机制, 可以在服务端而不是每个客户端中完成该属性的配置.</p>
<p>有关响应信息的定义, 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#312116-请求响应信息" target="_blank" rel="noopener">3.1.2.11.6节</a> .</p>
<h3 id="4-11-服务端重定向"><a href="#4-11-服务端重定向" class="headerlink" title="4.11 服务端重定向"></a>4.11 服务端重定向</h3><p>服务端<strong>可以</strong>通过发送包含原因码为<code>0x9C((临时)使用其他服务端)</code>或<code>0x9D(服务端已(永久)移动)</code>的<code>CONNACK</code>或<code>DISCONNECT</code>报文请求客户端使用另一台服务端, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述.服务端发送这些原因码时<strong>可以</strong>包含一个服务端参考属性, 用以说明客户端<strong>应该</strong>使用的服务端位置.</p>
<p>原因码<code>0x9C ((临时)使用其他服务端)</code> 指定客户端<strong>应该</strong>临时切换到另一台服务端. 另一台服务端可能是客户端已知的, 也可能是由服务端参考所指定的.</p>
<p>原因码<code>0x9D (服务端已(永久)移动)</code>指定客户端<strong>应该</strong>永久切换到另一台服务端. 另一台服务端可能是客户端已知的, 也可能是由服务端参考所指定的.</p>
<p>服务端参考是一个UTF-8编码字符串, 其值是一个由空格分隔开的参考列表. 本规范不指定服务端参考的格式.</p>
<pre><code>非规范评注
推荐每个参考包含名称及可选的端口号. 如果名称包含冒号, 则名称字符串可以由方括号括起来(“[“和“]”). 由方括号括起来的名称不能包含右方括号(“]”)字符, 用于表示使用冒号分隔符的IPv6地址.这是一个简化版的URI授权, 如 [RFC3986] 所述.

非规范评注
服务端参考中的名字通常代表主机名、DNS名 [RFC1035]、SRV名 [RFC2782] 或IP地址. 跟随冒号分隔符的通常是十进制端口号. 如果端口信息来自于DNS(比如包含SRV)或者使用默认端口, 则主机名后无需跟随端口号.

非规范评注
如果给出了多个服务端参考, 则期望客户端选择其中一个.

非规范评注
服务端参考示例如下:
myserver.xyz.org 
myserver.xyz.org:8883
10.10.151.22:8883 [fe80::9610:3eff:fe1c]:1883</code></pre><p>允许服务端不发送服务端参考, 允许客户端忽略服务端参考. 此特性可用于负载均衡、服务端重定位和服务端预置服务端.</p>
<h3 id="4-12-增强认证"><a href="#4-12-增强认证" class="headerlink" title="4.12 增强认证"></a>4.12 增强认证</h3><p>MQTT <code>CONNECT</code>报文使用用户名和密码字段支持基本的网络连接认证. 这些字段虽然称为简单密码认证, 但可以被用来承载其他形式的认证, 例如把密码作为令牌(Token)传递.</p>
<p>增强认证包含质询/响应风格的认证, 从而扩展了基本认证.它可能涉及在<code>CONNECT</code>报文之后、<code>CONNACK</code>报文之前的客户端和服务端之间<code>AUTH</code>报文交换.</p>
<p>服务端通过在<code>CONNECT</code>报文中添加认证方法字段来启动增强认证. 此字段指定使用的认证方法. 如果服务端不支持客户端提供的认证方法, 它<strong>可以</strong>发送一个包含原因码<code>0x8C(无效的认证方法)</code>或<code>0x87(未授权)</code>的<code>CONNACK</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述, 并且<strong>必须</strong>关闭网络连接 [MQTT-4.12.0-1].</p>
<p>认证方法是客户端和服务端关于认证数据中的数据和<code>CONNECT</code>报文中其他字段的含义, 以及客户端和服务端完成认证需要交换和处理的协议.</p>
<pre><code>非规范评注
认证方法通常为SASL(Simple Authentication and Security Layer)机制, 使用一个注册过的名称便于信息交换.然而, 认证方法不限于使用已注册的SASL机制.</code></pre><p>如果客户端选择的认证方法指定客户端先发送数据, 客户端<strong>应该</strong>在<code>CONNECT</code>报文中包含认证数据属性. 此属性可被用来提供认证方法指定的数据, 认证数据的内容由认证方法定义.</p>
<p>如果服务端需要额外的信息来完成认证, 它<strong>可以</strong>向客户端发送<code>AUTH</code>报文, 此报文<strong>必须</strong>包含原因码<code>0x18(继续认证)</code> [MQTT-4.12.0-2]. 如果认证方法需要服务端向客户端发送认证相关的数据, 这些数据在<code>认证数据(Authentication Data)</code>中发送.</p>
<p>客户端通过发送另一个<code>AUTH</code>报文响应来自服务端的 <code>AUTH</code> 报文, 此报文<strong>必须</strong>包含原因码<code>0x18(继续认证)</code> [MQTT-4.12.0-3]. 如果认证方法要求客户端向服务端发送认证相关的数据, 这些数据在<code>认证数据(Authentication Data)</code>中发送.</p>
<p>客户端和服务端按需交换<code>AUTH</code>报文, 直到服务端通过发送包含原因码为0的<code>CONNACK</code>报文接受认证为止. 如果接受认证需要向客户端发送数据, 这些数据在认证数据中发送.</p>
<p>客户端<strong>可以</strong>在处理过程中随时关闭连接. 它<strong>可以</strong>在关闭之前发送<code>DISCONNECT</code>报文. 服务端<strong>可以</strong>在处理过程中随时拒绝认证. 它<strong>可以</strong>发送包含原因码大于等于0x80的<code>CONNACK</code>报文 , 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述, 并且<strong>必须</strong>关闭网络连接 [MQTT-4.12.0-4].</p>
<p>如果初始<code>CONNECT</code>报文包含认证方法属性, 则所有的<code>AUTH</code>报文和成功的<code>CONNACK</code>报文必须包含与<code>CONNECT</code>报文中相同的认证方法属性. [MQTT-4.12.0-5].</p>
<p>增强认证的实现对于客户端和服务端来说都是可选的. 如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 则服务端不能发送AUTH报文, 且不能在<code>CONNACK</code>报文中发送认证方法 [MQTT-4.12.0-6]. 如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 则客户端不能向服务端发送<code>AUTH</code>报文 [MQTT-4.12.0-7].</p>
<p>如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 服务端应该使用<code>CONNECT</code>报文中的信息、TLS会话和网络连接进行认证.</p>
<p><code>SCRAM认证</code>非规范示例</p>
<ul>
<li>客户端到服务端:<code>CONNECT</code>认证方法=”SCRAM-SHA-1”, 认证数据=client-first-data</li>
<li>服务端到客户端:<code>AUTH</code>原因码=0x18, 认证方法=”SCRAM-SHA-1”, 认证数据=server-first-data</li>
<li>客户端到服务端:<code>AUTH</code>原因码=0x18, 认证方法=”SCRAM-SHA-1”, 认证数据=client-final-data</li>
<li>服务端到客户端:<code>CONNACK</code>原因码=0, 认证方法=”SCRAM-SHA-1”, 认证数据=server-final-data</li>
</ul>
<p><code>Kerberos认证</code>非规范示例</p>
<ul>
<li>客户端到服务端:<code>CONNECT</code>认证方法=”GS2-KRB5”</li>
<li>服务端到客户端:<code>AUTH</code>原因码=0x18, 认证方法=”GS2-KRB5”</li>
<li>客户端到服务端:<code>AUTH</code>原因码=0x18, 认证方法=”GS2-KRB5”, 认证数据=initial context token</li>
<li>服务端到客户端:<code>AUTH</code>原因码=0x18, 认证方法=”GS2-KRB5”, 认证数据=reply context token</li>
<li>客户端到服务端:<code>AUTH</code>原因码=0x18, 认证方法=”GS2-KRB5”</li>
<li>服务端到客户端:<code>CONNACK</code>原因码=0, 认证方法=”GS2-KRB5”, 认证数据=outcome of authentication</li>
</ul>
<h4 id="4-12-1-重新认证"><a href="#4-12-1-重新认证" class="headerlink" title="4.12.1 重新认证"></a>4.12.1 重新认证</h4><p>如果客户端在<code>CONNECT</code>报文中提供了认证方法, 它<strong>可以</strong>在收到<code>CONNACK</code>报文之后的任何时间通过发送包含原因码<code>0x19(重新认证)</code>的<code>AUTH</code>报文发起重新认证. 客户端<strong>必须</strong>将认证方法设置为与最初验证网络连接时的认证方法一致 [MQTT-4.12.1-1].如果认证方法需要客户端先发送数据, 则此<code>AUTH</code>报文包含第一片认证数据.</p>
<p>服务端通过向客户端发送<code>AUTH</code>报文来响应此重新认证请求, 包含原因码为0x00(成功)的<code>AUTH</code>报文指示重新认证完成, 包含原因码为<code>0x18(继续认证)</code>的<code>AUTH</code>报文指示需要更多的认证数据. 客户端可以通过发送包含原因码<code>0x18(继续认证)</code>的<code>AUTH</code>报文来响应附加的认证数据. 此流程与原始身份验证一样, 直到重新认证完成或重新认证失败.</p>
<p>如果重新认证失败, 客户端或服务端<strong>应该</strong>发送包含适当原因码的<code>DISCONNECT</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 并且必须关闭网络连接 [MQTT-4.12.1-2].</p>
<p>在重新认证的过程中, 客户端和服务端的其他报文流可以继续使用之前的认证.</p>
<pre><code>非规范评注
服务端可以通过拒绝重新认证来限制客户端在重新认证中尝试的更改范围. 例如, 如果服务端不允许更改用户名, 它可以使任何尝试更改用户名的重新认证都失败.</code></pre><h3 id="4-13-错误处理"><a href="#4-13-错误处理" class="headerlink" title="4.13 错误处理"></a>4.13 错误处理</h3><h4 id="4-13-1-无效报文和协议错误"><a href="#4-13-1-无效报文和协议错误" class="headerlink" title="4.13.1 无效报文和协议错误"></a>4.13.1 无效报文和协议错误</h4><p><code>无效报文(Malformed Packet)</code>和<code>协议错误(Protocol Error)</code>的定义见<a href="https://www.zybuluo.com/khan-lau/note/1325300#12-术语" target="_blank" rel="noopener">1.2节</a> 术语.这些错误案例的部分术语贯穿本规范. 客户端或服务端对其收到的MQTT控制报文的检查严格程度依赖:</p>
<ul>
<li>客户端或服务端实现的大小.</li>
<li>实现支持的性能.</li>
<li>接收端对发送端发送的MQTT控制报文的信任程度.</li>
<li>接收端对用于分发MQTT控制报文的网络的信任程度.</li>
<li>继续处理错误报文的的后果.</li>
</ul>
<p>如果发送端遵守此规范, 它将不会发送无效报文或导致协议错误. 然而, 如果客户端在收到<code>CONNACK</code>报文之前发送MQTT控制报文, 它可能会因为错误的估计了服务端的性能而导致协议错误. 参考<a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">3.1.4节</a> <code>CONNECT</code> 行为.</p>
<p>无效报文和协议错误使用的原因码包括:</p>
<ul>
<li><code>0x81</code> 无效报文</li>
<li><code>0x82</code> 协议错误</li>
<li><code>0x93</code> 超过接收最大值</li>
<li><code>0x95</code> 报文过大</li>
<li><code>0x9A</code> 不支持保留</li>
<li><code>0x9B</code> 不支持的QoS等级</li>
<li><code>0x9E</code> 不支持共享订阅</li>
<li><code>0xA1</code> 不支持订阅标识符</li>
<li><code>0xA2</code> 不支持通配符订阅</li>
</ul>
<p>当客户端检测到无效报文或协议错误, 并且本规范中给出了相应的原因码时, 它应该关闭网络连接. 在<code>AUTH</code>报文出错的情况下它可以在关闭网络连接之前发送包含原因码的<code>DISCONNECT</code>报文. 在其他报文出错的情况下它应该在关闭网络连接之前发送包含原因码的<code>DISCONNECT</code>报文. 使用原因码<code>0x81(错误报文)</code>或<code>0x82(协议错误)</code>, 除非包含<a href="https://www.zybuluo.com/khan-lau/note/1325300#31421-断开原因码" target="_blank" rel="noopener">3.14.2.1 断开原因码</a> 中定义的更具体的原因码.</p>
<p>当服务端检测到无效报文或协议错误, 并且本规范中给出了相应的原因码时, 它必须关闭网络连接 [MQTT-4.13.1-1]. 在<code>CONNECT</code>报文出错的情况下它可以在关闭网络连接之前发送包含原因码的<code>CONNACK</code>报文. 在其他报文出错的情况下它应该在关闭网络连接之前发送包含原因码的<code>DISCONNECT</code>报文. 使用原因码<code>0x81(无效报文)</code>或<code>0x82(协议错误)</code>, 除非包含<a href="https://www.zybuluo.com/khan-lau/note/1325300#3222-连接原因码" target="_blank" rel="noopener">3.2.2.2节 - 连接原因码</a> 或<a href="https://www.zybuluo.com/khan-lau/note/1325300#31421-断开原因码" target="_blank" rel="noopener">3.14.2.1节 – 断开原因码</a> 中定义的更具体的原因码. 对其他会话没有影响.</p>
<p>如果服务端或客户端省略了检查MQTT控制报文的某些特性, 它可能无法检测到某个错误, 因此可能会导致数据被损坏.</p>
<h4 id="4-13-2-其他错误"><a href="#4-13-2-其他错误" class="headerlink" title="4.13.2 其他错误"></a>4.13.2 其他错误</h4><p>发送端无法预料到无效报文和协议错误以外的错误, 因为它可能有某些没有告知发送端的约束. 客户端或服务端可能在接收时遇到短暂的错误, 比如内存不足, 导致无法成功的处理某个MQTT控制报文.</p>
<p>包含原因码大于等于0x80的确认报文<code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBACK</code>, <code>UNSUBACK</code>表明收到了某个报文标识符的报文出错. 这不会影响其他会话或此会话上的其他报文.</p>
<p><code>CONNACK</code>报文和<code>DISCONNECT</code>报文允许使用大于等于0x80的原因码以指示网络连接将被关闭. 如果某个大于等于0x80的原因码被指定, 无论是否发送<code>CONNACK</code>报文或<code>DISCONNECT</code>报文, 必须关闭网络连接 [MQTT-4.13.2-1]. 发送这些原因码不会影响任何其他会话.</p>
<p>如果控制报文包含多个错误, 接收端可以按照任意顺序对报文进行验证, 并对发现的任何错误采取适当的行为.</p>
<h2 id="5-安全-非规范"><a href="#5-安全-非规范" class="headerlink" title="5 安全(非规范)"></a>5 安全(非规范)</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>强烈建议提供<code>TLS [RFC5246]</code> 的服务端实现使用<code>TCP端口8883</code>(IANA服务名:secure-mqtt).</p>
<p>安全是一个快速变化的领域, 所以在设计安全解决方案时总是使用最新的建议.</p>
<p>解决方案需要考虑的风险包括:</p>
<ul>
<li>设备可能会被盗用</li>
<li>客户端和服务端的静态数据可能是可访问的(可能会被修改)</li>
<li>协议行为可能有副作用(如计时器攻击)</li>
<li>拒绝服务(DoS)攻击</li>
<li>通信可能会被拦截、修改、重定向或泄露</li>
<li>虚假MQTT控制报文注入</li>
</ul>
<p>MQTT方案通常部署在不安全的通信环境中.在这种情况下, 协议实现通常需要提供这些机制:</p>
<ul>
<li>用户和设备身份认证</li>
<li>服务端资源访问授权</li>
<li>MQTT控制报文和内嵌应用数据的完整性校验</li>
<li>MQTT控制报文和内嵌应用数据的隐私控制</li>
</ul>
<p>作为传输层协议, MQTT仅关注消息传输, 提供合适的安全功能是实现者的责任.使用<code>TLS [RFC5246]</code> 是比较普遍的选择.</p>
<p>除了技术上的安全问题外, 还有地区因素(例如<code>美国欧盟隐私盾框架 [USEUPRIVSH]</code>), 行业标准(例如<code>第三方支付行业数据安全标准 [PCIDSS]</code>), 监管方面的考虑(例如<code>萨斯班-奥克斯利法案[SARBANES]</code>).</p>
<h3 id="5-2-MQTT解决方案-安全和认证"><a href="#5-2-MQTT解决方案-安全和认证" class="headerlink" title="5.2 MQTT解决方案:安全和认证"></a>5.2 MQTT解决方案:安全和认证</h3><p>协议实现可能需要提供符合特定行业安全标准, 如<code>NIST网络安全框架 [NISTCSF]</code>, 第<code>三方支付行业数据安全标准 [PCIDSS]</code>, <code>美国联邦信息处理标准 [FIPS1402]</code> 和<code>NSA加密组合B [NSAB]</code>.</p>
<p>在MQTT的补充出版物(MQTT and the NIST Framework for Improving Critical Infrastructure Cybersecurity [MQTTNIST])中可以找到在<code>NIST网络安全框架 [NISTCSF]</code> 中使用MQTT的指导. 使用行业证明、独立审计和认证技术有助于满足合规要求.</p>
<h3 id="5-3-轻量级的加密与受限设备"><a href="#5-3-轻量级的加密与受限设备" class="headerlink" title="5.3 轻量级的加密与受限设备"></a>5.3 轻量级的加密与受限设备</h3><p>广泛采用的加密算法是<code>高级加密标准 [AES]</code>. 对AES提供了硬件支持的处理器有很多, 但通常不包含嵌入式处理器. <code>加密算法ChaCha20 [CHACHA20]</code> 软件加解密速度快很多, 但不像AES那样广泛可用.</p>
<p>推荐使用为资源受限的低端设备特别优化过的<code>轻量级加密国际标准ISO 29192 [ISO29192]</code>.</p>
<h3 id="5-4-实现注意事项"><a href="#5-4-实现注意事项" class="headerlink" title="5.4 实现注意事项"></a>5.4 实现注意事项</h3><p>实现或使用MQTT时需要考虑许多安全问题. 以下章节不应被视为核对清单 .</p>
<p>协议实现时可以实现下面的一部分或全部:</p>
<h4 id="5-4-1-客户端身份认证"><a href="#5-4-1-客户端身份认证" class="headerlink" title="5.4.1 客户端身份认证"></a>5.4.1 客户端身份认证</h4><p><code>CONNECT</code>报文包含<code>用户名</code>和<code>密码</code>字段. 实现可以决定如何使用这些字段的内容.实现者可以提供自己的身份验证机制, 或者使用外部的认证系统如<code>LDAP [RFC4511]</code> 或 <code>Auth [RFC6749]</code> , 还可以利用操作系统的认证机制.</p>
<p>MQTT v5.0提供了一种增强认证机制, <a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">如4.12节</a> 所述.使用此机制需要客户端和服务端双方的支持.</p>
<p>实现可以明文传递认证数据, 混淆数据元素, 或者不要求任何认证数据, 但应该意识到这会增加中间人攻击和重放攻击的风险. <a href="https://www.zybuluo.com/khan-lau/note/1325300#545-应用消息和mqtt控制报文的保密性" target="_blank" rel="noopener">5.4.5节</a> 介绍了确保数据私密的方法.</p>
<p>在客户端和服务端之间使用虚拟专用网(VPN)可以确保数据只被授权的客户端收到.</p>
<p>使用<code>TLS [RFC5246]</code> 时, 服务端可以使用客户端发送的TLS证书验证客户端的身份.</p>
<p>实现可以允许客户端通过应用消息给服务端发送用于身份验证的凭证.</p>
<h4 id="5-4-2-客户端授权"><a href="#5-4-2-客户端授权" class="headerlink" title="5.4.2 客户端授权"></a>5.4.2 客户端授权</h4><p>如果客户端已经成功通过身份认证, 服务端实现需要在接受连接之前执行授权检查.</p>
<p>授权可以基于客户端提供的信息如用户名, 客户端主机名/IP地址, 或认证机制的结果.</p>
<p>具体来说, 实现应该检查客户端是否被授权使用此客户标识符, 因为客户标识符提供了对MQTT会话状态的访问(如<a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">4.1节</a> 所述). 此授权检查是为了防止某个客户端偶然或恶意的使用了已被其他客户端所使用的客户标识符.</p>
<p>实现应该提供发生在<code>CONNECT</code>之后的访问控制以限制客户端发布消息到特定主体或使用特定主体过滤器进行订阅的能力. 实现需要考虑对具有广泛作用域的主题过滤器的访问限制, 如<code>&quot;#&quot;</code>主题过滤器.</p>
<h4 id="5-4-3-服务端身份认证"><a href="#5-4-3-服务端身份认证" class="headerlink" title="5.4.3 服务端身份认证"></a>5.4.3 服务端身份认证</h4><p>MQTT协议不是双向信任的.基本认证没有提供客户端验证服务端身份的机制.某些形式的扩展认证允许双向认证.</p>
<p>但是使用<code>TLS [RFC5246]</code> 时, 客户端可以使用服务端发送的TLS证书验证服务端的身份. 从单IP多域名提供MQTT服务的实现应该考虑 [RFC6066] 第3节定义的TLS的<code>SNI扩展</code>. SNI允许客户端告诉服务端它要连接的服务端主机名.</p>
<p>实现可以允许服务端通过应用消息给客户端发送凭证用于身份验证. MQTT v5.0提供了一种增强的认证机制, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">4.12节</a> 所述, 它可以被客户端用于验证服务端. 使用此机制需要客户端和服务端双方的支持.</p>
<p>在客户端和服务端之间使用虚拟专用网(VPN)可以确保客户端正连接的是预期的服务端.</p>
<h4 id="5-4-4-应用消息和MQTT控制报文的完整性"><a href="#5-4-4-应用消息和MQTT控制报文的完整性" class="headerlink" title="5.4.4 应用消息和MQTT控制报文的完整性"></a>5.4.4 应用消息和MQTT控制报文的完整性</h4><p>应用可以在应用消息中单独包含哈希值. 这样做可以为<code>PUBLISH</code>报文的网络传输和静态数据提供内容的完整性检查.</p>
<p><code>TLS [RFC5246]</code> 提供了对网络传输的数据做完整性校验的哈希算法.</p>
<p>在客户端和服务端之间使用虚拟专用网(VPN)连接可以在VPN覆盖的网络段提供数据完整性检查.</p>
<h4 id="5-4-5-应用消息和MQTT控制报文的保密性"><a href="#5-4-5-应用消息和MQTT控制报文的保密性" class="headerlink" title="5.4.5 应用消息和MQTT控制报文的保密性"></a>5.4.5 应用消息和MQTT控制报文的保密性</h4><p><code>TLS [RFC5246]</code> 可以对网络传输的数据加密.如果有效的 TLS 密码组合包含的加密算法为 NULL, 那么它不会加密数据. 要确保客户端和服务端的保密, 应避免使用这些密码组合.</p>
<p>应用可以单独加密应用消息的内容. 这可以提供应用消息传输途中和静态数据的私密性. 但不能给应用消息的其它属性如主题名加密.</p>
<p>客户端和服务端实现可以加密存储静态数据, 例如可以将应用消息作为会话的一部分存储.</p>
<p>在客户端和服务端之间使用虚拟专用网(VPN)连接可以在VPN覆盖的网络段保证数据的私密性.</p>
<h4 id="5-4-6-消息传输的不可否认性"><a href="#5-4-6-消息传输的不可否认性" class="headerlink" title="5.4.6 消息传输的不可否认性"></a>5.4.6 消息传输的不可否认性</h4><p>应用设计者可能需要考虑适当的策略, 以实现端到端的<code>不可否认性(non-repudiation)</code>.</p>
<h4 id="5-4-7-客户端和服务端盗用检测"><a href="#5-4-7-客户端和服务端盗用检测" class="headerlink" title="5.4.7 客户端和服务端盗用检测"></a>5.4.7 客户端和服务端盗用检测</h4><p>使用<code>TLS [RFC5246]</code>的客户端和服务端实现应该能够确保, 初始化TLS连接时提供的 SSL 证书是与主机名(客户端要连接的或服务端将被连接的)关联的.</p>
<p>使用<code>TLS [RFC5246]</code> 的客户端和服务端实现, 可以选择提供<code>检查证书吊销列表(CRLs [RFC5280])</code>和<code>在线整数状态协议(OSCP) [RFC6960]</code> 的功能, 拒绝使用被吊销的整数.</p>
<p>物理部署可以将防篡改硬件与应用消息的特殊数据传输结合. 例如, 一个仪表可能会内置一个GPS以确保没有在未授权的地区使用. IEEE安全设备认证 [IEEE8021AR] 就是用于实现这个机制的一个标准, 它使用加密绑定标识符验证设备身份.</p>
<h4 id="5-4-8-异常行为检测"><a href="#5-4-8-异常行为检测" class="headerlink" title="5.4.8 异常行为检测"></a>5.4.8 异常行为检测</h4><p>服务端实现可以监视客户端的行为, 检测潜在的安全风险.例如:</p>
<ul>
<li>重复的连接请求</li>
<li>重复的身份验证请求</li>
<li>连接的异常终止</li>
<li>主题扫描(请求发送或订阅大量主题)</li>
<li>发送无法送达的消息(没有订阅者的主题)</li>
<li>客户端连接但是不发送数据</li>
</ul>
<p>发现违反安全规则的行为, 服务端实现可以关闭客户端的网络连接.</p>
<p>服务端实现检测不受欢迎的行为, 可以基于IP地址或客户标识符实现一个动态黑名单列表.</p>
<p>服务部署可以使用网络层次控制(如果可用)实现基于IP地址或其它信息的速率限制或黑名单.</p>
<h4 id="5-4-9-其它安全注意事项"><a href="#5-4-9-其它安全注意事项" class="headerlink" title="5.4.9 其它安全注意事项"></a>5.4.9 其它安全注意事项</h4><p>如果客户端或服务端的TLS证书丢失, 或者我们考虑证书被盗用或者被吊销(利用 CRLs [RFC5280] 和 OSCP [RFC6960])的情况.</p>
<p>客户端或服务端验证凭证时, 如果发现用户名和密码丢失或被盗用, 应该吊销或者重新发放.</p>
<p>在使用长连接时:<br>- 客户端和服务端使用<code>TLS [RFC5246]</code> 时应该允许重新协商会话以确认新的加密参数(替换会话密钥, 更换密码组合, 更换认证凭证).<br>- 服务端可以关闭客户端的网络连接, 并要求他们使用新的凭证重新验证身份.<br>- 服务端可以要求客户端使用<a href="https://www.zybuluo.com/khan-lau/note/1325300#4121-重新认证" target="_blank" rel="noopener">4.12.1节</a> 中描述的机制周期性的进行重新认证.</p>
<p>资源受限设备或使用受限网络的客户端可以使用<code>TLS [RFC5246</code>] 会话恢复, 以降低<code>TLS [RFC5246]</code> 会话重连的成本.</p>
<p>连接到服务端的客户端与其它连接到服务端的客户端之间有一个信任传递关系, 它们都有权在同一个主题上发布消息.</p>
<h4 id="5-4-10-使用SOCK代理"><a href="#5-4-10-使用SOCK代理" class="headerlink" title="5.4.10 使用SOCK代理"></a>5.4.10 使用SOCK代理</h4><p>客户端实现应该意识到某些环境要求使用<code>SOCKSv5 [RFC1928]</code> 代理创建出站的网络连接. 某些MQTT实现可以利用安全隧道(如SSH)通过SOCKS代理. 一个实现决定支持SOCKS时, 它们应该同时支持匿名的和用户名密码验证的SOCKS代理. 对于后一种情况, 实现应该意识到SOCKS可能使用明文认证, 因此应该避免使用相同的凭证连接 MQTT 服务器.</p>
<h4 id="5-4-11-安全配置文件"><a href="#5-4-11-安全配置文件" class="headerlink" title="5.4.11 安全配置文件"></a>5.4.11 安全配置文件</h4><p>实现者和方案设计者可能希望将安全当作配置文件集合应用到MQTT协议中. 下面描述的是一个分层的安全等级结构.</p>
<h4 id="5-4-11-1-开放通信配置"><a href="#5-4-11-1-开放通信配置" class="headerlink" title="5.4.11.1 开放通信配置"></a>5.4.11.1 开放通信配置</h4><p>使用开放通信配置时, MQTT协议运行在一个没有内置额外安全通信机制的开放网络上.</p>
<h4 id="5-4-11-2-安全网络通信配置"><a href="#5-4-11-2-安全网络通信配置" class="headerlink" title="5.4.11.2 安全网络通信配置"></a>5.4.11.2 安全网络通信配置</h4><p>使用安全网络通信配置时, MQTT协议运行在有安全控制的物理或虚拟网络上, 如VPN或物理安全网络.</p>
<h4 id="5-4-11-3-安全传输配置"><a href="#5-4-11-3-安全传输配置" class="headerlink" title="5.4.11.3 安全传输配置"></a>5.4.11.3 安全传输配置</h4><p>使用安全传输配置时, MQTT协议运行在使用 <code>TLS [RFC5246]</code> 的物理或虚拟网络上, 它提供了身份认证, 完整性和保密性.</p>
<p>使用内置的用户名称和密码字段, <code>TLS [RFC5246]</code> 客户端身份认证可被用于(或者替代)MQTT客户端认证.</p>
<h4 id="5-4-11-4-工业标准的安全配置"><a href="#5-4-11-4-工业标准的安全配置" class="headerlink" title="5.4.11.4 工业标准的安全配置"></a>5.4.11.4 工业标准的安全配置</h4><p>可以预料的是, MQTT协议被设计为支持很多工业标准的应用配置, 每一种定义一个威胁模型和用于定位威胁的特殊安全机制. 特殊的安全机制推荐从下面的方案中选择:</p>
<p>[<code>NISTCSF</code>] NIST网络安全框架<br>[<code>NIST7628</code>] NISTIR 7628智能电网网络安全指南<br>[<code>FIPS1402</code>] (FIPS PUB 140-2)加密模块的安全要求<br>[<code>PCIDSS</code>] PCI-DSS 第三方支付行业数据安全标准<br>[<code>NSAB</code>] NSA 加密组合B</p>
<h2 id="6-使用WebSocket作为网络层"><a href="#6-使用WebSocket作为网络层" class="headerlink" title="6 使用WebSocket作为网络层"></a>6 使用WebSocket作为网络层</h2><p>如果MQTT在<code>WebSocket [RFC6455]</code> 连接上传输, 要满足下面的条件:</p>
<ul>
<li>MQTT控制报文<strong>必须</strong>使用WebSocket二进制数据帧发送.如果收到任何其它类型的数据帧, 接收者<strong>必须</strong>关闭网络连接 [MQTT-6.0.0-1].</li>
<li>单个WebSocket数据帧<strong>可以</strong>包含多个或者部分MQTT报文.接收者<strong>不能</strong>假设MQTT控制报文按WebSocket帧边界对齐 [MQTT-6.0.0-2].</li>
<li>客户端<strong>必须</strong>将字符串”mqtt”包含在它提供的WebSocket子协议列表里 [MQTT-6.0.0-3].</li>
<li>服务端选择和返回的WebSocket子协议名<strong>必须</strong>是”mqtt” [MQTT-6.0.0-4].</li>
<li>用于连接客户端和服务器的WebSocket URI对MQTT协议没有任何影响.</li>
</ul>
<h3 id="6-1-IANA注意事项"><a href="#6-1-IANA注意事项" class="headerlink" title="6.1 IANA注意事项"></a>6.1 IANA注意事项</h3><p>本规范请求IANA修改“WebSocket子协议名”条目下MQTT子协议注册信息为下列数据:</p>
<ul>
<li>图 6 1 IANA WebSocket标识符</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">子协议标识符</td>
</tr>
<tr>
<td align="left">子协议通用名</td>
</tr>
<tr>
<td align="left">子协议定义</td>
</tr>
</tbody></table>
<h2 id="7-一致性"><a href="#7-一致性" class="headerlink" title="7 一致性"></a>7 一致性</h2><p>MQTT规范定义了MQTT客户端实现和MQTT服务端实现的一致性要求. MQTT实现可以同时作为MQTT客户端和MQTT服务端.</p>
<h2 id="7-1-一致性条款"><a href="#7-1-一致性条款" class="headerlink" title="7.1 一致性条款"></a>7.1 一致性条款</h2><h4 id="7-1-1-MQTT服务端一致性条款"><a href="#7-1-1-MQTT服务端一致性条款" class="headerlink" title="7.1.1 MQTT服务端一致性条款"></a>7.1.1 MQTT服务端一致性条款</h4><p>服务端的定义, 参考术语章节的<code>服务端(Server)</code>部分.</p>
<p>MQTT服务端只有满足下面所有的要求才算是符合本规范:<br>\1. 服务端发送的所有MQTT控制报文的格式符合<a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章</a>和<a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章</a>描述的格式.<br>\2. 遵守<a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">4.7节</a> 描述的主题匹配规则和<a href="https://www.zybuluo.com/khan-lau/note/1325300#48-订阅" target="_blank" rel="noopener">4.8节</a> 匹配的订阅规则.<br>\3. 满足下列章节中所有必须级别的要求, 明确仅适用于对客户端的除外:<br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#1-概述" target="_blank" rel="noopener">第一章 - 介绍</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章 - MQTT控制报文格式</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章 - MQTT控制报文</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#4-操作行为" target="_blank" rel="noopener">第四章 - 操作行为</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">第六章 - 使用WebSocket作为网络层</a><br>\4. 为了能够与任何其他一致的(MQTT)实现进行互操作, 无需使用在规范之外定义的任何扩展.</p>
<h4 id="7-1-2-MQTT客户端一致性条款"><a href="#7-1-2-MQTT客户端一致性条款" class="headerlink" title="7.1.2 MQTT客户端一致性条款"></a>7.1.2 MQTT客户端一致性条款</h4><p>客户端的定义, 参考术语章节的<code>客户端(Client)</code> 部分.</p>
<p>MQTT客户端只有满足下面所有的要求才算是符合本规范:<br>\1. 客户端发送端所有MQTT控制报文的格式符合<a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章</a>和<a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章</a>描述的格式.<br>\2. 满足下列章节中所有必须级别的要求, 明确仅适用于对服务端的除外:<br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#1-概述" target="_blank" rel="noopener">第一章 - 介绍</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#2-mqtt控制报文格式" target="_blank" rel="noopener">第二章 - MQTT控制报文格式</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#3-mqtt控制报文" target="_blank" rel="noopener">第三章 - MQTT控制报文</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#4-操作行为" target="_blank" rel="noopener">第四章 - 操作行为</a><br>- <a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">第六章 - 使用WebSocket作为网络层</a><br>\3. 为了能够与任何其他一致的(MQTT)实现进行互操作, 无需使用在规范之外定义的任何扩展.</p>
<h2 id="Appendix-A-致谢"><a href="#Appendix-A-致谢" class="headerlink" title="Appendix A. 致谢"></a>Appendix A. 致谢</h2><p>技术委员会特别感谢Andy Stanford-Clark博士和Arlen Nipper博士作为MQTT协议的原始发明者以及他们对标准化过程的持续支持.</p>
<p>以下成员在本规范制定期间为OASIS技术委员会成员, 他们的贡献值得感谢:</p>
<p>参与者:<br>- Senthil Nathan Balasubramaniam (Infiswift)<br>- Dr. Andrew Banks, editor (IBM)<br>- Ken Borgendale, editor (IBM)<br>- Ed Briggs, editor (Microsoft)<br>- Raphael Cohn (Individual)<br>- Richard Coppen, chairman (IBM)<br>- William Cox (Individual)<br>- Ian Craggs , secretary (IBM)<br>- Konstantin Dotchkoff (Microsoft)<br>- Derek Fu (IBM)<br>- Rahul Gupta, editor (IBM)<br>- Stefan Hagen (Individual)<br>- David Horton (Solace Systems)<br>- Alex Kritikos (Software AG, Inc.)<br>- Jonathan Levell (IBM)<br>- Shawn McAllister (Solace Systems)<br>- William McLane (TIBCO Software Inc.)<br>- Peter Niblett (IBM)<br>- Dominik Obermaier (dc-square GmbH)<br>- Nicholas O’Leary (IBM)<br>- Brian Raymor, chairman (Microsoft)<br>- Andrew Schofield (IBM)<br>- Tobias Sommer (Cumulocity)<br>- Joe Speed (IBM)<br>- Dr Andy Stanford-Clark (IBM)<br>- Allan Stockdill-Mander (IBM)<br>- Stehan Vaillant (Cumulocity)</p>
<p>有关对早期版本MQTT协议做出贡献的人员列表, 参考MQTT v3.1.1规范中的附录A [MQTTV311].</p>
<h2 id="Appendix-B-强制性规范声明-非规范"><a href="#Appendix-B-强制性规范声明-非规范" class="headerlink" title="Appendix B. 强制性规范声明(非规范)"></a>Appendix B. 强制性规范声明(非规范)</h2><p>此附录是非规范性的, 只作为本文档正文中可以找到的大量一致性声明的摘要提供. 参考 <a href="https://www.zybuluo.com/khan-lau/note/1325300#7-一致性" target="_blank" rel="noopener">第七章</a> 一致性要求限制列表.</p>
<p>规范声明序号 规范声明<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">MQTT-1.5.4-1</a> UTF-8编码字符串中的数据<strong>必须</strong>是按照 [Unicode] 规范定义的, 在RFC 3629 [RFC3629] 中重申的有效的UTF-8格式. 特别需要指出的是, 这些数据<strong>不能</strong>包含字符码在U+D800和U+DFFF之间的数据.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">MQTT-1.5.4-2</a> UTF-8编码的字符串<strong>不能</strong>包含空字符U+0000.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#154-utf-8-编码字符串" target="_blank" rel="noopener">MQTT-1.5.4-3</a> UTF-8编码序列0xEF 0xBB 0xBF总是被解释为U+FEFF (“零宽度非换行空白字符”) , 无论它出现在字符串的什么位置, 报文接收者都<strong>不能</strong>跳过或者剥离它.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#155-变长字节整数" target="_blank" rel="noopener">MQTT-1.5.5-1</a> 编码值<strong>必须</strong>使用表示该值所需的最少字节数.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#157-utf-8字符串对" target="_blank" rel="noopener">MQTT-1.5.7-1</a> 所有的字符串都<strong>必须</strong>符合UTF-8编码字符串的要求.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#213-标志" target="_blank" rel="noopener">MQTT-2.1.3-1</a> 如果标记位被标记为“保留”, 则保留它以供将来使用, 并且<strong>必须</strong>设置为所列出的值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-2</a> QoS等级为0的<code>PUBLISH</code>报文<strong>不能</strong>包含报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-3</a> 客户端每次发送新的<code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>或<code>PUBLISH</code>(当QoS等级&gt;0)MQTT控制报文时, 它<strong>必须</strong>为其分配一个当前未被使用的非0报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-4</a> 服务端每次发送新的<code>PUBLISH</code>(当QoS等级&gt;0)MQTT控制报文时, 它<strong>必须</strong>为其分配一个当前未被使用的非0报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-5</a> <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>或<code>PUBCOMP</code>报文<strong>必须</strong>包含<code>PUBLISH</code>报文中发送的原始报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#221-报文标识符" target="_blank" rel="noopener">MQTT-2.2.1-6</a> <code>SUBACK</code>和<code>UNSUBACK</code>报文<strong>必须</strong>包含相应的<code>SUBSCRIBE</code>和<code>UNSUBSCRIBE</code>报文中使用的报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#2221-属性长度" target="_blank" rel="noopener">MQTT-2.2.2-1</a> 如果没有属性, 属性长度必须为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#31-connect--连接请求" target="_blank" rel="noopener">MQTT-3.1.0-1</a> 客户端到服务端的网络连接建立后, 客户端发送给服务端的第一个报文<strong>必须</strong>是<code>CONNECT</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#31-connect--连接请求" target="_blank" rel="noopener">MQTT-3.1.0-2</a> 当协议错误并关闭网络连接时, 服务端<strong>必须</strong>处理客户端发送的第二个<code>CONNECT</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-1</a> 协议名<strong>必须</strong>是UTF-8字符串”MQTT”. 如果服务端不想接受<code>CONNECT</code>, 并希望透露它是MQTT服务端, 它<strong>可以</strong>发送一个包含原因码为<code>0x84(不支持的协议版本)</code>的<code>CONNACK</code>报文, 然后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-2</a> 如果协议版本不为5, 且服务端不想接受<code>CONNECT</code>报文, 则服务端<strong>可以</strong>发送一个包含原因码为<code>0x84(不支持的协议版本)</code>的<code>CONNACK</code>报文, 然后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-3</a> 服务端<strong>必须</strong>验证<code>CONNECT</code>报文的保留标志位(第0位)是否为 0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-4</a> 如果<code>CONNECT</code>报文的新开始标志被设置为1, 则客户端和服务端<strong>必须</strong>丢弃任何已存在的会话并开始一个新的会话.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-5</a> 如果<code>CONNECT</code>报文的新开始标志被设置为0, 并且存在与该客户标识符相关联的会话, 服务端<strong>必须</strong>基于此会话恢复与客户端的通信.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-6</a> 如果<code>CONNECT</code>报文的新开始标志被设置为0, 并且不存在与该客户标识符相关联的会话, 则服务端<strong>必须</strong>创建一个新的会话.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-7</a> 遗嘱标志被设置为1, 表示遗嘱消息<strong>必须</strong>被存储在服务端并与会话相关联.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-8</a> 在网络连接被关闭且遗嘱延时间隔已过或会话结束时遗嘱消息<strong>必须</strong>被发布, 除非遗嘱消息被服务端在收到包含原因码为<code>0x00(正常关闭)</code>的<code>DISCONNECT</code>报文后删除或关于此客户标识符的一个新的网络连接在遗嘱消息间隔过期之前被打开.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-9</a> 如果遗嘱标志被设置为0, 连接标志中的遗嘱QoS等级和遗嘱保留字段<strong>将会</strong>被服务端使用, 遗嘱属性、遗嘱主题和遗嘱消息字段<strong>必须</strong>存在于载荷中.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-10</a> 一旦遗嘱消息被发布或者服务端收到包含原因码为0x00(正常关闭)的<code>DISCONNECT</code>报文, 遗嘱消息<strong>必须</strong>从服务端的会话中删除.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-11</a> 如果遗嘱标志设置为0, 遗嘱QoS等级<strong>必须</strong>也设置为0 (0x00).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-12</a> 如果遗嘱标志设置为1, 遗嘱QoS等级<strong>可以</strong>被设置为0(0x00), 1(0x01)或2(0x02).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-13</a> 如果遗嘱标志被设置为0, 遗嘱保留标志也<strong>必须</strong>设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-14</a> 如果遗嘱标志被设置为1时, 如果遗嘱保留被设置为0, 则服务端<strong>必须</strong>将遗嘱消息当做非保留消息发布.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-15</a> 如果遗嘱保留被设置为1, 则服务端<strong>必须</strong>将遗嘱消息当做保留消息发布.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-16</a> 如果用户名标志被设置为 0, 有效载荷中<strong>不能</strong>包含用户名字段.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-17</a> 如果用户名标志被设置为 0, 有效载荷中<strong>必须</strong>包含用户名字段.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-18</a> 如果密码标志被设置为 0, 有效载荷中<strong>不能</strong>包含密码字段.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-19</a> 如果密码标志被设置为 1, 有效载荷中<strong>必须</strong>包含密码字段.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-20</a> 如果保持连接值不为0, 且没有任何其它的MQTT控制报文可以发送, 客户端<strong>必须</strong>发送一个<code>PINGREQ</code> 报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-21</a> 如果服务端返回的<code>CONNACK</code>报文中包含服务端保持连接, 客户端<strong>必须</strong>使用此值代替其发送的保持连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-22</a> 如果保持连接的值非零, 并且服务端在1.5倍的保持连接时间内没有收到客户端的MQTT控制报文, 它<strong>必须</strong>断开客户端的网络连接, 并判定网络连接已断开.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-23</a> 如果网络连接关闭时会话过期间隔大于0, 则客户端与服务端<strong>必须</strong>存储会话状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-24</a> 服务端<strong>不能</strong>发送超过最大报文长度的报文给客户端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-25</a> 当报文过大而不能发送时, 服务端<strong>必须</strong>丢弃这些报文, 然后当做应用消息发送已完成处理.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-26</a> 服务端在一个<code>PUBLISH</code>报文中发送的主题别名<strong>不能</strong>超过客户端设置的主题别名最大值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-27</a> 如果主题别名最大值没有设置, 或者设置为零, 则服务端<strong>不能</strong>向此客户端发送任何主题别名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-28</a> 请求响应信息值为0, 表示服务端<strong>不能</strong>返回响应信息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-29</a> 如果请求问题信息的值为0, 服务端可以选择在<code>CONNACK</code>或<code>DISCONNECT</code>报文中返回原因字符串或用户属性, 但<strong>不能</strong>在除<code>PUBLISH</code>, <code>CONNACK</code>或<code>DISCONNECT</code>之外的报文中发送原因字符串或用户属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#312-connect可变报头" target="_blank" rel="noopener">MQTT-3.1.2-30</a> 如果客户端在<code>CONNECT</code>报文中设置了认证方法, 则客户端在收到<code>CONNACK</code>报文之前<strong>不能</strong>发送除<code>AUTH</code>或<code>DISCONNECT</code>之外的报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-1</a> <code>CONNECT</code>报文的载荷中包含由可变报头中的标志确定的一个或多个以长度为前缀的字段.这些字段若存在, <strong>必须</strong>按照客户标识符、遗嘱属性、遗嘱主题、遗嘱载荷、用户名、密码的顺序出现.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-2</a> 客户端和服务端都<strong>必须</strong>使用客户标识符识别两者之间的 MQTT 会话相关的状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-3</a> 客户标识符<strong>必须</strong>存在, 且作为<code>CONNECT</code>报文载荷的第一个字段出现.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-4</a> 客户标识符<strong>必须</strong>被编码为UTF-8字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-5</a> 服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的客户标识符, 客户标识符只能包含这些字符:<code>&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</code><br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-6</a> 服务端<strong>可以</strong>允许客户端提供一个零字节的客户标识符, 如果这样做了, 服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户标识符给那个客户端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-7</a> 服务端<strong>必须</strong>假设客户端提供了那个唯一的客户标识符, 且<strong>必须</strong>在<code>CONNACK</code>报文中返回分配的客户标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-8</a> 如果服务端拒绝了某个客户标识符, 它<strong>可以</strong>发送包含原因码<code>0x85(客户标识符无效)</code>的<code>CONNACK</code>报文作为对客户端的<code>CONNECT</code>报文的回应 , 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>所述.之后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-9</a> 如果某个会话在遗嘱延时间隔到期之前创建了新的网络连接, 则服务端<strong>不能</strong>发送遗嘱消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-10</a> 服务端在发布遗嘱消息时<strong>必须</strong>维护用户属性的顺序.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-11</a> 遗嘱主题<strong>必须</strong>为UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#313-connect载荷" target="_blank" rel="noopener">MQTT-3.1.3-12</a> 如果用户名标志被设置为1, 用户名为载荷中下一个字段. 用户名<strong>必须</strong>是UTF-8编码字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-1</a> 服务端<strong>必须</strong>按照<a href="https://www.zybuluo.com/khan-lau/note/1325300#31-connect--连接请求" target="_blank" rel="noopener">3.1节</a>的要求验证<code>CONNECT</code>报文, 如果报文不符合规范, 服务端关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-2</a> 服务端<strong>可以</strong>检查<code>CONNECT</code>报文的内容是不是满足任何进一步的限制, <strong>应该</strong>执行身份验证和授权检查. 如果任何一项检查没通过, 服务端<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-3</a> 如果客户标识符所代表的客户端已经连接到此服务端, 那么向原有的客户端发送一个包含原因码为<code>0x8E(会话被接管)</code>的<code>DISCONNECT</code>报文, 并且<strong>必须</strong>关闭原有的网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-4</a> 服务端<strong>必须</strong>对新开始标志进行处理.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-5</a> 服务端<strong>必须</strong>使用包含原因码为<code>0x00(成功)</code>的<code>CONNACK</code>报文对客户端的<code>CONNECT</code>报文进行确认.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-connect行为" target="_blank" rel="noopener">MQTT-3.1.4-6</a> 如果服务端拒绝了<code>CONNECT</code>报文, 它<strong>不能</strong>处理客户端在<code>CONNECT</code>报文之后发送的任何除<code>AUTH</code>以外的报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#32-connack--确认连接请求" target="_blank" rel="noopener">MQTT-3.2.0-1</a> 服务端在发送任何除<code>AUTH</code>以外的报文之前<strong>必须</strong>先发送包含原因码为<code>0x00(成功)</code>的<code>CONNACK</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#32-connack--确认连接请求" target="_blank" rel="noopener">MQTT-3.2.0-2</a> 服务端在一次网络连接中不能发送多个<code>CONNACK</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-1</a> 第1个字节是连接确认标志, 位7-1是保留位且<strong>必须</strong>设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-2</a> 如果服务端接受一个新开始为1的连接, 服务端在<code>CONNACK</code>报文中除了把原因码设置为<code>0x00(成功)</code>之外, 还<strong>必须</strong>把会话存在标志设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-3</a> 如果服务端接受一个新开始为0的连接, 并且服务端已经保存了此客户标识符的会话状态, 服务端在<code>CONNACK</code>报文中<strong>必须</strong>把会话存在标志设置为1. 否则, 服务端<strong>必须</strong>把会话存在标志设置为0.无论如何, 服务端在<code>CONNACK</code>报文中<strong>必须</strong>把原因码设置为<code>0x00(成功)</code>.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-4</a> 如果客户端没有保存的会话状态, 但收到会话存在标志为1, 客户端<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-5</a> 如果客户端保存了会话状态, 但收到的会话存在标志为0, 客户端若要继续此网络连接, 它<strong>必须</strong>丢弃其保存的会话状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-6</a> 如果服务端发送的<code>CONNACK</code>报文中原因码非0, 它<strong>必须</strong>把会话存在标志设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-7</a> 如果服务端发送了一个包含原因码大于等于128的<code>CONNACK</code>报文, 它随后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-8</a> 服务端发送的<code>CONNACK</code>报文<strong>必须</strong>设置一种原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-9</a> 如果服务端不支持Qos为1或2的<code>PUBLISH</code>报文, 服务端<strong>必须</strong>在<code>CONNACK</code>报文中发送<code>最大服务质量</code>以指定其支持的<code>最大QoS值</code>.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-10</a> 即使不支持QoS为1或2的<code>PUBLISH</code>报文, 服务端也<strong>必须</strong>接受请求QoS为0、1或2的<code>SUBSCRIBE</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-11</a> 如果从服务端接收到了<code>最大QoS等级</code>, 则客户端<strong>不能</strong>发送超过<code>最大QoS等级</code>所指定的QoS等级的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-12</a> 如果服务端收到包含遗嘱的QoS超过服务端处理能力的<code>CONNECT</code>报文, 服务端<strong>必须</strong>拒绝此连接. 服务端<strong>应该</strong>使用包含原因码为<code>0x9B(不支持的QoS等级)</code>的<code>CONNACK</code>报文进行错误处理, 随后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-13</a> 如果服务端收到一个包含保留标志位1的遗嘱消息的<code>CONNECT</code>报文且服务端不支持保留消息, 服务端<strong>必须</strong>拒绝此连接请求, 且<strong>应该</strong>发送包含原因码为<code>0x9A(不支持保留)</code>的<code>CONNACK</code>报文, 随后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-14</a> 从服务端接收到的保留可用标志为0时, 客户端<strong>不能</strong>发送保留标志设置为1的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-15</a> 客户端不应该发送超过最大报文长度的报文给服务端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-16</a> 如果客户端使用长度为0的客户标识符, 服务端<strong>必须</strong>回复包含分配客户标识符的<code>CONNACK</code>报文. 分配客户标识符<strong>必须</strong>是没有被服务端的其他会话所使用的新客户标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-17</a> 客户端在一个<code>PUBLISH</code>报文中发送的主题别名值<strong>不能</strong>超过服务端设置的主题别名最大值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-18</a> 如果主题别名最大值没有设置, 或者设置为0, 则客户端<strong>不能</strong>向此服务端发送任何主题别名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-19</a> 如果加上原因字符串之后的<code>CONNACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-20</a> 如果加上用户属性之后的<code>CONNACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-21</a> 如果服务端发送了服务端保持连接属性, 客户端<strong>必须</strong>使用此值代替其在<code>CONNECT</code>报文中发送的保持连接时间值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#322-connack可变报头" target="_blank" rel="noopener">MQTT-3.2.2-22</a> 如果服务端没有发送服务端保持连接属性, 服务端<strong>必须</strong>使用客户端在<code>CONNECT</code>报文中设置的保持连接时间值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-1</a> 客户端或服务端请求重发一个<code>PUBLISH</code>报文时, <strong>必须</strong>将<code>DUP标志</code>设置为1.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-2</a> 对于QoS为0的消息, DUP标志<strong>必须</strong>设置为0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-3</a> 发送(出站)的<code>PUBLISH</code>报文与收到(入站)的<code>PUBLISH</code>报文中的<code>DUP标志</code>是独立设置的, 它的值<strong>必须</strong>单独的根据发送(出站)的<code>PUBLISH</code>报文是否是一个重发来确定.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-4</a> <code>PUBLISH</code>报文的2个QoS比特位<strong>不能</strong>同时设置为1.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-5</a> 如果客户端发给服务端的<code>PUBLISH</code>报文的保留标志被设置为1, 服务端<strong>必须</strong>存储此应用消息, 并用其替换此话题下任何已存在的消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-6</a> 如果载荷为空, 消息<strong>可以</strong>正常被服务端所处理, 但是此话题下的任何保留消息<strong>必须</strong>被丢弃, 并且此话题未来的订阅者将<strong>不会</strong>收到保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-7</a> 载荷为空的保留消息将<strong>不能</strong>被存储在服务端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-8</a> 如果客户端发给服务端的<code>PUBLISH</code>报文的保留标志位为0, 服务器<strong>不能</strong>把此消息存储为保留消息, 也<strong>不能</strong>丢弃或替换任何已存在的保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-9</a> 如果保留消息处理属性被设置为0, 服务端<strong>必须</strong>发送主题与客户端订阅的主题过滤器相匹配的所有保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-10</a> 如果保留消息处理属性被设置为1, 如果尚不存在匹配的订阅, 服务端<strong>必须</strong>发送主题与客户端订阅的主题过滤器相匹配的所有保留消息.如果已存在相匹配的订阅, 服务器<strong>不能</strong>发送这些保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-11</a> 如果保留消息处理属性被设置为2, 服务器<strong>不能</strong>发送这些保留消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-12</a> 如果发布保留订阅选项被设置为0, 服务端在转发应用消息时<strong>必须</strong>将保留标志设置为0, 而不管收到的<code>PUBLISH</code>报文中保留标志位如何设置的.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#331-publish固定报头" target="_blank" rel="noopener">MQTT-3.3.1-13</a> 如果发布保留订阅选项被设置为1, 服务端在转发应用消息时<strong>必须</strong>将保留标志设置为与收到的<code>PUBLISH</code>消息中的保留标志位相同.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-1</a> 主题名<strong>必须</strong>是<code>PUBLISH</code>报文可变报头的第一个字段. 它必须是UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-2</a> <code>PUBLISH</code>报文中的主题名<strong>不能</strong>包含通配符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-3</a> 服务端发送给订阅客户端的<code>PUBLISH</code>报文中的主题名<strong>必须</strong>匹配该订阅的主题过滤器.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-4</a> 服务端<strong>必须</strong>把接收到的应用消息中的载荷格式指示原封不动的发给所有的订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-5</a> 如果消息过期间隔已过期, 服务端还没开始向匹配的订阅者交付该消息, 则服务端<strong>必须</strong>删除该订阅者的消息副本.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-6</a> 服务端发送给客户端的<code>PUBLISH</code>报文中<strong>必须</strong>包含消息过期间隔, 值为接收时间减去消息在服务端的等待时间.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-7</a> 接收端<strong>不能</strong>将任何主题别名映射从一个网络连接转发到另一个网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-8</a> 发送端<strong>不能</strong>发送包含主题别名值为0的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-9</a> 客户端<strong>不能</strong>发送主题别名值大于服务端的<code>CONNACK</code>报文中指定的主题别名最大值的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-10</a> 客户端<strong>必须</strong>接受所有值大于0且小于等于其发送的<code>CONNECT</code>报文中的主题别名最大值的主题别名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-11</a> 服务端<strong>不能</strong>发送包含主题别名值大于客户端在<code>CONNECT</code>报文中指定的主题别名最大值的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-12</a> 服务端<strong>必须</strong>接受所有值大于0且小于等于其发送的<code>CONNACK</code>报文中的主题别名最大值的主题别名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-13</a> 响应主题<strong>必须</strong>是UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-14</a> 响应主题<strong>不能</strong>包含通配符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-15</a> 服务端在收到应用消息时<strong>必须</strong>将响应主题原封不动的发送给所有的订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-16</a> 服务端在收到应用消息时<strong>必须</strong>原封不动的把对比数据发送给所有的订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-17</a> 服务端在转发应用消息到客户端时<strong>必须</strong>原封不动的把所有的用户属性放在<code>PUBLISH</code>报文中.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-18</a> 服务端在转发应用消息时<strong>必须</strong>保持所有用户属性的先后顺序.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-19</a> 内容类型<strong>必须</strong>是UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#332-publish可变报头" target="_blank" rel="noopener">MQTT-3.3.2-20</a> 服务端<strong>必须</strong>把收到的应用消息中的内容类型原封不动的发送给所有的订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-1</a> <code>PUBLISH</code>报文的接收端<strong>必须</strong>按照<code>PUBLISH</code>报文中的 <code>QoS等级</code> 发送响应报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-2</a> 这种情况下, 服务端<strong>必须</strong>按照所有匹配的订阅中最大的<code>QoS等级</code>把消息发送给客户端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-3</a> 如果客户端在这些重叠的订阅中指定了订阅标识符, 服务端在发布这些订阅相匹配的消息时<strong>必须</strong>包含这些订阅标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-4</a> 如果服务端对这些重叠的订阅只发送一条相匹配的消息, 服务端<strong>必须</strong>在<code>PUBLISH</code>报文中包含所有的相匹配的订阅标识符(如果存在), 但没有顺序要求.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-5</a> 如果服务端对这些重叠的订阅<strong>必须</strong>分别发送相匹配的消息, 则每个<code>PUBLISH</code>报文中包含与订阅相匹配的订阅标识符(如果存在).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-6</a> 从客户端发送给服务端的<code>PUBLISH</code>报文<strong>不能</strong>包含订阅标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-7</a> 客户端在收到服务端的<code>PUBACK</code>, <code>PUBCOMP</code>或包含原因码大于等于128的<code>PUBREC</code>报文之前, <strong>不能</strong>发送数量超过服务端的接收最大值的QoS为1和2的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-8</a> 客户端<strong>不能</strong>延迟发送任何报文, 除了<code>PUBLISH</code>报文–如果已发送且没有收到确认的<code>PUBLISH</code>报文数量已达到服务端的接收最大值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-9</a> 服务端在接收到客户端的<code>PUBACK</code>, <code>PUBCOMP</code>或包含原因码大于等于128的<code>PUBREC</code>报文之前, <strong>不能</strong>发送数量超过客户端的接收最大值的QoS为1和2的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#334-publish行为" target="_blank" rel="noopener">MQTT-3.3.4-10</a> 服务端<strong>不能</strong>延迟发送任何报文, 除了<code>PUBLISH</code>报文–如果已发送且没有收到确认的<code>PUBLISH</code>报文数量已到达客户端的接收最大值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#342-puback可变报头" target="_blank" rel="noopener">MQTT-3.4.2-1</a> 服务端或客户端发送<code>PUBACK</code>报文时<strong>必须</strong>设置其中一种<code>PUBACK</code>原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#342-puback可变报头" target="_blank" rel="noopener">MQTT-3.4.2-2</a> 如果加上原因字符串之后的<code>PUBACK</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#342-puback可变报头" target="_blank" rel="noopener">MQTT-3.4.2-3</a> 如果加上用户属性之后的<code>PUBACK</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#352-pubrec可变报头" target="_blank" rel="noopener">MQTT-3.5.2-1</a> 服务端或客户端发送<code>PUBREC</code>报文时<strong>必须</strong>设置其中一种原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#352-pubrec可变报头" target="_blank" rel="noopener">MQTT-3.5.2-2</a> 发送端使用此值向接收端提供附加信息. 如果加上原因字符串之后的<code>PUBREC</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#352-pubrec可变报头" target="_blank" rel="noopener">MQTT-3.5.2-3</a> 如果加上用户属性之后的<code>PUBREC</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#361-pubrel固定报头" target="_blank" rel="noopener">MQTT-3.6.1-1</a> <code>PUBREL</code>固定报头的第3, 2, 1, 0位是保留位, 必须被设置为0, 0, 1, 0. 服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#362-pubrel可变报头" target="_blank" rel="noopener">MQTT-3.6.2-1</a> 客户端或服务端发送<code>PUBREL</code>报文时<strong>必须</strong>设置其中一种<code>PUBREL</code>原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#362-pubrel可变报头" target="_blank" rel="noopener">MQTT-3.6.2-2</a> 如果加上原因字符串之后的<code>PUBREL</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#362-pubrel可变报头" target="_blank" rel="noopener">MQTT-3.6.2-3</a> 如果加上用户属性之后的<code>PUBREL</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#372-pubcomp可变报头" target="_blank" rel="noopener">MQTT-3.7.2-1</a> 服务端或客户端发送<code>PUBCOMP</code>报文时<strong>必须</strong>设置一种<code>PUBCOMP</code>原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#372-pubcomp可变报头" target="_blank" rel="noopener">MQTT-3.7.2-2</a> 如果加上原因字符串之后的<code>PUBCOMP</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#372-pubcomp可变报头" target="_blank" rel="noopener">MQTT-3.7.2-3</a> 如果加上用户属性之后的<code>PUBCOMP</code>报文长度超出了接收端指定的最大报文长度, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#381-subscribe固定报头" target="_blank" rel="noopener">MQTT-3.8.1-1</a> <code>SUBSCRIBE</code>报文固定报头第3, 2, 1, 0比特位是保留位, 必须被设置为0, 0, 1, 0. 服务端<strong>必须</strong>将其他的任何值都当做是不合法的并关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-1</a> <code>主题过滤器</code> <strong>必须</strong>为UTF-8 编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-2</a> 载荷<strong>必须</strong>包含至少一个<code>主题过滤器</code>/<code>订阅选项</code>对.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-3</a> 订阅选项的第2比特表示非本地选项.值为1, 表示应用消息<strong>不能</strong>被转发给发布此消息的客户标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-4</a> 共享订阅时把非本地选项设为1将造成协议错误.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#383-subscribe载荷" target="_blank" rel="noopener">MQTT-3.8.3-5</a> 订阅选项的第6和7比特为将来所保留. 服务端<strong>必须</strong>把此保留位非0的<code>SUBSCRIBE</code>报文当做无效报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-1</a> 当服务端收到来自客户端的<code>SUBSCRIBE</code>报文时, <strong>必须</strong>使用<code>SUBACK</code>报文作为相应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-2</a> <code>SUBACK</code>报文<strong>必须</strong>和待确认的<code>SUBSCRIBE</code>报文有相同的报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-3</a> 如果服务端收到的<code>SUBSCRIBE</code>报文中的一个主题过滤器与当前会话的一个非共享订阅相同, 那么<strong>必须</strong>使用新的订阅替换现存的订阅.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-4</a> 如果保留处理选项为0, 任何匹配该<code>主题过滤器</code>的保留消息必须被重发, 但替换订阅<strong>不能</strong>造成应用消息的丢失.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-5</a> 如果服务端收到的<code>SUBSCRIBE</code>报文包含多个主题过滤器, 服务端<strong>必须</strong>当做收到一系列多个<code>SUBSCRIBE</code>报文来处理–除了将它们的响应组合为单个<code>SUBACK</code>响应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-6</a> 服务端发送给客户端的<code>SUBACK</code>报文<strong>必须</strong>为每一个<code>主题过滤器</code>/<code>订阅选项</code>对包含一个原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-7</a> 此原因码<strong>必须</strong>说明为该订阅授予的<code>最大QoS等级</code>, 或指示订阅失败.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#384-subscribe行为" target="_blank" rel="noopener">MQTT-3.8.4-8</a> 响应该订阅的应用消息<code>QoS等级</code> <strong>必须</strong>为该消息发布时的<code>QoS等级</code>和服务端授予的<code>最大QoS等级</code>二者最小值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#392-suback可变报头" target="_blank" rel="noopener">MQTT-3.9.2-1</a> 如果加上原因字符串之后的<code>SUBACK报文</code>长度超出了客户端指定的<code>最大报文长度</code>, 则服务端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#392-suback可变报头" target="_blank" rel="noopener">MQTT-3.9.2-2</a> 如果加上用户属性之后的<code>SUBACK</code>报文长度超出了客户端指定的<code>最大报文长度</code>, 则服务端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#393-suback载荷" target="_blank" rel="noopener">MQTT-3.9.3-1</a> <code>SUBACK</code>报文中的原因码顺序<strong>必须</strong>与<code>SUBSCRIBE</code>报文中的<code>主题过滤器</code>顺序相匹配.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#393-suback载荷" target="_blank" rel="noopener">MQTT-3.9.3-2</a> 服务端发送<code>SUBACK报文</code>时<strong>必须</strong>对收到的每一个<code>主题过滤器</code>设置一种原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3101-unsubscribe固定报头" target="_blank" rel="noopener">MQTT-3.10.1-1</a> <code>UNSUBSCRIBE</code>固定报头的第3, 2, 1, 0位是保留位且<strong>必须</strong>分别设置为0, 0, 1, 0. 服务端<strong>必须</strong>认为任何其它的值都是不合法的并关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3103-unsubscribe载荷" target="_blank" rel="noopener">MQTT-3.10.3-1</a> <code>UNSUBSCRIBE</code>报文中的主题过滤器<strong>必须</strong>为UTF-8编码的字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3103-unsubscribe载荷" target="_blank" rel="noopener">MQTT-3.10.3-2</a> <code>UNSUBSCRIBE</code>报文有效载荷<strong>必须</strong>包含至少一个主题过滤器.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-1</a> 服务端<strong>必须</strong>对客户端的<code>UNSUBSCRIBE</code>报文中提供的主题过滤器(不管是否包含通配符)逐个字符与当前持有的主题过滤器集进行比较. 如果任何过滤器完全匹配, 则<strong>必须</strong>删除其拥有的订阅.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-2</a> 当服务端收到<code>UNSUBSCRIBE</code>报文, 它<strong>必须</strong>停止添加为了交付给客户端的与主题过滤器相匹配的任何新消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-3</a> 当服务端收到<code>UNSUBSCRIBE</code>报文, 它<strong>必须</strong>完成任何已经开始发送给客户端的、与主题过滤器相匹配的、<code>QoS等级</code>为1或2的消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-4</a> 服务端<strong>必须</strong>发送<code>UNSUBACK</code>报文以响应客户端的<code>UNSUBSCRIBE</code>请求.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-5</a> <code>UNSUBACK</code>报文<strong>必须</strong>包含和<code>UNSUBSCRIBE</code>报文相同的报文标识符. 即使没有删除任何主题订阅, 服务端也<strong>必须</strong>发送一个<code>UNSUBACK</code>响应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3104-unsubscribe行为" target="_blank" rel="noopener">MQTT-3.10.4-6</a> 如果服务端收到的<code>UNSUBSCRIBE</code>报文包含多个主题过滤器, 服务端<strong>必须</strong>当做收到一系列多个<code>UNSUBSCRIBE</code>报文来处理–除了将它们的响应组合为单个<code>SUBACK</code>响应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3112-unsuback可变报头" target="_blank" rel="noopener">MQTT-3.11.2-1</a> 如果加上原因字符串之后的<code>UNSUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此原因字符串.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3112-unsuback可变报头" target="_blank" rel="noopener">MQTT-3.11.2-2</a> 如果加上用户属性之后的<code>UNSUBACK</code>报文长度超出了客户端指定的最大报文长度, 则服务端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3113-unsuback载荷" target="_blank" rel="noopener">MQTT-3.11.3-1</a> <code>UNSUBACK</code>报文中的原因码顺序<strong>必须</strong>与<code>UNSUBSCRIBE</code>报文中的主题过滤器顺序相匹配.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3113-unsuback载荷" target="_blank" rel="noopener">MQTT-3.11.3-2</a> 服务端发送<code>UNSUBACK</code>报文时对于每个收到的主题过滤器, <strong>必须</strong>使用一个取消订阅原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3124-pingreq行为" target="_blank" rel="noopener">MQTT-3.12.4-1</a> 服务端<strong>必须</strong>发送<code>PINGRESP</code>报文响应客户端的<code>PINGREQ</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#314-disconnect--断开通知" target="_blank" rel="noopener">MQTT-3.14.0-1</a> 服务端<strong>不能</strong>发送<code>DISCONNECT</code>报文, 直到它发送了包含原因码小于0x80的<code>CONNACK</code>报文之后.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3141-disconnect固定报头" target="_blank" rel="noopener">MQTT-3.14.1-1</a> 服务端或客户端<strong>必须</strong>验证所有的保留位都被设置为0, 如果他们不为0, 发送包含原因码为<code>0x81(无效报文)</code>的<code>DISCONNECT</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3142-disconnect可变报头" target="_blank" rel="noopener">MQTT-3.14.2-1</a> 客户端或服务端发送<code>DISCONNECT</code>报文时<strong>必须</strong>使用一种<code>DISCONNECT</code>原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3142-disconnect可变报头" target="_blank" rel="noopener">MQTT-3.14.2-2</a> 会话过期间隔<strong>不能</strong>由服务端的<code>DISCONNECT</code>报文发送.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3142-disconnect可变报头" target="_blank" rel="noopener">MQTT-3.14.2-3</a> 如果此属性使得<code>DISCONNECT</code>报文的长度超出了接收端指定的<code>最大报文长度</code>, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3142-disconnect可变报头" target="_blank" rel="noopener">MQTT-3.14.2-4</a> 如果加上用户属性之后的<code>DISCONNECT</code>报文长度超出了接收端指定的<code>最大报文长度</code>, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3144-disconnect行为" target="_blank" rel="noopener">MQTT-3.14.4-1</a> 发送端发送完<code>DISCONNECT</code>报文之后<strong>不能</strong>再在此网络连接上发送任何MQTT控制报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3144-disconnect行为" target="_blank" rel="noopener">MQTT-3.14.4-2</a> 发送端发送完<code>DISCONNECT</code>报文之后<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3144-disconnect行为" target="_blank" rel="noopener">MQTT-3.14.4-3</a> 接收到包含原因码为<code>0x00(成功)</code>的<code>DISCONNECT</code>时, 服务端<strong>必须</strong>丢弃任何与当前连接相关的<code>遗嘱消息</code>, 而不发布它.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3151-auth固定报头" target="_blank" rel="noopener">MQTT-3.15.1-1</a> <code>AUTH</code>报文固定报头第3, 2, 1, 0位是保留位, <strong>必须</strong>全设置为0. 客户端或服务端<strong>必须</strong>把其他值当做无效值并关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3152-auth可变报头" target="_blank" rel="noopener">MQTT-3.15.2-1</a> <code>AUTH</code>报文的发送端<strong>必须</strong>使用一种认证原因码.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3152-auth可变报头" target="_blank" rel="noopener">MQTT-3.15.2-2</a> 如果加上原因字符串之后的<code>AUTH</code>报文长度超出了接收端所指定的<code>最大报文长度</code>, 则发送端<strong>不能</strong>发送此属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#3152-auth可变报头" target="_blank" rel="noopener">MQTT-3.15.2-3</a> 如果加上用户属性之后的<code>AUTH</code>报文长度超出了接收端指定的<code>最大报文长度</code>, 则服务端<strong>不能</strong>发送此属性.<br><a href="[MQTT-4.1.0-2](https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态">MQTT-4.1.0-1</a> 当网络连接被关闭并且会话过期间隔已过时, 服务端必须丢弃会话状态.) 当网络连接打开时, 客户端和服务端<strong>不能</strong>丢弃会话状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#41-会话状态" target="_blank" rel="noopener">MQTT-4.1.0-2</a> 当网络连接被关闭并且会话过期间隔已过时, 服务端<strong>必须</strong>丢弃会话状态.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#42-网络连接" target="_blank" rel="noopener">MQTT-4.2.0-1</a> 客户端或服务端<strong>必须</strong>支持使用一个或多个提供有序的、可靠的、双向传输(从客户端到服务端和从服务端到客户端)字节流传输的底层传输协议.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#431-qos-0最多分发一次" target="_blank" rel="noopener">MQTT-4.3.1-1</a> 对于<code>QoS等级0</code>的分发协议, 发送端<strong>必须</strong>发送QoS等于0, DUP等于0的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-1</a> 对于<code>QoS等级1</code>的分发协议, 发送端每次发送新的应用消息都<strong>必须</strong>分配一个未使用的用户标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-2</a> 对于<code>QoS等级1</code>的分发协议, 发送端发送的<code>PUBLISH</code>报文<strong>必须</strong>包含报文标识符且QoS等于1, DUP等于0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-3</a> 对于<code>QoS等级1</code>的分发协议, 发送端<strong>必须</strong>将这个<code>PUBLISH</code>报文看作是未确认的, 直到从接收端那收到对应的<code>PUBACK</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-4</a> 对于QoS等级1的分发协议, 接收端响应的<code>PUBACK</code>报文<strong>必须</strong>包含一个报文标识符, 这个标识符来自接收到的、已经接受所有权的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1至少分发一次" target="_blank" rel="noopener">MQTT-4.3.2-5</a> 对于<code>QoS等级1</code>的分发协议, 接收端发送了<code>PUBACK</code>报文之后, 接收端<strong>必须</strong>将任何包含相同报文标识符的入站<code>PUBLISH</code>报文当做一个新的消息, 并忽略它的<code>DUP标志</code>的值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-1</a> 对于<code>QoS等级2</code>的分发协议, 发送端<strong>必须</strong>给要发送的新应用消息分配一个未使用的报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-2</a> 对于<code>QoS等级2</code>的分发协议, 发送端<code>PUBLISH</code>报文<strong>必须</strong>包含报文标识符且报文的QoS等于2, DUP等于0.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-3</a> 对于<code>QoS等级2</code>的分发协议, 发送端<strong>必须</strong>将这个<code>PUBLISH</code>报文看作是未确认的, 直到从接收端那收到对应的<code>PUBREC</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-4</a> 对于<code>QoS等级2</code>的分发协议, 收到发送端发送的包含原因码小于0x80的<code>PUBREC</code>报文后<strong>必须</strong>发送一个<code>PUBREL</code>报文. <code>PUBREL</code>报文<strong>必须</strong>包含与原始<code>PUBLISH</code>报文相同的报文标识符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-5</a> 对于<code>QoS等级2</code>的分发协议, 发送端<strong>必须</strong>将这个<code>PUBREL</code>报文看作是未确认的 , 直到从接收端那收到对应的<code>PUBCOMP</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-6</a> 对于<code>QoS等级2</code>的分发协议, 发送端一旦发送了对应的<code>PUBREL</code>报文就<strong>不能</strong>重发这个<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-7</a> 对于<code>QoS等级2</code>的分发协议, 如果<code>PUBLISH</code>报文已发送, <strong>不能</strong>应用消息过期属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-8</a> 对于<code>QoS等级2</code>的分发协议, 接收端响应的<code>PUBREC</code>报文<strong>必须</strong>包含报文标识符, 这个标识符来自接收到的、已经接受所有权的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-9</a> 对于<code>QoS等级2</code>的分发协议, 如果接收端发送了包含原因码大于等于0x80的<code>PUBREC</code>报文, 它<strong>必须</strong>将后续包含相同报文标识符的<code>PUBLISH</code>报文当做是新的应用消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-10</a> 对于<code>QoS等级2</code>的分发协议, 接收端在收到对应的<code>PUBREL</code>报文之前, 接收端<strong>必须</strong>发送<code>PUBREC</code>报文确认任何后续的具有相同报文标识符的<code>PUBLISH</code>报文. 在这种情况下, 它<strong>不能</strong>重复分发消息给任何后续的接收者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-11</a> 对于<code>QoS等级2</code>的分发协议, 接收端<strong>必须</strong>发送包含与<code>PUBREL</code>相同报文标识符的<code>PUBCOMP</code>报文作为对<code>PUBREL</code>报文的响应.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-12</a> 对于<code>QoS等级2</code>的分发协议, 接收端发送<code>PUBCOMP</code>报文之后, <strong>必须</strong>将后续包含相同报文标识符的<code>PUBLISH</code>报文当做是新的应用消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#433-qos-2仅分发一次" target="_blank" rel="noopener">MQTT-4.3.3-13</a> 对于<code>QoS等级2</code>的分发协议, 接收端<strong>必须</strong>继续<code>QoS等级2</code>确认序列, 即使它已经应用了消息过期属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#44-消息分发重试" target="_blank" rel="noopener">MQTT-4.4.0-1</a> 客户端以新开始标志为0且会话存在的情况下重连时, 客户端和服务端都<strong>必须</strong>使用原始报文标识符重新发送任何未被确认的<code>PUBLISH</code>报文(当QoS &gt; 0)和<code>PUBREL</code>报文. 这是唯一要求客户端或服务端重发消息的情况. 客户端和服务端<strong>不能</strong>在其他任何时间重发消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#44-消息分发重试" target="_blank" rel="noopener">MQTT-4.4.0-2</a> 如果收到包含原因码大于等于0x80的<code>PUBACK</code>或<code>PUBREC</code>, 则对应的<code>PUBLISH</code>报文被看作已确认, 且<strong>不能</strong>被重传.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#45-消息收到" target="_blank" rel="noopener">MQTT-4.5.0-1</a> 当服务端接受入站应用消息的所有权时, 它<strong>必须</strong>将消息添加到订阅匹配的客户端的会话状态中.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#45-消息收到" target="_blank" rel="noopener">MQTT-4.5.0-2</a> 客户端<strong>必须</strong>按照可用的<code>服务质量(QoS)</code>规则确认它收到的任何<code>PUBLISH</code>报文, 不管它是否选择处理其包含的应用消息.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-1</a> 重发任何之前的<code>PUBLISH</code>报文时, 客户端<strong>必须</strong>按原始<code>PUBLISH</code>报文的发送顺序重发(适用于<code>QoS等级1</code>和<code>QoS等级2</code> 消息).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-2</a> 客户端<strong>必须</strong>按照对应的<code>PUBLISH</code>报文的顺序发送<code>PUBACK报文</code>(<code>QoS等级1</code>消息).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-3</a> 客户端<strong>必须</strong>按照对应的<code>PUBLISH</code>报文的顺序发送<code>PUBREC</code>报文(<code>QoS等级2</code>消息).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-4</a> 客户端<strong>必须</strong>按照对应的<code>PUBREC</code>报文的顺序发送<code>PUBREL</code>报文(<code>QoS等级2</code>消息).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-5</a> 当服务端处理发布到有序主题的消息时, 它<strong>必须</strong>按照消息从任何给定客户端接收的顺序发送<code>PUBLISH</code>报文给消费端(对于同一主题和QoS等级).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#46-消息排序" target="_blank" rel="noopener">MQTT-4.6.0-6</a> 默认情况下, 服务端转发非共享订阅的消息时, <strong>必须</strong>将每个主题都视为有序主题.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#47-主题名和主题过滤器" target="_blank" rel="noopener">MQTT-4.7.0-1</a> 主题过滤器中可以使用通配符, 但是主题名<strong>不能</strong>使用通配符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#471-主题通配符" target="_blank" rel="noopener">MQTT-4.7.1-1</a> 多层通配符<strong>必须</strong>单独指定, 或者跟在主题层级分隔符后面. 不管哪种情况, 它都<strong>必须</strong>是主题过滤器的最后一个字符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#471-主题通配符" target="_blank" rel="noopener">MQTT-4.7.1-2</a> 在主题过滤器的任意层级都可以使用单层通配符, 包括第一个和最后一个层级. 在使用它时, 它<strong>必须</strong>占据过滤器的整个层级.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#472--以开头的主题" target="_blank" rel="noopener">MQTT-4.7.2-1</a> 服务端<strong>不能</strong>将<code>$</code>字符开头的主题名匹配通配符(<code>#</code>或<code>+</code>)开头的主题过滤器.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#473-主题语义和用法" target="_blank" rel="noopener">MQTT-4.7.3-1</a> 所有的主题名和主题过滤器<strong>必须</strong>至少包含一个字符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#473-主题语义和用法" target="_blank" rel="noopener">MQTT-4.7.3-2</a> 主题名和主题过滤器<strong>不能</strong>包含空字符(Unicode U+0000).<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#473-主题语义和用法" target="_blank" rel="noopener">MQTT-4.7.3-3</a> 主题名和主题过滤器是UTF-8编码字符串, 它们<strong>不能</strong>超过65,535字节.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#473-主题语义和用法" target="_blank" rel="noopener">MQTT-4.7.3-4</a> 匹配订阅时, 服务端<strong>不能</strong>对主题名或主题过滤器执行任何规范化处理, <strong>不能</strong>修改或替换任何未识别的字符.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-1</a> 共享订阅主题过滤器必须以<code>&quot;$share/&quot;</code>开始, 且<strong>必须</strong>包含至少一个字符长度的共享名.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-2</a> 共享名<strong>不能</strong>包含字符<code>&quot;/&quot;</code>, <code>&quot;+&quot;</code>或<code>&quot;#&quot;</code>, 但<strong>必须</strong>跟在<code>&quot;/&quot;</code>字符后面. 此<code>&quot;/&quot;</code>字符后面<strong>必须</strong>跟随一个主题过滤器.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-3</a> 向客户端发送应用消息时, 服务端<strong>必须</strong>考虑授予客户端的QoS等级.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-4</a> 服务端<strong>必须</strong>在客户端重新连接时完成向该客户端的消息分发.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-5</a> 如果客户端的会话在客户端重连之前终止, 服务端<strong>不能</strong>把此消息发送给其他订阅的客户端.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#482-共享订阅" target="_blank" rel="noopener">MQTT-4.8.2-6</a> 如果客户端对来自服务端的<code>PUBLISH</code>报文使用包含原因码大于等于0x80的<code>PUBACK</code>或<code>PUBREC</code>报文进行响应, 服务端<strong>必须</strong>丢弃应用消息而不尝试将其发送给任何其他订阅者.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">MQTT-4.9.0-1</a> 客户端或服务端<strong>必须</strong>将其初始发送配额设置为不超过接收最大值的非0值.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">MQTT-4.9.0-2</a> 每当客户端或服务端发送了一个QoS等级大于0的<code>PUBLISH</code>报文, 它就会减少发送配额. 如果发送配额减为0, 客户端或服务端<strong>不能</strong>再发送任何QoS等级大于0的<code>PUBLISH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#49-流控" target="_blank" rel="noopener">MQTT-4.9.0-3</a> 它<strong>可以</strong>继续发送QoS为0的<code>PUBLISH</code>报文, 也<strong>可以</strong>选择暂停发送这些报文. 即使配额为0, 客户端和服务端也<strong>必须</strong>继续处理和响应其他MQTT控制报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-1</a> 如果服务端不支持客户端提供的认证方法, 它<strong>可以</strong>发送一个包含原因码<code>0x8C(无效的认证方法)</code>或<code>0x87(未授权)</code>的<code>CONNACK</code>报文, 并且<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-2</a> 如果服务端需要额外的信息来完成认证, 它可以向客户端发送<code>AUTH</code>报文, 此报文<strong>必须</strong>包含原因码<code>0x18(继续认证)</code>.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-3</a> 客户端通过发送另一个<code>AUTH</code>报文响应来自服务端的<code>AUTH</code>报文, 此报文<strong>必须</strong>包含原因码<code>0x18(继续认证)</code>.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-4</a> 服务端可以在处理过程中随时拒绝认证. 它<strong>可以</strong>发送包含原因码大于等于0x80的<code>CONNACK</code>报文, 如<a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a>所述, 并且<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-5</a> 如果初始<code>CONNECT</code>报文包含认证方法属性, 则所有的<code>AUTH</code>报文和成功的<code>CONNACK</code>报文<strong>必须</strong>包含与<code>CONNECT</code>报文中相同的认证方法属性.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-6</a> 如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 则服务端<strong>不能</strong>发送<code>AUTH</code>报文, 且<strong>不能</strong>在<code>CONNACK</code>报文中发送认证方法.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#412-增强认证" target="_blank" rel="noopener">MQTT-4.12.0-7</a> 如果客户端在<code>CONNECT</code>报文中没有包含认证方法, 则客户端<strong>不能</strong>向服务端发送<code>AUTH</code>报文.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#4121-重新认证" target="_blank" rel="noopener">MQTT-4.12.1-1</a> 如果客户端在<code>CONNECT</code>报文中提供了认证方法, 它<strong>可以</strong>在收到<code>CONNACK</code>报文之后的任何时间通过发送包含原因码<code>0x19(重新认证)</code>的<code>AUTH</code>报文发起重新认证. 客户端<strong>必须</strong>将认证方法设置为与最初验证网络连接时的认证方法一致.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#4121-重新认证" target="_blank" rel="noopener">MQTT-4.12.1-2</a> 如果重新认证失败, 客户端或服务端<strong>应该</strong>发送包含适当原因码的<code>DISCONNECT</code>报文, 如 section <a href="https://www.zybuluo.com/khan-lau/note/1325300#413-错误处理" target="_blank" rel="noopener">4.13节</a> 所述. 并且<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#4131-无效报文和协议错误" target="_blank" rel="noopener">MQTT-4.13.1-1</a> 当服务端检测到无效报文或协议错误, 并且本规范中给出了相应的原因码时, 它<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#4132-其他错误" target="_blank" rel="noopener">MQTT-4.13.2-1</a> <code>CONNACK</code>报文和<code>DISCONNECT</code>报文允许使用大于等于0x80的原因码以指示网络连接将被关闭. 如果某个大于等于0x80的原因码被指定, 无论是否发送<code>CONNACK</code>报文或<code>DISCONNECT</code>报文, <strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">MQTT-6.0.0-1</a> MQTT控制报文<strong>必须</strong>使用WebSocket二进制数据帧发送. 如果收到任何其它类型的数据帧, 接收者<strong>必须</strong>关闭网络连接.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">MQTT-6.0.0-2</a> 单个WebSocket数据帧<strong>可以</strong>包含多个或者部分MQTT报文. 接收者<strong>不能</strong>假设MQTT控制报文按WebSocket帧边界对齐.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">MQTT-6.0.0-3</a> 客户端<strong>必须</strong>将字符串”mqtt”包含在它提供的WebSocket子协议列表里.<br><a href="https://www.zybuluo.com/khan-lau/note/1325300#6-使用websocket作为网络层" target="_blank" rel="noopener">MQTT-6.0.0-4</a> 服务端选择和返回的WebSocket子协议名<strong>必须</strong>是”mqtt”.</p>
<h2 id="Appendix-C-MQTT-v5-0新特性总结-非规范"><a href="#Appendix-C-MQTT-v5-0新特性总结-非规范" class="headerlink" title="Appendix C. MQTT v5.0新特性总结(非规范)"></a>Appendix C. MQTT v5.0新特性总结(非规范)</h2><p>MQTT v5.0添加了以下特性</p>
<ul>
<li>会话过期<br>把<code>清理会话标志</code>拆分成<code>新开始标志(指示会话应该在不使用现有会话的情况下开始)</code>和<code>会话过期间隔标志(指示连接断开之后会话保留的时间)</code>.<code>会话过期间隔时间</code>可以在断开时修改. 把<code>新开始标志</code>设置为1且<code>会话过期间隔标志</code>设置为0, 等同于在MQTT v3.1.1中把<code>清理会话(CleanSession)</code>设置为1.</li>
<li>消息过期<br>允许消息在发布时设置一个<code>过期间隔</code>.</li>
<li>所有确认报文原因码<br>更改所有响应报文以包含原因码, 包括<code>CONNACK</code>, <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBACK</code>, <code>UNSUBACK</code>, <code>DISCONNECT</code>和<code>AUTH</code>, 以使得调用方确定请求的函数是否成功.</li>
<li>所有确认报文原因字符串<br>更改大部分报文以包含原因码同时也允许一个可选的<code>原因字符串</code>.这是为问题定位而设计的, 并且不应由接收端所解析.</li>
<li>服务端断开<br>允许服务端发送<code>DISCONNECT</code>报文, 以指示连接被关闭的原因.</li>
<li>载荷格式和内容类型<br>允许在消息发布时指定载荷格式(二进制、文本)和<code>MIME样式内容类型</code>.这些信息被转发到消息的接收端.</li>
<li>请求/响应<br>规定MQTT请求/响应模式, 提供响应主题和对比数据属性, 以使得响应消息被路由回请求的发布者. 此外, 为客户端添加从服务端获取获取关于构造响应主题的配置信息的能力.</li>
<li>共享订阅<br>添加对<code>共享订阅</code>的支持, 以允许多个订阅消费者进行负载均衡.</li>
<li>订阅标识符<br>允许在<code>SUBSCRIBE</code>报文中指定一个数字订阅标识符, 并在消息分发时返回此标识符. 这使得客户端收到分发的消息时确定此消息是由哪个或哪些订阅导致的.</li>
<li>主题别名<br>通过将<code>主题名</code>缩写为<code>小整数</code>来减小MQTT报文的开销大小. 客户端和服务端分别指定它们允许的主题别名的数量.</li>
<li>流量控制<br>允许客户端和服务端分别指定未完成的可靠消息(QoS&gt;0)的数量.发送端可以暂停发送此类消息以保持消息数量低于配额.这被用于限制<code>可靠消息</code>的速率和某一时刻的传输中(in-flight)消息数量.</li>
<li>用户属性<br>为大多数报文添加用户属性.PUBLISH报文的用户属性由客户端应用程序定义.PUBLISH报文和遗嘱报文的用户属性由服务端转发给应用消息的接收端.<code>CONNECT</code>, <code>SUBSCRIBE</code>和<code>UNSUBSCRIBE</code>报文的用户属性由服务端实现定义. <code>CONNACK</code>, <code>PUBACK</code>, <code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code>, <code>SUBACK</code>, <code>UNSUBACK</code>和<code>AUTH</code>报文的用户属性由发送端定义, 且对发送端具有唯一性. MQTT规范不定义用户属性的意义.</li>
<li>最大报文长度<br>允许客户端和服务端各自指定它们支持的<code>最大报文长度</code>.会话参与方发送更大的报文将造成错误.</li>
<li>可选的服务端功能可用性<br>提供定义一组服务端不允许的功能, 并告知客户端的机制.可以使用这种方式指定的功能包括:<code>最大QoS等级</code>, <code>保留可用</code>, <code>通配符订阅可用</code>, <code>订阅标识符可用</code>和<code>共享订阅可用</code>.客户端使用服务端通知了(不可用)的功能将造成错误.<br>在早期版本的MQTT协议中, 服务端没有实现的功能通过未授权告知客户端.当客户端使用其中一种(不可用的)功能时, 此功能允许服务端告知客户端, 并添加特定的原因码.</li>
<li>增强的认证<br>提供一种机制来启用包括<code>互相认证</code>在内的<code>质询</code>/<code>响应</code>风格的认证.这允许在客户端和服务端都支持的情况下使用SASL风格的认证, 包括客户端在连接中重新认证的功能.</li>
<li>订阅选项<br>提供主要用于定义允许消息桥接应用的<code>订阅选项</code>.包括不要把消息发送给消息源客户端(非本地)的选项和订阅时处理保留消息的选项.</li>
<li>遗嘱延迟<br>提供指定<code>遗嘱消息</code>在连接中断后延时发送的能力.设计此特性是为了在会话的连接重建的情况下不发送遗嘱消息.此特性允许连接短暂中断而不通知其他客户端.</li>
<li>服务端保持连接<br>允许服务端指定其希望客户端使用的保持连接值.此特性允许服务端设置最大允许的保持连接值并被客户端使用.</li>
<li>分配客户标识符<br>服务端分配了<code>客户标识符</code>的情况下, 向客户端返回此<code>客户标识符</code>.服务端分配<code>客户标识符</code>只能用于<code>新开始标志</code>为1的连接.</li>
<li>服务端参考<br>允许服务端使用<code>CONNACK</code>或<code>DISCONNECT</code>报文指定备用服务端.此特性被用于(服务端)重定向或做准备.</li>
</ul>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/Network">Network</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/MQTT">MQTT</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "MQTT 协议 5.0&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>











</body>
</html>
